C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USBFS
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\USBFS.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\USBFS.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(DEBUG) W
                    -L(2) PR(.\DP8051\DP8051_Keil_951\Debug/USBFS.lst) CD OT(5,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\USBFS.obj)

line level    source

   1          /***************************************************************************//**
   2          * \file USBFS.c
   3          * \version 3.0
   4          *
   5          * \brief
   6          *  This file contains the global USBFS API functions.
   7          *
   8          * Note:
   9          *  Many of the functions use an endpoint number. SRAM arrays are sized with 9
  10          *  elements, so they are indexed directly by epNumber.  The SIE and ARB
  11          *  registers are indexed by variations of epNumber - 1.
  12          *
  13          ********************************************************************************
  14          * \copyright
  15          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  16          * You may use this file only in accordance with the license, terms, conditions,
  17          * disclaimers, and limitations in the end user license agreement accompanying
  18          * the software package with which this file was provided.
  19          *******************************************************************************/
  20          
  21          #include "USBFS_pvt.h"
  22          #include "USBFS_cydmac.h"
  23          #include "USBFS_hid.h"
  24          
  25          
  26          /***************************************
  27          * Global data allocation
  28          ***************************************/
  29          
  30          /** Indicates whether the USBFS has been initialized. The variable is
  31          * initialized to 0 after device reset and set to 1 the first time USBFS_Start()
  32          * is called. This allows the Component to restart without reinitialization after
  33          * the first call to the USBFS_Start() routine.
  34          * If re-initialization of the Component is required, the variable should be set
  35          * to 0 before the USBFS_Start() routine is called. Alternatively, the USBFS can
  36          * be reinitialized by calling both USBFS_Init() and USBFS_InitComponent()
  37          * functions.
  38          */
  39          uint8 USBFS_initVar = 0u;
  40          
  41          #if (USBFS_EP_MANAGEMENT_DMA)
                  #if (CY_PSOC4)
                      static void USBFS_InitEpDma(void);
              
                      /* DMA chanels assigend for endpoints. */
                      const uint8 USBFS_DmaChan[USBFS_MAX_EP] =
                      {
                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 2   

                          0u,
                          0u,
                          0u,
                      };        
                  #else
                      /* DMA chanels assigend for endpoints. */
                      uint8 USBFS_DmaChan[USBFS_MAX_EP];
                      
                      /* DMA TDs require for PSoC 3/5LP operation. */
                      uint8 USBFS_DmaTd[USBFS_MAX_EP];
                  #endif /* (CY_PSOC4) */
              #endif /* (USBFS_EP_MANAGEMENT_DMA) */
  66          
  67          #if (USBFS_EP_MANAGEMENT_DMA_AUTO)
              #if (CY_PSOC4)
                  /* Number of DMA bursts. */
                  uint8  USBFS_DmaEpBurstCnt   [USBFS_MAX_EP];
                  
                  /* Number of bytes to transfer in last DMA burst. */
                  uint8  USBFS_DmaEpLastBurstEl[USBFS_MAX_EP];
              
                  /* Storage for arrays above. */
                  uint8  USBFS_DmaEpBurstCntBackup  [USBFS_MAX_EP];
                  uint32 USBFS_DmaEpBufferAddrBackup[USBFS_MAX_EP];
                   
                  /* DMA trigger mux output for usb.dma_req[0-7]. */
                  const uint8 USBFS_DmaReqOut[USBFS_MAX_EP] =
                  {
                      0u,
                      USBFS_ep1_dma__TR_OUTPUT,
                      USBFS_ep2_dma__TR_OUTPUT,
                      0u,
                      0u,
                      0u,
                      0u,
                      0u,
                      0u,
                  };
              
                  /* DMA trigger mux output for usb.dma_burstend[0-7]. */
                  const uint8 USBFS_DmaBurstEndOut[USBFS_MAX_EP] =
                  {
                      0u,
                      USBFS_BURSTEND_0_TR_OUTPUT,
                      USBFS_BURSTEND_1_TR_OUTPUT,
                      USBFS_BURSTEND_2_TR_OUTPUT,
                      USBFS_BURSTEND_3_TR_OUTPUT,
                      USBFS_BURSTEND_4_TR_OUTPUT,
                      USBFS_BURSTEND_5_TR_OUTPUT,
                      USBFS_BURSTEND_6_TR_OUTPUT,
                      USBFS_BURSTEND_7_TR_OUTPUT
                  };
                  
              #else
                  #if (USBFS_EP_DMA_AUTO_OPT == 0u)
                      static uint8 clearInDataRdyStatus = USBFS_ARB_EPX_CFG_DEFAULT;
                      uint8 USBFS_DmaNextTd[USBFS_MAX_EP];
                      const uint8 USBFS_epX_TD_TERMOUT_EN[USBFS_MAX_EP] =
                      {
                          0u,
                          0u,
                          0u,
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 3   

                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
                      };
              
                      volatile uint16 USBFS_inLength[USBFS_MAX_EP];
                      const uint8 *USBFS_inDataPointer[USBFS_MAX_EP];
                      volatile uint8 USBFS_inBufFull[USBFS_MAX_EP];
                  #endif /* (USBFS_EP_DMA_AUTO_OPT == 0u) */
              #endif /* (CY_PSOC4) */
              #endif /* (USBFS_EP_MANAGEMENT_DMA_AUTO) */
 130          
 131          
 132          /*******************************************************************************
 133          * Function Name: USBFS_Start
 134          ****************************************************************************//**
 135          *
 136          *   This function performs all required initialization for the USBFS component.
 137          *   After this function call, the USB device initiates communication with the
 138          *   host by pull-up D+ line. This is the preferred method to begin component
 139          *   operation.
 140          *
 141          *   Note that global interrupts have to be enabled because interrupts are
 142          *   required for USBFS component operation.
 143          *
 144          *   PSoC 4200L devices: when USBFS component configured to DMA with Automatic
 145          *   Buffer Management, the DMA interrupt priority is changed to the highest
 146          *   (priority 0) inside this function.
 147          *
 148          *   PSoC 3/PSoC 5LP devices: when USBFS component configured to DMA with
 149          *   Automatic Buffer Management, the Arbiter interrupt priority is changed to
 150          *   the highest (priority 0) inside this function.
 151          *
 152          *  \param device
 153          *          Contains the device number of the desired device descriptor.
 154          *          The device number can be found in the Device Descriptor Tab of
 155          *          "Configure" dialog, under the settings of desired Device Descriptor,
 156          *          in the "Device Number" field.
 157          *  \param mode:
 158          *   The operating voltage. This determines whether the voltage regulator
 159          *   is enabled for 5V operation or if pass through mode is used for 3.3V
 160          *   operation. Symbolic names and their associated values are given in the
 161          *   following list.
 162          *
 163          *       *USBFS_3V_OPERATION* - Disable voltage regulator and pass-
 164          *                                      through Vcc for pull-up
 165          *
 166          *       *USBFS_5V_OPERATION* - Enable voltage regulator and use
 167          *                                      regulator for pull-up
 168          *
 169          *       *USBFS_DWR_POWER_OPERATION* - Enable or disable the voltage
 170          *                                      regulator depending on the power supply
 171          *                                      voltage configuration in the DWR tab.
 172          *                                      For PSoC 3/5LP devices, the VDDD supply
 173          *                                      voltage is considered and for PSoC 4A-L,
 174          *                                      the VBUS supply voltage is considered.*
 175          * \globalvars
 176          *  \ref USBFS_initVar
 177          *
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 4   

 178          * \sideeffect
 179          *   This function will reset all communication states to default.
 180          *
 181          * \reentrant
 182          *  No.
 183          *
 184          *******************************************************************************/
 185          void USBFS_Start(uint8 device, uint8 mode) 
 186          {
 187   1          if (0u == USBFS_initVar)
 188   1          {
 189   2              USBFS_Init();
 190   2              USBFS_initVar = 1u;
 191   2          }
 192   1      
 193   1          USBFS_InitComponent(device, mode);
 194   1      }
 195          
 196          
 197          /*******************************************************************************
 198          * Function Name: USBFS_Init
 199          ****************************************************************************//**
 200          *
 201          * This function initializes or restores the component according to the
 202          * customizer Configure dialog settings. It is not necessary to call
 203          * USBFS_Init() because the USBFS_Start() routine calls
 204          * this function and is the preferred method to begin component operation.
 205          *
 206          * \reentrant
 207          *  No.
 208          *
 209          *******************************************************************************/
 210          void USBFS_Init(void) 
 211          {
 212   1      #if (CY_PSOC4)
                  /* Enable clock to USB IP. */
                  USBFS_USB_CLK_EN_REG = USBFS_USB_CLK_CSR_CLK_EN;
              
                  /* The internal regulator (CR1.REG_ENABLE) is enabled in
                  * USBFS_InitComponent() if it is required.
                  */
              
                  /* Enable USBIO control on drive mode of D+ and D- pins. */
                  USBFS_USBIO_CR1_REG &= ~ (uint32) USBFS_USBIO_CR1_IOMODE;
              
                  /* Set number of LF CLK to detect UBS bus reset. */
                  USBFS_BUS_RST_CNT_REG = USBFS_DEFUALT_BUS_RST_CNT;
              
                  /* Select VBUS detection source and clear PHY isolate. The application level
                  * must ensure that VBUS is valid. There is no need to wait 2us before VBUS is valid.
                  */
                  USBFS_POWER_CTRL_REG = USBFS_DEFAULT_POWER_CTRL_VBUS;
              
                  /* Enable PHY detector and single-ended and differential receivers. */
                  USBFS_POWER_CTRL_REG |= USBFS_DEFAULT_POWER_CTRL_PHY;
              
                  /* Suspend clear sequence. */
                  USBFS_POWER_CTRL_REG &= (uint32) ~USBFS_POWER_CTRL_SUSPEND;
                  CyDelayUs(USBFS_WAIT_SUSPEND_DEL_DISABLE);
                  USBFS_POWER_CTRL_REG &= (uint32) ~USBFS_POWER_CTRL_SUSPEND_DEL;
              
                  /* Sets IMO lock options and clear all other bits. */
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 5   

                  USBFS_CR1_REG = USBFS_DEFUALT_CR1;
              
                  /* Configure level (hi, lo, med) for each interrupt source. */
                  USBFS_INTR_LVL_SEL_REG = USBFS_DEFAULT_INTR_LVL_SEL;
              
                  /* Configure interrupt sources from: SOF, Bus Reset and EP0. */
                  USBFS_INTR_SIE_MASK_REG = USBFS_DEFAULT_INTR_SIE_MASK;
              
              #else
 249   1          uint8 enableInterrupts = CyEnterCriticalSection();
 250   1      
 251   1      #if (USBFS_EP_MANAGEMENT_DMA)
                  uint16 i;
              #endif /* (USBFS_EP_MANAGEMENT_DMA) */
 254   1      
 255   1          /* Enable USB block. */
 256   1          USBFS_PM_ACT_CFG_REG |= USBFS_PM_ACT_EN_FSUSB;
 257   1          /* Enable USB block for Standby Power Mode. */
 258   1          USBFS_PM_STBY_CFG_REG |= USBFS_PM_STBY_EN_FSUSB;
 259   1      
 260   1          /* Enable core clock. */
 261   1          USBFS_USB_CLK_EN_REG = USBFS_USB_CLK_ENABLE;
 262   1      
 263   1          USBFS_CR1_REG = USBFS_CR1_ENABLE_LOCK;
 264   1      
 265   1          /* ENABLING USBIO PADS IN USB MODE FROM I/O MODE. */
 266   1          /* Ensure USB transmit enable is low (USB_USBIO_CR0.ten). - Manual Transmission - Disabled. */
 267   1          USBFS_USBIO_CR0_REG &= (uint8) ~USBFS_USBIO_CR0_TEN;
 268   1          CyDelayUs(USBFS_WAIT_REG_STABILITY_50NS);  /* ~50ns delay. */
 269   1          /* Disable USBIO by asserting PM.USB_CR0.fsusbio_pd_n(Inverted.
 270   1          *  high. These bits will be set low by the power manager out-of-reset.
 271   1          *  Also confirm USBIO pull-up is disabled.
 272   1          */
 273   1          USBFS_PM_USB_CR0_REG &= (uint8) ~(USBFS_PM_USB_CR0_PD_N |
 274   1                                                       USBFS_PM_USB_CR0_PD_PULLUP_N);
 275   1      
 276   1          /* Select IOMODE to USB mode. */
 277   1          USBFS_USBIO_CR1_REG &= (uint8) ~USBFS_USBIO_CR1_IOMODE;
 278   1      
 279   1          /* Enable USBIO reference by setting PM.USB_CR0.fsusbio_ref_en. */
 280   1          USBFS_PM_USB_CR0_REG |= USBFS_PM_USB_CR0_REF_EN;
 281   1          /* Reference is available for 1us after regulator is enabled. */
 282   1          CyDelayUs(USBFS_WAIT_REG_STABILITY_1US);
 283   1          /* OR 40us after power is restored. */
 284   1          CyDelayUs(USBFS_WAIT_VREF_RESTORE);
 285   1          /* Ensure single-ended disable bits are low (PRT15.INP_DIS[7:6])(input receiver enabled). */
 286   1          USBFS_DM_INP_DIS_REG &= (uint8) ~USBFS_DM_MASK;
 287   1          USBFS_DP_INP_DIS_REG &= (uint8) ~USBFS_DP_MASK;
 288   1      
 289   1          /* Enable USBIO. */
 290   1          USBFS_PM_USB_CR0_REG |= USBFS_PM_USB_CR0_PD_N;
 291   1          CyDelayUs(USBFS_WAIT_PD_PULLUP_N_ENABLE);
 292   1          /* Set USBIO pull-up enable. */
 293   1          USBFS_PM_USB_CR0_REG |= USBFS_PM_USB_CR0_PD_PULLUP_N;
 294   1      
 295   1          /* Reset Arbiter Write Address register for endpoint 1. */
 296   1          CY_SET_REG8(USBFS_ARB_RW1_WA_PTR,     0u);
 297   1          CY_SET_REG8(USBFS_ARB_RW1_WA_MSB_PTR, 0u);
 298   1      
 299   1      #if (USBFS_EP_MANAGEMENT_DMA)
                  /* Initialize transfer descriptor. This will be used to detect DMA state - initialized or not. */
                  for (i = 0u; i < USBFS_MAX_EP; ++i)
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 6   

                  {
                      USBFS_DmaTd[i] = DMA_INVALID_TD;
              
                  #if (USBFS_EP_MANAGEMENT_DMA_AUTO && (USBFS_EP_DMA_AUTO_OPT == 0u))
                      USBFS_DmaNextTd[i] = DMA_INVALID_TD;
                  #endif /* (USBFS_EP_MANAGEMENT_DMA_AUTO && (USBFS_EP_DMA_AUTO_OPT == 0u)) */
                  }
              #endif /* (USBFS_EP_MANAGEMENT_DMA) */
 310   1      
 311   1          CyExitCriticalSection(enableInterrupts);
 312   1      #endif /* (CY_PSOC4) */
 313   1      
 314   1          /* Configure interrupts from USB block. */
 315   1      #if (CY_PSOC4)
                  /* Configure hi_int: set handler and priority. */
                  CyIntSetPriority     (USBFS_INTR_HI_VECT_NUM,  USBFS_INTR_HI_PRIORITY);
                  (void) CyIntSetVector(USBFS_INTR_HI_VECT_NUM, &USBFS_INTR_HI_ISR);
              
                  /* Configure lo_int: set handler and priority. */
                  CyIntSetPriority     (USBFS_INTR_LO_VECT_NUM,  USBFS_INTR_LO_PRIORITY);
                  (void) CyIntSetVector(USBFS_INTR_LO_VECT_NUM, &USBFS_INTR_LO_ISR);
              
                  /* Configure med_int: set handler and priority (routed through DSI). */
                  CyIntSetPriority     (USBFS_INTR_MED_VECT_NUM,  USBFS_INTR_MED_PRIORITY);
                  (void) CyIntSetVector(USBFS_INTR_MED_VECT_NUM, &USBFS_INTR_MED_ISR);
              
              #else
 329   1          /* Set bus reset interrupt. */
 330   1          CyIntSetPriority(USBFS_BUS_RESET_VECT_NUM, USBFS_BUS_RESET_PRIOR);
 331   1          (void) CyIntSetVector(USBFS_BUS_RESET_VECT_NUM,   &USBFS_BUS_RESET_ISR);
 332   1      
 333   1          /* Set Control Endpoint Interrupt. */
 334   1          CyIntSetPriority(USBFS_EP_0_VECT_NUM, USBFS_EP_0_PRIOR);
 335   1          (void) CyIntSetVector(USBFS_EP_0_VECT_NUM,   &USBFS_EP_0_ISR);
 336   1      
 337   1          /* Set SOF interrupt. */
 338   1          #if (USBFS_SOF_ISR_ACTIVE)
 339   1              CyIntSetPriority     (USBFS_SOF_VECT_NUM,  USBFS_SOF_PRIOR);
 340   1              (void) CyIntSetVector(USBFS_SOF_VECT_NUM, &USBFS_SOF_ISR);
 341   1          #endif /* (USBFS_SOF_ISR_ACTIVE) */
 342   1      
 343   1          /* Set Data Endpoint 1 Interrupt. */
 344   1          #if (USBFS_EP1_ISR_ACTIVE)
 345   1              CyIntSetPriority     (USBFS_EP_1_VECT_NUM,  USBFS_EP_1_PRIOR);
 346   1              (void) CyIntSetVector(USBFS_EP_1_VECT_NUM,  &USBFS_EP_1_ISR);
 347   1          #endif /* (USBFS_EP1_ISR_ACTIVE) */
 348   1      
 349   1          /* Set Data Endpoint 2 Interrupt. */
 350   1          #if (USBFS_EP2_ISR_ACTIVE)
 351   1              CyIntSetPriority     (USBFS_EP_2_VECT_NUM,  USBFS_EP_2_PRIOR);
 352   1              (void) CyIntSetVector(USBFS_EP_2_VECT_NUM, &USBFS_EP_2_ISR);
 353   1          #endif /* (USBFS_EP2_ISR_ACTIVE) */
 354   1      
 355   1          /* Set Data Endpoint 3 Interrupt. */
 356   1          #if (USBFS_EP3_ISR_ACTIVE)
                      CyIntSetPriority     (USBFS_EP_3_VECT_NUM,  USBFS_EP_3_PRIOR);
                      (void) CyIntSetVector(USBFS_EP_3_VECT_NUM, &USBFS_EP_3_ISR);
                  #endif /* (USBFS_EP3_ISR_ACTIVE) */
 360   1      
 361   1          /* Set Data Endpoint 4 Interrupt. */
 362   1          #if (USBFS_EP4_ISR_ACTIVE)
                      CyIntSetPriority     (USBFS_EP_4_VECT_NUM,  USBFS_EP_4_PRIOR);
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 7   

                      (void) CyIntSetVector(USBFS_EP_4_VECT_NUM, &USBFS_EP_4_ISR);
                  #endif /* (USBFS_EP4_ISR_ACTIVE) */
 366   1      
 367   1          /* Set Data Endpoint 5 Interrupt. */
 368   1          #if (USBFS_EP5_ISR_ACTIVE)
                      CyIntSetPriority     (USBFS_EP_5_VECT_NUM,  USBFS_EP_5_PRIOR);
                      (void) CyIntSetVector(USBFS_EP_5_VECT_NUM, &USBFS_EP_5_ISR);
                  #endif /* (USBFS_EP5_ISR_ACTIVE) */
 372   1      
 373   1          /* Set Data Endpoint 6 Interrupt. */
 374   1          #if (USBFS_EP6_ISR_ACTIVE)
                      CyIntSetPriority     (USBFS_EP_6_VECT_NUM,  USBFS_EP_6_PRIOR);
                      (void) CyIntSetVector(USBFS_EP_6_VECT_NUM, &USBFS_EP_6_ISR);
                  #endif /* (USBFS_EP6_ISR_ACTIVE) */
 378   1      
 379   1           /* Set Data Endpoint 7 Interrupt. */
 380   1          #if (USBFS_EP7_ISR_ACTIVE)
                      CyIntSetPriority     (USBFS_EP_7_VECT_NUM,  USBFS_EP_7_PRIOR);
                      (void) CyIntSetVector(USBFS_EP_7_VECT_NUM, &USBFS_EP_7_ISR);
                  #endif /* (USBFS_EP7_ISR_ACTIVE) */
 384   1      
 385   1          /* Set Data Endpoint 8 Interrupt. */
 386   1          #if (USBFS_EP8_ISR_ACTIVE)
                      CyIntSetPriority     (USBFS_EP_8_VECT_NUM,  USBFS_EP_8_PRIOR);
                      (void) CyIntSetVector(USBFS_EP_8_VECT_NUM, &USBFS_EP_8_ISR);
                  #endif /* (USBFS_EP8_ISR_ACTIVE) */
 390   1      
 391   1          /* Set ARB Interrupt. */
 392   1          #if (USBFS_EP_MANAGEMENT_DMA && USBFS_ARB_ISR_ACTIVE)
                      CyIntSetPriority     (USBFS_ARB_VECT_NUM,  USBFS_ARB_PRIOR);
                      (void) CyIntSetVector(USBFS_ARB_VECT_NUM, &USBFS_ARB_ISR);
                  #endif /* (USBFS_EP_MANAGEMENT_DMA && USBFS_ARB_ISR_ACTIVE) */
 396   1      #endif /* (CY_PSOC4) */
 397   1      
 398   1          /* Common: Configure GPIO interrupt for wakeup. */
 399   1      #if (USBFS_DP_ISR_ACTIVE)
 400   1          CyIntSetPriority     (USBFS_DP_INTC_VECT_NUM,  USBFS_DP_INTC_PRIORITY);
 401   1          (void) CyIntSetVector(USBFS_DP_INTC_VECT_NUM, &USBFS_DP_ISR);
 402   1      #endif /* (USBFS_DP_ISR_ACTIVE) */
 403   1      
 404   1      #if (USBFS_EP_MANAGEMENT_DMA && CY_PSOC4)
                  /* Initialize DMA channels. */
                  USBFS_InitEpDma();
              #endif /* (USBFS_EP_MANAGEMENT_DMA && CY_PSOC4) */
 408   1      }
 409          
 410          
 411          /*******************************************************************************
 412          * Function Name: USBFS_InitComponent
 413          ****************************************************************************//**
 414          *
 415          *   This function initializes the component’s global variables and initiates
 416          *   communication with the host by pull-up D+ line.
 417          *
 418          * \param device:
 419          *   Contains the device number of the desired device descriptor. The device
 420          *   number can be found in the Device Descriptor Tab of "Configure" dialog,
 421          *   under the settings of desired Device Descriptor, in the *Device Number*
 422          *   field.
 423          *  \param mode:
 424          *   The operating voltage. This determines whether the voltage regulator
 425          *   is enabled for 5V operation or if pass through mode is used for 3.3V
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 8   

 426          *   operation. Symbolic names and their associated values are given in the
 427          *   following list.
 428          *
 429          *       *USBFS_3V_OPERATION* - Disable voltage regulator and pass-
 430          *                                      through Vcc for pull-up
 431          *
 432          *       *USBFS_5V_OPERATION* - Enable voltage regulator and use
 433          *                                      regulator for pull-up
 434          *
 435          *       *USBFS_DWR_POWER_OPERATION* - Enable or disable the voltage
 436          *                                      regulator depending on the power supply
 437          *                                      voltage configuration in the DWR tab.
 438          *                                      For PSoC 3/5LP devices, the VDDD supply
 439          *                                      voltage is considered and for PSoC 4A-L,
 440          *                                      the VBUS supply voltage is considered.
 441          *
 442          * \globalvars
 443          *   \ref USBFS_device
 444          *   \ref USBFS_transferState
 445          *   \ref USBFS_configuration
 446          *   \ref USBFS_deviceStatus
 447          *
 448          *   \ref USBFS_deviceAddress - Contains the current device address. This
 449          *       variable is initialized to zero in this API. The Host starts to communicate
 450          *      to the device with address 0 and then sets it to a whatever value using a
 451          *      SET_ADDRESS request.
 452          *
 453          *   \ref USBFS_lastPacketSize - Initialized to 0;
 454          *
 455          * \reentrant
 456          *  No.
 457          *
 458          *******************************************************************************/
 459          void USBFS_InitComponent(uint8 device, uint8 mode) 
 460          {
 461   1          /* Initialize _hidProtocol variable to comply with
 462   1          *  HID 7.2.6 Set_Protocol Request:
 463   1          *  "When initialized, all devices default to report protocol."
 464   1          */
 465   1      #if defined(USBFS_ENABLE_HID_CLASS)
 466   1          uint8 i;
 467   1      
 468   1          for (i = 0u; i < USBFS_MAX_INTERFACES_NUMBER; i++)
 469   1          {
 470   2              USBFS_hidProtocol[i] = USBFS_PROTOCOL_REPORT;
 471   2          }
 472   1      #endif /* USBFS_ENABLE_HID_CLASS */
 473   1      
 474   1          /* Store device number to access descriptor. */
 475   1          USBFS_device = device;
 476   1      
 477   1          /* Reset component internal variables. */
 478   1          USBFS_transferState   = USBFS_TRANS_STATE_IDLE;
 479   1          USBFS_configurationChanged = 0u;
 480   1          USBFS_configuration   = 0u;
 481   1          USBFS_interfaceNumber = 0u;
 482   1          USBFS_deviceAddress   = 0u;
 483   1          USBFS_deviceStatus    = 0u;
 484   1          USBFS_lastPacketSize  = 0u;
 485   1      
 486   1          /* Enable component interrupts. */
 487   1      #if (CY_PSOC4)
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 9   

                  CyIntEnable(USBFS_INTR_HI_VECT_NUM);
                  CyIntEnable(USBFS_INTR_MED_VECT_NUM);
                  CyIntEnable(USBFS_INTR_LO_VECT_NUM);
              #else
 492   1          CyIntEnable(USBFS_BUS_RESET_VECT_NUM);
 493   1          CyIntEnable(USBFS_EP_0_VECT_NUM);
 494   1      
 495   1          #if (USBFS_SOF_ISR_ACTIVE)
 496   1              CyIntEnable(USBFS_SOF_VECT_NUM);
 497   1          #endif /* (USBFS_SOF_ISR_ACTIVE) */
 498   1      
 499   1          #if (USBFS_EP1_ISR_ACTIVE)
 500   1              CyIntEnable(USBFS_EP_1_VECT_NUM);
 501   1          #endif /* (USBFS_EP1_ISR_ACTIVE) */
 502   1      
 503   1          #if (USBFS_EP2_ISR_ACTIVE)
 504   1              CyIntEnable(USBFS_EP_2_VECT_NUM);
 505   1          #endif /* (USBFS_EP5_ISR_ACTIVE) */
 506   1      
 507   1          #if (USBFS_EP3_ISR_ACTIVE)
                      CyIntEnable(USBFS_EP_3_VECT_NUM);
                  #endif /* (USBFS_EP5_ISR_ACTIVE) */
 510   1      
 511   1          #if (USBFS_EP4_ISR_ACTIVE)
                      CyIntEnable(USBFS_EP_4_VECT_NUM);
                  #endif /* (USBFS_EP5_ISR_ACTIVE) */
 514   1      
 515   1          #if (USBFS_EP5_ISR_ACTIVE)
                      CyIntEnable(USBFS_EP_5_VECT_NUM);
                  #endif /* (USBFS_EP5_ISR_ACTIVE) */
 518   1      
 519   1          #if (USBFS_EP6_ISR_ACTIVE)
                      CyIntEnable(USBFS_EP_6_VECT_NUM);
                  #endif /* USBFS_EP6_ISR_REMOVE */
 522   1      
 523   1          #if (USBFS_EP7_ISR_ACTIVE)
                      CyIntEnable(USBFS_EP_7_VECT_NUM);
                  #endif /* (USBFS_EP7_ISR_ACTIVE) */
 526   1      
 527   1          #if (USBFS_EP8_ISR_ACTIVE)
                      CyIntEnable(USBFS_EP_8_VECT_NUM);
                  #endif /* (USBFS_EP8_ISR_ACTIVE) */
 530   1      #endif /* (CY_PSOC4) */
 531   1      
 532   1      #if (USBFS_EP_MANAGEMENT_DMA && USBFS_ARB_ISR_ACTIVE)
                  /* Enable ARB EP interrupt sources. */
                  USBFS_ARB_INT_EN_REG = USBFS_DEFAULT_ARB_INT_EN;
              
                  #if (CY_PSOC3 || CY_PSOC5)
                      CyIntEnable(USBFS_ARB_VECT_NUM);
                  #endif /* (CY_PSOC3 || CY_PSOC5) */
              #endif   /* (USBFS_EP_MANAGEMENT_DMA && USBFS_ARB_ISR_ACTIVE) */
 540   1      
 541   1      /* Arbiter configuration for DMA transfers. */
 542   1      #if (USBFS_EP_MANAGEMENT_DMA)
                  /* Configure Arbiter for Manual or Auto DMA operation and clear configuration completion. */
                  USBFS_ARB_CFG_REG = USBFS_DEFAULT_ARB_CFG;
              
                  #if (CY_PSOC4)
                      /* Enable DMA operation. */
                      CyDmaEnable();
              
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 10  

                      #if (USBFS_EP_MANAGEMENT_DMA_AUTO)
                          /* Change DMA priority to be highest. */
                           CyIntSetPriority(CYDMA_INTR_NUMBER, USBFS_DMA_AUTO_INTR_PRIO);
                      #endif /* (USBFS_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (CY_PSOC4) */
              
                  #if (USBFS_EP_MANAGEMENT_DMA_AUTO)
                      #if (CY_PSOC4)
                          /* Enable DMA interrupt to handle DMA management. */
                          CyIntEnable(CYDMA_INTR_NUMBER);
                      #else
                          #if (USBFS_EP_DMA_AUTO_OPT == 0u)
                              /* Initialize interrupts which handle verification of successful DMA transaction. */
                              USBFS_EP_DMA_Done_isr_StartEx(&USBFS_EP_DMA_DONE_ISR);
                              USBFS_EP17_DMA_Done_SR_InterruptEnable();
                              USBFS_EP8_DMA_Done_SR_InterruptEnable();
                          #endif /* (USBFS_EP_DMA_AUTO_OPT == 0u) */
                      #endif /* (CY_PSOC4) */
                  #endif /* (USBFS_EP_MANAGEMENT_DMA_AUTO) */
              #endif /* (USBFS_EP_MANAGEMENT_DMA) */
 570   1      
 571   1          /* Enable USB regulator depends on operation voltage. IMO Locking is enabled in Init(). */
 572   1          switch(mode)
 573   1          {
 574   2          case USBFS_3V_OPERATION:
 575   2              /* Disable regulator for 3V operation. */
 576   2              USBFS_CR1_REG &= (uint8) ~USBFS_CR1_REG_ENABLE;
 577   2              break;
 578   2      
 579   2          case USBFS_5V_OPERATION:
 580   2              /* Enable regulator for 5V operation. */
 581   2              USBFS_CR1_REG |= (uint8)  USBFS_CR1_REG_ENABLE;
 582   2              break;
 583   2      
 584   2          default: /* Check DWR settings of USB power supply. */
 585   2          #if (USBFS_VDDD_MV < USBFS_3500MV)
                      /* Disable regulator for 3V operation. */
                      USBFS_CR1_REG &= (uint8) ~USBFS_CR1_REG_ENABLE;
                  #else
 589   2              /* Enable regulator for 5V operation. */
 590   2              USBFS_CR1_REG |= (uint8)  USBFS_CR1_REG_ENABLE;
 591   2          #endif /* (USBFS_VDDD_MV < USBFS_3500MV) */
 592   2              break;
 593   2          }
 594   1      
 595   1      #if (CY_PSOC4)
                  /* Clear bus activity. */
                  USBFS_CR1_REG &= (uint32) ~USBFS_CR1_BUS_ACTIVITY;
              
                  /* Clear EP0 count register. */
                  USBFS_EP0_CNT_REG = USBFS_CLEAR_REG;
              
                  /* Set EP0.CR: ACK Setup, NAK IN/OUT. */
                  USBFS_EP0_CR_REG = USBFS_MODE_NAK_IN_OUT;
              
                  #if (USBFS_LPM_ACTIVE)
                      if (NULL != USBFS_GetBOSPtr())
                      {
                          /* Enable LPM and acknowledge LPM packets for active device.
                          * Reset NYET_EN and SUB_RESP bits in the LPM_CTRL register.
                          */
                          USBFS_LPM_CTRL_REG = (USBFS_LPM_CTRL_LPM_EN | \
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 11  

                                                           USBFS_LPM_CTRL_LPM_ACK_RESP);
                      }
                      else
                      {
                          /* Disable LPM for active device. */
                          USBFS_LPM_CTRL_REG &= (uint32) ~USBFS_LPM_CTRL_LPM_EN;
                      }
                  #endif /* (USBFS_LPM_ACTIVE) */
              
                  /* Enable device to responds to USB traffic with address 0. */
                  USBFS_CR0_REG = USBFS_DEFUALT_CR0;
              
              #else
 625   1          /* Set EP0.CR: ACK Setup, STALL IN/OUT. */
 626   1          USBFS_EP0_CR_REG = USBFS_MODE_STALL_IN_OUT;
 627   1      
 628   1          /* Enable device to respond to USB traffic with address 0. */
 629   1          USBFS_CR0_REG = USBFS_DEFUALT_CR0;
 630   1          CyDelayCycles(USBFS_WAIT_CR0_REG_STABILITY);
 631   1      #endif /* (CY_PSOC4) */
 632   1      
 633   1          /* Enable D+ pull-up and keep USB control on IO. */
 634   1          USBFS_USBIO_CR1_REG = USBFS_USBIO_CR1_USBPUEN;
 635   1      }
 636          
 637          
 638          /*******************************************************************************
 639          * Function Name: USBFS_ReInitComponent
 640          ****************************************************************************//**
 641          *
 642          *  This function reinitialize the component configuration and is
 643          *  intend to be called from the Reset interrupt.
 644          *
 645          * \globalvars
 646          *   USBFS_device - Contains the device number of the desired Device
 647          *        Descriptor. The device number can be found in the Device Descriptor tab
 648          *       of the Configure dialog, under the settings of the desired Device Descriptor,
 649          *       in the Device Number field.
 650          *   USBFS_transferState - This variable is used by the communication
 651          *       functions to handle the current transfer state. Initialized to
 652          *       TRANS_STATE_IDLE in this API.
 653          *   USBFS_configuration - Contains the current configuration number
 654          *       set by the Host using a SET_CONFIGURATION request.
 655          *       Initialized to zero in this API.
 656          *   USBFS_deviceAddress - Contains the current device address. This
 657          *       variable is initialized to zero in this API. The Host starts to communicate
 658          *      to the device with address 0 and then sets it to a whatever value using
 659          *      a SET_ADDRESS request.
 660          *   USBFS_deviceStatus - Initialized to 0.
 661          *       This is a two-bit variable which contains the power status in the first bit
 662          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and the remote
 663          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in the second bit.
 664          *   USBFS_lastPacketSize - Initialized to 0;
 665          *
 666          * \reentrant
 667          *  No.
 668          *
 669          *******************************************************************************/
 670          void USBFS_ReInitComponent(void) 
 671          {
 672   1          /* Initialize _hidProtocol variable to comply with HID 7.2.6 Set_Protocol
 673   1          *  Request: "When initialized, all devices default to report protocol."
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 12  

 674   1          */
 675   1      #if defined(USBFS_ENABLE_HID_CLASS)
 676   1          uint8 i;
 677   1      
 678   1          for (i = 0u; i < USBFS_MAX_INTERFACES_NUMBER; i++)
 679   1          {
 680   2              USBFS_hidProtocol[i] = USBFS_PROTOCOL_REPORT;
 681   2          }
 682   1      #endif /* USBFS_ENABLE_HID_CLASS */
 683   1      
 684   1          /* Reset component internal variables. */
 685   1          USBFS_transferState   = USBFS_TRANS_STATE_IDLE;
 686   1          USBFS_configurationChanged = 0u;
 687   1          USBFS_configuration   = 0u;
 688   1          USBFS_interfaceNumber = 0u;
 689   1          USBFS_deviceAddress   = 0u;
 690   1          USBFS_deviceStatus    = 0u;
 691   1          USBFS_lastPacketSize  = 0u;
 692   1      
 693   1      #if (CY_PSOC4)
                  /* Set EP0.CR: ACK Setup, NAK IN/OUT. */
                  USBFS_EP0_CR_REG = USBFS_MODE_NAK_IN_OUT;
              #else
 697   1          /* Set EP0.CR: ACK Setup, STALL IN/OUT. */
 698   1          USBFS_EP0_CR_REG = USBFS_MODE_STALL_IN_OUT;
 699   1      #endif /* (CY_PSOC4) */
 700   1      
 701   1          /* Enable device to respond to USB traffic with address 0. */
 702   1          USBFS_CR0_REG = USBFS_DEFUALT_CR0;
 703   1      }
 704          
 705          
 706          /*******************************************************************************
 707          * Function Name: USBFS_Stop
 708          ****************************************************************************//**
 709          *
 710          *  This function shuts down the USB function including to release
 711          *  the D+ pull-up and disabling the SIE.
 712          *
 713          * \globalvars
 714          *   \ref USBFS_configuration
 715          *
 716          *   USBFS_deviceAddress - Contains the current device address. This
 717          *       variable is initialized to zero in this API. The Host starts to communicate
 718          *      to the device with address 0 and then sets it to a whatever value using
 719          *      a SET_ADDRESS request.
 720          *
 721          *   \ref USBFS_deviceStatus
 722          *
 723          *   \ref USBFS_configurationChanged
 724          *
 725          *   USBFS_intiVar -  This variable is set to zero
 726          *
 727          *******************************************************************************/
 728          void USBFS_Stop(void) 
 729          {
 730   1          uint8 enableInterrupts;
 731   1      
 732   1      #if (USBFS_EP_MANAGEMENT_DMA)
                  /* Stop all DMA channels. */
                  USBFS_Stop_DMA(USBFS_MAX_EP);
              #endif /* (USBFS_EP_MANAGEMENT_DMA) */
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 13  

 736   1      
 737   1          enableInterrupts = CyEnterCriticalSection();
 738   1      
 739   1          /* Disable USB IP to respond to USB traffic. */
 740   1          USBFS_CR0_REG &= (uint8) ~USBFS_CR0_ENABLE;
 741   1      
 742   1          /* Disable D+ pull-up. */
 743   1          USBFS_USBIO_CR1_REG &= (uint8) ~ USBFS_USBIO_CR1_USBPUEN;
 744   1      
 745   1      #if (CY_PSOC4)
                  /* Disable USBFS block. */
                  USBFS_POWER_CTRL_REG &= (uint32) ~USBFS_POWER_CTRL_ENABLE;
              #else
 749   1          /* Clear power active and standby mode templates. */
 750   1          USBFS_PM_ACT_CFG_REG  &= (uint8) ~USBFS_PM_ACT_EN_FSUSB;
 751   1          USBFS_PM_STBY_CFG_REG &= (uint8) ~USBFS_PM_STBY_EN_FSUSB;
 752   1      #endif /* (CY_PSOC4) */
 753   1      
 754   1          CyExitCriticalSection(enableInterrupts);
 755   1      
 756   1          /* Disable component interrupts. */
 757   1      #if (CY_PSOC4)
                  CyIntDisable(USBFS_INTR_HI_VECT_NUM);
                  CyIntDisable(USBFS_INTR_LO_VECT_NUM);
                  CyIntDisable(USBFS_INTR_MED_VECT_NUM);
              #else
 762   1      
 763   1          CyIntDisable(USBFS_BUS_RESET_VECT_NUM);
 764   1          CyIntDisable(USBFS_EP_0_VECT_NUM);
 765   1      
 766   1          #if (USBFS_SOF_ISR_ACTIVE)
 767   1              CyIntDisable(USBFS_SOF_VECT_NUM);
 768   1          #endif /* (USBFS_SOF_ISR_ACTIVE) */
 769   1      
 770   1          #if (USBFS_EP1_ISR_ACTIVE)
 771   1              CyIntDisable(USBFS_EP_1_VECT_NUM);
 772   1          #endif /* (USBFS_EP1_ISR_ACTIVE) */
 773   1      
 774   1          #if (USBFS_EP2_ISR_ACTIVE)
 775   1              CyIntDisable(USBFS_EP_2_VECT_NUM);
 776   1          #endif /* (USBFS_EP2_ISR_ACTIVE) */
 777   1      
 778   1          #if (USBFS_EP3_ISR_ACTIVE)
                      CyIntDisable(USBFS_EP_3_VECT_NUM);
                  #endif /* (USBFS_EP3_ISR_ACTIVE) */
 781   1      
 782   1          #if (USBFS_EP4_ISR_ACTIVE)
                      CyIntDisable(USBFS_EP_4_VECT_NUM);
                  #endif /* (USBFS_EP4_ISR_ACTIVE) */
 785   1      
 786   1          #if (USBFS_EP5_ISR_ACTIVE)
                      CyIntDisable(USBFS_EP_5_VECT_NUM);
                  #endif /* (USBFS_EP5_ISR_ACTIVE) */
 789   1      
 790   1          #if (USBFS_EP6_ISR_ACTIVE)
                      CyIntDisable(USBFS_EP_6_VECT_NUM);
                  #endif /* USBFS_EP6_ISR_REMOVE */
 793   1      
 794   1          #if (USBFS_EP7_ISR_ACTIVE)
                      CyIntDisable(USBFS_EP_7_VECT_NUM);
                  #endif /* (USBFS_EP7_ISR_ACTIVE) */
 797   1      
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 14  

 798   1          #if (USBFS_EP8_ISR_ACTIVE)
                      CyIntDisable(USBFS_EP_8_VECT_NUM);
                  #endif /* (USBFS_EP8_ISR_ACTIVE) */
 801   1      #endif /* (CY_PSOC4) */
 802   1      
 803   1          /* Reset component internal variables. */
 804   1          USBFS_configurationChanged = 0u;
 805   1          USBFS_configuration   = 0u;
 806   1          USBFS_interfaceNumber = 0u;
 807   1          USBFS_deviceAddress   = 0u;
 808   1          USBFS_deviceStatus    = 0u;
 809   1      
 810   1          /* It is mandatory for correct device startup. */
 811   1          USBFS_initVar = 0u;
 812   1      }
 813          
 814          
 815          /*******************************************************************************
 816          * Function Name: USBFS_CheckActivity
 817          ****************************************************************************//**
 818          *
 819          *  This function returns the activity status of the bus. It clears the hardware
 820          *  status to provide updated status on the next call of this function. It
 821          *  provides a way to determine whether any USB bus activity occurred. The
 822          *  application should use this function to determine if the USB suspend
 823          *  conditions are met.
 824          *
 825          *
 826          * \return
 827          *  cystatus: Status of the bus since the last call of the function.
 828          *  Return Value |   Description
 829          *  -------------|---------------------------------------------------------------
 830          *  1            |Bus activity was detected since the last call to this function
 831          *  0            |Bus activity was not detected since the last call to this function
 832          *
 833          *
 834          *******************************************************************************/
 835          uint8 USBFS_CheckActivity(void) 
 836          {
 837   1          uint8 cr1Reg = USBFS_CR1_REG;
 838   1      
 839   1          /* Clear bus activity. */
 840   1          USBFS_CR1_REG = (cr1Reg & (uint8) ~USBFS_CR1_BUS_ACTIVITY);
 841   1      
 842   1          /* Get bus activity. */
 843   1          return ((0u != (cr1Reg & USBFS_CR1_BUS_ACTIVITY)) ? (1u) : (0u));
 844   1      }
 845          
 846          
 847          /*******************************************************************************
 848          * Function Name: USBFS_GetConfiguration
 849          ****************************************************************************//**
 850          *
 851          *  This function gets the current configuration of the USB device.
 852          *
 853          * \return
 854          *  Returns the currently assigned configuration. Returns 0 if the device
 855          *  is not configured
 856          *
 857          *******************************************************************************/
 858          uint8 USBFS_GetConfiguration(void) 
 859          {
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 15  

 860   1          return (USBFS_configuration);
 861   1      }
 862          
 863          
 864          /*******************************************************************************
 865          * Function Name: USBFS_IsConfigurationChanged
 866          ****************************************************************************//**
 867          *
 868          *  This function returns the clear-on-read configuration state.  It is useful
 869          *  when the host sends double SET_CONFIGURATION request with the same 
 870          *  configuration number or changes alternate settings of the interface. 
 871          *  After configuration has been changed the OUT endpoints must be enabled and IN 
 872          *  endpoint must be loaded with data to start communication with the host.
 873          *
 874          * \return
 875          *  None-zero value when new configuration has been changed, otherwise zero is
 876          *  returned.
 877          *
 878          * \globalvars
 879          *
 880          *  \ref USBFS_configurationChanged - This variable is set to 1 after
 881          *   a SET_CONFIGURATION request and cleared in this function.
 882          *
 883          *******************************************************************************/
 884          uint8 USBFS_IsConfigurationChanged(void) 
 885          {
 886   1          uint8 res = 0u;
 887   1      
 888   1          if (USBFS_configurationChanged != 0u)
 889   1          {
 890   2              res = USBFS_configurationChanged;
 891   2              USBFS_configurationChanged = 0u;
 892   2          }
 893   1      
 894   1          return (res);
 895   1      }
 896          
 897          
 898          /*******************************************************************************
 899          * Function Name: USBFS_GetInterfaceSetting
 900          ****************************************************************************//**
 901          *
 902          *  This function gets the current alternate setting for the specified interface.
 903          *  It is useful to identify which alternate settings are active in the specified 
 904          *  interface.
 905          *
 906          *  \param
 907          *  interfaceNumber interface number
 908          *
 909          * \return
 910          *  Returns the current alternate setting for the specified interface.
 911          *
 912          *******************************************************************************/
 913          uint8  USBFS_GetInterfaceSetting(uint8 interfaceNumber)
 914                                                              
 915          {
 916   1          return (USBFS_interfaceSetting[interfaceNumber]);
 917   1      }
 918          
 919          
 920          /*******************************************************************************
 921          * Function Name: USBFS_GetEPState
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 16  

 922          ****************************************************************************//**
 923          *
 924          *  This function returns the state of the requested endpoint.
 925          *
 926          * \param epNumber Data endpoint number
 927          *
 928          * \return
 929          *  Returns the current state of the specified USBFS endpoint. Symbolic names and
 930          *  their associated values are given in the following table. Use these constants
 931          *  whenever you write code to change the state of the endpoints, such as ISR
 932          *  code, to handle data sent or received.
 933          *
 934          *  Return Value           | Description
 935          *  -----------------------|-----------------------------------------------------
 936          *  USBFS_NO_EVENT_PENDING |The endpoint is awaiting SIE action
 937          *  USBFS_EVENT_PENDING    |The endpoint is awaiting CPU action
 938          *  USBFS_NO_EVENT_ALLOWED |The endpoint is locked from access
 939          *  USBFS_IN_BUFFER_FULL   |The IN endpoint is loaded and the mode is set to ACK IN
 940          *  USBFS_IN_BUFFER_EMPTY  |An IN transaction occurred and more data can be loaded
 941          *  USBFS_OUT_BUFFER_EMPTY |The OUT endpoint is set to ACK OUT and is waiting for data
 942          *  USBFS_OUT_BUFFER_FULL  |An OUT transaction has occurred and data can be read
 943          *
 944          *******************************************************************************/
 945          uint8 USBFS_GetEPState(uint8 epNumber) 
 946          {
 947   1          return (USBFS_EP[epNumber].apiEpState);
 948   1      }
 949          
 950          
 951          /*******************************************************************************
 952          * Function Name: USBFS_GetEPCount
 953          ****************************************************************************//**
 954          *
 955          *  This function supports Data Endpoints only(EP1-EP8).
 956          *  Returns the transfer count for the requested endpoint.  The value from
 957          *  the count registers includes 2 counts for the two byte checksum of the
 958          *  packet.  This function subtracts the two counts.
 959          *
 960          *  \param epNumber Data Endpoint Number.
 961          *                   Valid values are between 1 and 8.
 962          *
 963          * \return
 964          *  Returns the current byte count from the specified endpoint or 0 for an
 965          *  invalid endpoint.
 966          *
 967          *******************************************************************************/
 968          uint16 USBFS_GetEPCount(uint8 epNumber) 
 969          {
 970   1          uint16 cntr = 0u;
 971   1      
 972   1          if ((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
 973   1          {
 974   2              /* Get 11-bits EP counter where epCnt0 - 3 bits MSB and epCnt1 - 8 bits LSB. */
 975   2              cntr  = ((uint16) USBFS_SIE_EP_BASE.sieEp[epNumber].epCnt0) & USBFS_EPX_CNT0_MASK;
 976   2              cntr  = ((uint16) (cntr << 8u)) | ((uint16) USBFS_SIE_EP_BASE.sieEp[epNumber].epCnt1);
 977   2              cntr -= USBFS_EPX_CNTX_CRC_COUNT;
 978   2          }
 979   1      
 980   1          return (cntr);
 981   1      }
 982          
 983          
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 17  

 984          #if (USBFS_EP_MANAGEMENT_DMA)
              #if (CY_PSOC4)
                  /*******************************************************************************
                  * Function Name: USBFS_InitEpDma
                  ****************************************************************************//**
                  *
                  *  This function configures priority for all DMA channels utilized by the
                  *  component. Also sets callbacks for DMA auto mode.
                  *
                  *******************************************************************************/
                  static void USBFS_InitEpDma(void)
                  {
                  #if (USBFS_DMA1_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBFS_ep1_dma_CHANNEL] = USBFS_ep1_dma_CHANNEL_CFG;
                  #endif /* (USBFS_DMA1_ACTIVE) */
              
                  #if (USBFS_DMA2_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBFS_ep2_dma_CHANNEL] = USBFS_ep2_dma_CHANNEL_CFG;
                  #endif /* (USBFS_DMA2_ACTIVE) */
              
                  #if (USBFS_DMA3_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBFS_ep3_dma_CHANNEL] = USBFS_ep3_dma_CHANNEL_CFG;
                  #endif /* (USBFS_DMA3_ACTIVE) */
              
                  #if (USBFS_DMA4_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBFS_ep4_dma_CHANNEL] = USBFS_ep4_dma_CHANNEL_CFG;
                  #endif /* (USBFS_DMA4_ACTIVE) */
              
                  #if (USBFS_DMA5_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBFS_ep5_dma_CHANNEL] = USBFS_ep5_dma_CHANNEL_CFG;
                  #endif /* (USBFS_DMA5_ACTIVE) */
              
                  #if (USBFS_DMA6_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBFS_ep6_dma_CHANNEL] = USBFS_ep6_dma_CHANNEL_CFG;
                  #endif /* (USBFS_DMA6_ACTIVE) */
              
                  #if (USBFS_DMA7_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBFS_ep7_dma_CHANNEL] = USBFS_ep7_dma_CHANNEL_CFG;
                  #endif /* (USBFS_DMA7_ACTIVE) */
              
                  #if (USBFS_DMA8_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USBFS_ep8_dma_CHANNEL] = USBFS_ep8_dma_CHANNEL_CFG;
                  #endif /* (USBFS_DMA8_ACTIVE) */
              
                  #if (USBFS_EP_MANAGEMENT_DMA_AUTO)
                      /* Initialize DMA channel callbacks. */
                      #if (USBFS_DMA1_ACTIVE)
                          (void) USBFS_ep1_dma_SetInterruptCallback(&USBFS_EP1_DMA_DONE_ISR);
                      #endif /* (USBFS_DMA1_ACTIVE) */
              
                      #if (USBFS_DMA2_ACTIVE)
                          (void) USBFS_ep2_dma_SetInterruptCallback(&USBFS_EP2_DMA_DONE_ISR);
                      #endif /* (USBFS_DMA2_ACTIVE) */
              
                      #if (USBFS_DMA3_ACTIVE)
                          (void) USBFS_ep3_dma_SetInterruptCallback(&USBFS_EP3_DMA_DONE_ISR);
                      #endif /* (USBFS_DMA3_ACTIVE) */
              
                      #if (USBFS_DMA4_ACTIVE)
                          (void) USBFS_ep4_dma_SetInterruptCallback(&USBFS_EP4_DMA_DONE_ISR);
                      #endif /* (USBFS_DMA4_ACTIVE) */
              
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 18  

                      #if (USBFS_DMA5_ACTIVE)
                          (void) USBFS_ep5_dma_SetInterruptCallback(&USBFS_EP5_DMA_DONE_ISR);
                      #endif /* (USBFS_DMA5_ACTIVE) */
              
                      #if (USBFS_DMA6_ACTIVE)
                          (void) USBFS_ep6_dma_SetInterruptCallback(&USBFS_EP6_DMA_DONE_ISR);
                      #endif /* (USBFS_DMA6_ACTIVE) */
              
                      #if (USBFS_DMA7_ACTIVE)
                          (void) USBFS_ep7_dma_SetInterruptCallback(&USBFS_EP7_DMA_DONE_ISR);
                      #endif /* (USBFS_DMA7_ACTIVE) */
              
                      #if (USBFS_DMA8_ACTIVE)
                          (void) USBFS_ep8_dma_SetInterruptCallback(&USBFS_EP8_DMA_DONE_ISR);
                      #endif /* (USBFS_DMA8_ACTIVE) */
                  #endif /* (USBFS_EP_MANAGEMENT_DMA_AUTO) */
                  }
              #else
              
              
                  /***************************************************************************
                  * Function Name: USBFS_InitEP_DMA
                  ************************************************************************//**
                  *
                  *  This function allocates and initializes a DMA channel to be used by the
                  *  USBFS_LoadInEP() or USBFS_ReadOutEP() APIs for data
                  *  transfer. It is available when the Endpoint Memory Management parameter
                  *  is set to DMA.
                  *
                  *  This function is automatically called from the USBFS_LoadInEP() and USBFS_ReadOutEP() APIs.
                  *
                  *  \param epNumber Contains the data endpoint number.
                  *            Valid values are between 1 and 8.
                  *  \param *pData Pointer to a data array that is related to the EP transfers.
                  *
                  * \reentrant No.
                  *
                  ***************************************************************************/
                  void USBFS_InitEP_DMA(uint8 epNumber, const uint8 *pData)
                                                                                  
                  {
                      uint16 src;
                      uint16 dst;
              
                  #if (CY_PSOC3)
                      src = HI16(CYDEV_SRAM_BASE);
                      dst = HI16(CYDEV_PERIPH_BASE);
                      pData = pData;
                  #else
                      if ((USBFS_EP[epNumber].addr & USBFS_DIR_IN) != 0u)
                      {
                          /* IN endpoint: source is memory buffer. */
                          src = HI16(pData);
                          dst = HI16(CYDEV_PERIPH_BASE);
                      }
                      else
                      {
                          /* OUT endpoint: source is USB IP memory buffer. */
                          src = HI16(CYDEV_PERIPH_BASE);
                          dst = HI16(pData);
                      }
                  #endif  /* (CY_PSOC3) */
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 19  

              
                      switch(epNumber)
                      {
                  #if (USBFS_DMA1_ACTIVE)
                      case USBFS_EP1:
                          USBFS_DmaChan[epNumber] = USBFS_ep1_DmaInitialize(USBFS_DMA_BYTES_PER_BURST,
                                                                                                  USBFS_DMA_REQUEST_PER_
             -BURST, src, dst);
                          break;
                  #endif /* (USBFS_DMA1_ACTIVE) */
              
                  #if (USBFS_DMA2_ACTIVE)
                      case USBFS_EP2:
                          USBFS_DmaChan[epNumber] = USBFS_ep2_DmaInitialize(USBFS_DMA_BYTES_PER_BURST,
                                                                                                  USBFS_DMA_REQUEST_PER_
             -BURST, src, dst);
                          break;
                  #endif /* (USBFS_DMA2_ACTIVE) */
              
                  #if (USBFS_DMA3_ACTIVE)
                          case USBFS_EP3:
                              USBFS_DmaChan[epNumber] = USBFS_ep3_DmaInitialize(USBFS_DMA_BYTES_PER_BURST,
                                                                                                      USBFS_DMA_REQUEST_
             -PER_BURST, src, dst);
                          break;
                  #endif /* (USBFS_DMA3_ACTIVE) */
              
                  #if (USBFS_DMA4_ACTIVE)
                          case USBFS_EP4:
                              USBFS_DmaChan[epNumber] = USBFS_ep4_DmaInitialize(USBFS_DMA_BYTES_PER_BURST,
                                                                                                      USBFS_DMA_REQUEST_
             -PER_BURST, src, dst);
                          break;
                  #endif /* (USBFS_DMA4_ACTIVE) */
              
                  #if (USBFS_DMA5_ACTIVE)
                          case USBFS_EP5:
                              USBFS_DmaChan[epNumber] = USBFS_ep5_DmaInitialize(USBFS_DMA_BYTES_PER_BURST,
                                                                                                      USBFS_DMA_REQUEST_
             -PER_BURST, src, dst);
                          break;
                  #endif /* (USBFS_DMA5_ACTIVE) */
              
                  #if (USBFS_DMA6_ACTIVE)
                      case USBFS_EP6:
                          USBFS_DmaChan[epNumber] = USBFS_ep6_DmaInitialize(USBFS_DMA_BYTES_PER_BURST,
                                                                                                  USBFS_DMA_REQUEST_PER_
             -BURST, src, dst);
                          break;
                  #endif /* (USBFS_DMA6_ACTIVE) */
              
                  #if (USBFS_DMA7_ACTIVE)
                      case USBFS_EP7:
                              USBFS_DmaChan[epNumber] = USBFS_ep7_DmaInitialize(USBFS_DMA_BYTES_PER_BURST,
                                                                                                      USBFS_DMA_REQUEST_
             -PER_BURST, src, dst);
                          break;
                  #endif /* (USBFS_DMA7_ACTIVE) */
              
                  #if (USBFS_DMA8_ACTIVE)
                      case USBFS_EP8:
                              USBFS_DmaChan[epNumber] = USBFS_ep8_DmaInitialize(USBFS_DMA_BYTES_PER_BURST,
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 20  

                                                                                                      USBFS_DMA_REQUEST_
             -PER_BURST, src, dst);
                          break;
                  #endif /* (USBFS_DMA8_ACTIVE) */
              
                      default:
                          /* Do nothing for endpoints other than 1-8. */
                          break;
                      }
              
                      if ((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
                      {
                          USBFS_DmaTd[epNumber] = CyDmaTdAllocate();
              
                      #if (USBFS_EP_MANAGEMENT_DMA_AUTO && (USBFS_EP_DMA_AUTO_OPT == 0u))
                          USBFS_DmaNextTd[epNumber] = CyDmaTdAllocate();
                      #endif /* (USBFS_EP_MANAGEMENT_DMA_AUTO && (USBFS_EP_DMA_AUTO_OPT == 0u)) */
                      }
                  }
              #endif /* (CY_PSOC4) */
              
                  /***************************************************************************
                  * Function Name: USBFS_Stop_DMA
                  ************************************************************************//**
                  *  
                  *  This function stops DMA channel associated with endpoint. It is available 
                  *  when the Endpoint Buffer Management parameter is set to DMA. Call this 
                  *  function when endpoint direction is changed from IN to OUT or vice versa 
                  *  to trigger DMA re-configuration when USBFS_LoadInEP() or 
                  *  USBFS_ReadOutEP() functions are called the first time. 
                  *  
                  *  \param epNumber: The data endpoint number for which associated DMA 
                  *  channel is stopped. The range of valid values is between 1 and 8. To stop 
                  *  all DMAs associated with endpoints call this function with 
                  *  USBFS_MAX_EP argument.
                  *
                  * \reentrant
                  *  No.
                  *
                  ***************************************************************************/
                  void USBFS_Stop_DMA(uint8 epNumber) 
                  {
                      uint8 i;
              
                      i = (epNumber < USBFS_MAX_EP) ? epNumber : USBFS_EP1;
              
                      do
                      {
                      #if (CY_PSOC4)
                          if (0u != USBFS_DmaChan[i])
                          {
                              USBFS_CyDmaChDisable(USBFS_DmaChan[i]);
                          }
                      #else
                          if(USBFS_DmaTd[i] != DMA_INVALID_TD)
                          {
                              (void) CyDmaChDisable(USBFS_DmaChan[i]);
                              CyDmaTdFree(USBFS_DmaTd[i]);
                              USBFS_DmaTd[i] = DMA_INVALID_TD;
                          }
              
                          #if (USBFS_EP_MANAGEMENT_DMA_AUTO && (USBFS_EP_DMA_AUTO_OPT == 0u))
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 21  

                              if(USBFS_DmaNextTd[i] != DMA_INVALID_TD)
                              {
                                  CyDmaTdFree(USBFS_DmaNextTd[i]);
                                  USBFS_DmaNextTd[i] = DMA_INVALID_TD;
                              }
                          #endif /* (USBFS_EP_MANAGEMENT_DMA_AUTO && (USBFS_EP_DMA_AUTO_OPT == 0u)) */
              
                      #endif /* (CY_PSOC4) */
                          i++;
                      }
                      while ((i < USBFS_MAX_EP) && (epNumber == USBFS_MAX_EP));
                  }
              #endif /* (USBFS_EP_MANAGEMENT_DMA) */
1237          
1238          
1239          #if (CY_PSOC3 || CY_PSOC5)
1240          #if (USBFS_EP_MANAGEMENT_DMA_AUTO && (USBFS_EP_DMA_AUTO_OPT == 0u))
                  /***************************************************************************
                  * Function Name: USBFS_LoadNextInEP
                  ************************************************************************//**
                  *
                  * Summary:
                  *  This internal function is used for IN endpoint DMA reconfiguration in
                  *  Auto DMA mode.
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number.
                  *  mode:   0 - Configure DMA to send the the rest of data.
                  *          1 - Configure DMA to repeat 2 last bytes of the first burst.
                  *
                  ***************************************************************************/
                  void USBFS_LoadNextInEP(uint8 epNumber, uint8 mode) 
                  {
                      reg16 *convert;
              
                      if (mode == 0u)
                      {
                          /* Configure DMA to send rest of data. */
                          /* CyDmaTdSetConfiguration API is optimized to change transfer length only and configure TD. *
             -/
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBFS_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length. */
                          CY_SET_REG16(convert, USBFS_inLength[epNumber] - USBFS_DMA_BYTES_PER_BURST);
                          /* CyDmaTdSetAddress API is optimized to change source address only. */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBFS_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert, LO16((uint32)USBFS_inDataPointer[epNumber] +
                                                          USBFS_DMA_BYTES_PER_BURST));
                          USBFS_inBufFull[epNumber] = 1u;
                      }
                      else
                      {
                          /* Configure DMA to repeat 2 last bytes of the first burst. */
                          /* CyDmaTdSetConfiguration API is optimized to change transfer length only and configure TD. *
             -/
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBFS_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length. */
                          CY_SET_REG16(convert, USBFS_DMA_BYTES_REPEAT);
                          /* CyDmaTdSetAddress API is optimized to change source address only. */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBFS_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert,  LO16((uint32)USBFS_inDataPointer[epNumber] +
                                                 (USBFS_DMA_BYTES_PER_BURST - USBFS_DMA_BYTES_REPEAT)));
                      }
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 22  

              
                      /* CyDmaChSetInitialTd API is optimized to initialize TD. */
                      CY_DMA_CH_STRUCT_PTR[USBFS_DmaChan[epNumber]].basic_status[1u] = USBFS_DmaTd[epNumber];
                  }
              #endif /* (USBFS_EP_MANAGEMENT_DMA_AUTO && (USBFS_EP_DMA_AUTO_OPT == 0u)) */
1289          #endif /* (CY_PSOC3 || CY_PSOC5) */
1290          
1291          
1292          /*******************************************************************************
1293          * Function Name: USBFS_LoadInEP
1294          ****************************************************************************//**
1295          *
1296          *  This function performs different functionality depending on the Component’s
1297          *  configured Endpoint Buffer Management. This parameter is defined in
1298          *  the Descriptor Root in Component Configure window.
1299          *
1300          *  *Manual (Static/Dynamic Allocation):*
1301          *  This function loads and enables the specified USB data endpoint for an IN
1302          *  data transfer.
1303          *
1304          *  *DMA with Manual Buffer Management:*
1305          *  Configures DMA for a data transfer from system RAM to endpoint buffer.
1306          *  Generates request for a transfer.
1307          *
1308          *  *DMA with Automatic Buffer Management:*
1309          *  Configures DMA. This is required only once, so it is done only when parameter
1310          *  pData is not NULL. When the pData pointer is NULL, the function skips this
1311          *  task. Sets Data ready status: This generates the first DMA transfer and
1312          *  prepares data in endpoint buffer.
1313          *
1314          *  \param epNumber Contains the data endpoint number.
1315          *            Valid values are between 1 and 8.
1316          *  \param *pData A pointer to a data array from which the data for the endpoint space
1317          *          is loaded.
1318          *  \param length The number of bytes to transfer from the array and then send as
1319          *          a result of an IN request. Valid values are between 0 and 512
1320          *          (1023 for DMA with Automatic Buffer Management mode). The value 512
1321          *          is applicable if only one endpoint is used.
1322          *
1323          *
1324          * \reentrant
1325          *  No.
1326          *
1327          *******************************************************************************/
1328          void USBFS_LoadInEP(uint8 epNumber, const uint8 pData[], uint16 length)
1329                                                                                  
1330          {
1331   1          if ((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
1332   1          {
1333   2          #if (!USBFS_EP_MANAGEMENT_DMA_AUTO)
1334   2              /* Limit length to available buffer USB IP buffer size.*/
1335   2              if (length > (USBFS_EPX_DATA_BUF_MAX - USBFS_EP[epNumber].buffOffset))
1336   2              {
1337   3                  length = USBFS_EPX_DATA_BUF_MAX - USBFS_EP[epNumber].buffOffset;
1338   3              }
1339   2          #endif /* (!USBFS_EP_MANAGEMENT_DMA_AUTO) */
1340   2      
1341   2              /* Set count and data toggle. */
1342   2              USBFS_SIE_EP_BASE.sieEp[epNumber].epCnt0 = (uint8) HI8(length) | USBFS_EP[epNumber].epToggle;
1343   2              USBFS_SIE_EP_BASE.sieEp[epNumber].epCnt1 = (uint8) LO8(length);
1344   2      
1345   2          #if (USBFS_EP_MANAGEMENT_MANUAL)
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 23  

1346   2              if (NULL != pData)
1347   2              {
1348   3                              /* Copy data using arbiter data register. */
1349   3                  uint16 i;
1350   3                  for (i = 0u; i < length; ++i)
1351   3                  {
1352   4                      USBFS_ARB_EP_BASE.arbEp[epNumber].rwDr = pData[i];
1353   4                  }
1354   3              }
1355   2      
1356   2              /* IN endpoint buffer is full - read to be read. */
1357   2              USBFS_EP[epNumber].apiEpState = USBFS_NO_EVENT_PENDING;
1358   2      
1359   2              /* Arm IN endpoint. */
1360   2              USBFS_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBFS_EP[epNumber].epMode;
1361   2      
1362   2          #else
              
                      #if (CY_PSOC3 || CY_PSOC5LP)
                          /* Initialize DMA if it was not initialized. */
                          if (DMA_INVALID_TD == USBFS_DmaTd[epNumber])
                          {
                              USBFS_InitEP_DMA(epNumber, pData);
                          }
                      #endif /* (CY_PSOC3 || CY_PSOC5LP) */
              
                      #if (USBFS_EP_MANAGEMENT_DMA_MANUAL)
                          /* IN endpoint buffer will be fully loaded by DMA shortly. */
                          USBFS_EP[epNumber].apiEpState = USBFS_NO_EVENT_PENDING;
              
                          if ((pData != NULL) && (length > 0u))
                          {
                          #if (CY_PSOC4)
                              uint32 channelNum = (uint32) USBFS_DmaChan[epNumber];
              
                              /* Disable DMA channel: start configuration. */
                              USBFS_CyDmaChDisable(channelNum);
              
                              /* Configure source and destination. */
                              USBFS_CyDmaSetSrcAddress(channelNum, USBFS_DMA_DESCR0, (void*) pData);
                              USBFS_CyDmaSetDstAddress(channelNum, USBFS_DMA_DESCR0, (void*) &USBFS_ARB_EP_BASE.arbEp[ep
             -Number].rwDr);
              
                              /* Configure DMA descriptor. */
                              --length;
                              USBFS_CyDmaSetConfiguration(channelNum, USBFS_DMA_DESCR0, USBFS_DMA_COMMON_CFG | length |
                                                                      CYDMA_BYTE | CYDMA_ELEMENT_WORD | CYDMA_INC_SRC_AD
             -DR | CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                              /* Validate descriptor to execute on following DMA request. */
                              USBFS_CyDmaValidateDescriptor(channelNum, USBFS_DMA_DESCR0);
              
                              /* Enable DMA channel: configuration complete. */
                              USBFS_CyDmaChEnable(channelNum);
                          #else
                              /* Configure DMA to transfer data. */
                              (void) CyDmaChDisable(USBFS_DmaChan[epNumber]);
                              (void) CyDmaTdSetConfiguration(USBFS_DmaTd[epNumber], length, CY_DMA_DISABLE_TD, TD_TERMIN
             -_EN | TD_INC_SRC_ADR);
                              (void) CyDmaTdSetAddress(USBFS_DmaTd[epNumber], LO16((uint32) pData), LO16((uint32) &USBFS
             -_ARB_EP_BASE.arbEp[epNumber].rwDr));
              
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 24  

                              /* Enable DMA channel. */
                              (void) CyDmaChSetInitialTd(USBFS_DmaChan[epNumber], USBFS_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USBFS_DmaChan[epNumber], 1u);
                          #endif /* (CY_PSOC4) */
              
                              /* Generate DMA request. */
                              USBFS_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint8)  USBFS_ARB_EPX_CFG_DMA_REQ;
                              USBFS_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint8) ~USBFS_ARB_EPX_CFG_DMA_REQ;
              
                              /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer has 
             -been completed. */
                          }
                          else
                          {
                              /* When zero-length packet: arm IN endpoint directly. */
                              USBFS_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBFS_EP[epNumber].epMode;
                          }
                      #endif /* (USBFS_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USBFS_EP_MANAGEMENT_DMA_AUTO)
                          if (pData != NULL)
                          {
                          #if (CY_PSOC4)
                              uint32 channelNum = (uint32) USBFS_DmaChan[epNumber];
              
                              /* Store address of buffer. */
                              USBFS_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
              
                              /* Disable DMA channel: start configuration. */
                              USBFS_CyDmaChDisable(channelNum);
              
                              /* Set destination address. */
                              USBFS_CyDmaSetDstAddress(channelNum, USBFS_DMA_DESCR0, (void*) &USBFS_ARB_EP_BASE.arbEp[ep
             -Number].rwDr);
                              USBFS_CyDmaSetDstAddress(channelNum, USBFS_DMA_DESCR1, (void*) &USBFS_ARB_EP_BASE.arbEp[ep
             -Number].rwDr);
              
                              /* Configure DMA descriptor. */
                              USBFS_CyDmaSetConfiguration(channelNum, USBFS_DMA_DESCR0, USBFS_DMA_COMMON_CFG  |
                                                                      CYDMA_BYTE | CYDMA_ELEMENT_WORD | CYDMA_INC_SRC_AD
             -DR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                              /* Configure DMA descriptor. */
                              USBFS_CyDmaSetConfiguration(channelNum, USBFS_DMA_DESCR1, USBFS_DMA_COMMON_CFG  |
                                                                      CYDMA_BYTE | CYDMA_ELEMENT_WORD | CYDMA_INC_SRC_AD
             -DR | CYDMA_CHAIN);
              
                              /* Enable interrupt from DMA channel. */
                              USBFS_CyDmaSetInterruptMask(channelNum);
              
                              /* Validate descriptor 1. It will not be invalided during operation. */
                              USBFS_CyDmaValidateDescriptor(channelNum, USBFS_DMA_DESCR1);
              
                              /* Enable DMA channel: configuration complete. */
                              USBFS_CyDmaChEnable(channelNum);
              
                          #else
                              (void) CyDmaChDisable(USBFS_DmaChan[epNumber]);
              
                              #if (USBFS_EP_DMA_AUTO_OPT == 0u)
                                  USBFS_inLength[epNumber] = length;
                                  USBFS_inDataPointer[epNumber] = pData;
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 25  

              
                                  /* Configure DMA to send data only for first burst */
                                  (void) CyDmaTdSetConfiguration(USBFS_DmaTd[epNumber],
                                      (length > USBFS_DMA_BYTES_PER_BURST) ? USBFS_DMA_BYTES_PER_BURST : length,
                                      USBFS_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR);
                                  (void) CyDmaTdSetAddress(USBFS_DmaTd[epNumber], LO16((uint32) pData),
                                                                                             LO16((uint32) &USBFS_ARB_EP
             -_BASE.arbEp[epNumber].rwDr));
              
                                  /* The second TD will be executed only when the first one fails.
                                  *  The intention of this TD is to generate NRQ interrupt
                                  *  and repeat 2 last bytes of the first burst.
                                  */
                                  (void) CyDmaTdSetConfiguration(USBFS_DmaNextTd[epNumber], 1u,
                                                                 USBFS_DmaNextTd[epNumber],
                                                                 USBFS_epX_TD_TERMOUT_EN[epNumber]);
              
                                  /* Configure DmaNextTd to clear Data Ready status. */
                                  (void) CyDmaTdSetAddress(USBFS_DmaNextTd[epNumber], LO16((uint32) &clearInDataRdyStatu
             -s),
                                                                                                 LO16((uint32) &USBFS_AR
             -B_EP_BASE.arbEp[epNumber].epCfg));
                              #else
                                  /* Configure DMA to send all data. */
                                  (void) CyDmaTdSetConfiguration(USBFS_DmaTd[epNumber], length,
                                                                 USBFS_DmaTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR);
                                  (void) CyDmaTdSetAddress(USBFS_DmaTd[epNumber], LO16((uint32) pData),
                                                                                             LO16((uint32) &USBFS_ARB_EP
             -_BASE.arbEp[epNumber].rwDr));
                              #endif /* (USBFS_EP_DMA_AUTO_OPT == 0u) */
              
                              /* Clear any potential pending DMA requests before starting DMA channel to transfer data. 
             -*/
                              (void) CyDmaClearPendingDrq(USBFS_DmaChan[epNumber]);
                              /* Enable DMA. */
                              (void) CyDmaChSetInitialTd(USBFS_DmaChan[epNumber], USBFS_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USBFS_DmaChan[epNumber], 1u);
                          #endif /* (CY_PSOC4) */
                          }
                          else
                          {
                              /* IN endpoint buffer (32 bytes) will shortly be preloaded by DMA. */
                              USBFS_EP[epNumber].apiEpState = USBFS_NO_EVENT_PENDING;
              
                              if (length > 0u)
                              {
                              #if (CY_PSOC4)
                                  uint32 lengthDescr0, lengthDescr1;
                                  uint32 channelNum = (uint32) USBFS_DmaChan[epNumber];
              
                                  /* Get number of full bursts. */
                                  USBFS_DmaEpBurstCnt[epNumber] = (uint8) (length / USBFS_DMA_BYTES_PER_BURST);
              
                                  /* Get number of elements in the last burst. */
                                  USBFS_DmaEpLastBurstEl[epNumber] = (uint8) (length % USBFS_DMA_BYTES_PER_BURST);
              
                                  /* Get total number of bursts. */
                                  USBFS_DmaEpBurstCnt[epNumber] += (0u != USBFS_DmaEpLastBurstEl[epNumber]) ? 1u : 0u;
              
                                  /* Adjust number of data elements transferred in last burst. */
                                  USBFS_DmaEpLastBurstEl[epNumber] = (0u != USBFS_DmaEpLastBurstEl[epNumber]) ?
                                                                                        (USBFS_DmaEpLastBurstEl[epNumber
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 26  

             -] - 1u) :
                                                                                        (USBFS_DMA_BYTES_PER_BURST - 1u)
             -;
              
                                  /* Get number of data elements to transfer for descriptor 0 and 1. */
                                  lengthDescr0 = (1u == USBFS_DmaEpBurstCnt[epNumber]) ? USBFS_DmaEpLastBurstEl[epNumber
             -] : (USBFS_DMA_BYTES_PER_BURST - 1u);
                                  lengthDescr1 = (2u == USBFS_DmaEpBurstCnt[epNumber]) ? USBFS_DmaEpLastBurstEl[epNumber
             -] : (USBFS_DMA_BYTES_PER_BURST - 1u);
              
              
                                  /* Mark which descriptor is last one to execute. */
                                  USBFS_DmaEpLastBurstEl[epNumber] |= (0u != (USBFS_DmaEpBurstCnt[epNumber] & 0x1u)) ?
                                                                                          USBFS_DMA_DESCR0_MASK : USBFS_
             -DMA_DESCR1_MASK;
              
                                  /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger a
             -fter valid descriptor were executed. */
                                  USBFS_DmaEpBurstCnt[epNumber] = USBFS_DMA_GET_BURST_CNT(USBFS_DmaEpBurstCnt[epNumber])
             -;
              
                                  /* Restore DMA settings for current transfer. */
                                  USBFS_CyDmaChDisable(channelNum);
              
                                  /* Restore destination address for input endpoint. */
                                  USBFS_CyDmaSetSrcAddress(channelNum, USBFS_DMA_DESCR0, (void*) ((uint32) USBFS_DmaEpBu
             -fferAddrBackup[epNumber]));
                                  USBFS_CyDmaSetSrcAddress(channelNum, USBFS_DMA_DESCR1, (void*) ((uint32) USBFS_DmaEpBu
             -fferAddrBackup[epNumber] +
                                                                                                                        
             -         USBFS_DMA_BYTES_PER_BURST));
              
                                  /* Set number of elements to transfer. */
                                  USBFS_CyDmaSetNumDataElements(channelNum, USBFS_DMA_DESCR0, lengthDescr0);
                                  USBFS_CyDmaSetNumDataElements(channelNum, USBFS_DMA_DESCR1, lengthDescr1);
              
                                  /* Validate descriptor 0 and command to start with it. */
                                  USBFS_CyDmaValidateDescriptor(channelNum, USBFS_DMA_DESCR0);
                                  USBFS_CyDmaSetDescriptor0Next(channelNum);
              
                                  /* Enable DMA channel: configuration complete. */
                                  USBFS_CyDmaChEnable(channelNum);
              
                              #elif (USBFS_EP_DMA_AUTO_OPT == 0u)
                                  USBFS_inLength[epNumber]  = length;
                                  USBFS_inBufFull[epNumber] = 0u;
              
                                  (void) CyDmaChDisable(USBFS_DmaChan[epNumber]);
                                  /* Configure DMA to send data only for first burst. */
                                  (void) CyDmaTdSetConfiguration(
                                      USBFS_DmaTd[epNumber], (length > USBFS_DMA_BYTES_PER_BURST) ?
                                      USBFS_DMA_BYTES_PER_BURST : length,
                                      USBFS_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR );
                                  (void) CyDmaTdSetAddress(USBFS_DmaTd[epNumber], LO16((uint32)  USBFS_inDataPointer[epN
             -umber]),
                                                                                             LO16((uint32) &USBFS_ARB_EP
             -_BASE.arbEp[epNumber].rwDr));
                                  /* Clear Any potential pending DMA requests before starting DMA channel to transfer da
             -ta. */
                                  (void) CyDmaClearPendingDrq(USBFS_DmaChan[epNumber]);
                                  /* Enable DMA. */
                                  (void) CyDmaChSetInitialTd(USBFS_DmaChan[epNumber], USBFS_DmaTd[epNumber]);
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 27  

                                  (void) CyDmaChEnable(USBFS_DmaChan[epNumber], 1u);
                              #endif /* (CY_PSOC4) */
              
                              #if !defined (USBFS_MANUAL_IN_EP_ARM)
                                  /* Set IN data ready to generate DMA request to load data into endpoint buffer. */
                                  USBFS_ARB_EP_BASE.arbEp[epNumber].epCfg |= USBFS_ARB_EPX_CFG_IN_DATA_RDY;
                              #endif  /* (USBFS_MANUAL_IN_EP_ARM) */
              
                                  /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer 
             -has been completed. */
                              }
                              else
                              {
                                  /* When zero-length packet: arm IN endpoint directly. */
                                  USBFS_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBFS_EP[epNumber].epMode;
                              }
                          }
                      #endif /* (USBFS_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USBFS_EP_MANAGEMENT_MANUAL) */
1585   2          }
1586   1      }
1587          
1588          
1589          /*******************************************************************************
1590          * Function Name: USBFS_ReadOutEP
1591          ****************************************************************************//**
1592          *
1593          *   This function performs different functionality depending on the Component’s
1594          *   configured Endpoint Buffer Management. This parameter is defined in the
1595          *   Descriptor Root in Component Configure window.
1596          *
1597          *   *Manual (Static/Dynamic Allocation):*
1598          *   This function moves the specified number of bytes from endpoint buffer to
1599          *   system RAM. The number of bytes actually transferred from endpoint buffer to
1600          *   system RAM is the lesser of the actual number of bytes sent by the host or
1601          *   the number of bytes requested by the length parameter.
1602          *
1603          *   *DMA with Manual Buffer Management:*
1604          *   Configure DMA to transfer data from endpoint buffer to system RAM. Generate
1605          *   a DMA request. The firmware must wait until the DMA completes the data
1606          *   transfer after calling the USBFS_ReadOutEP() API. For example,
1607          *   by checking EPstate:
1608          *
1609          *   \snippet /USBFS_sut_02.cydsn/main.c checking EPstatey
1610          *
1611          *   The USBFS_EnableOutEP() has to be called to allow host to write data into
1612          *   the endpoint buffer after DMA has completed transfer data from OUT endpoint
1613          *   buffer to SRAM.
1614          *
1615          *   *DMA with Automatic Buffer Management:*
1616          *   Configure DMA. This is required only once and automatically generates DMA
1617          *   requests as data arrives
1618          *
1619          *  \param epNumber: Contains the data endpoint number.
1620          *            Valid values are between 1 and 8.
1621          *  \param pData: A pointer to a data array from which the data for the endpoint
1622          *         space is loaded.
1623          *  \param length: The number of bytes to transfer from the USB Out endpoint and
1624          *          loads it into data array. Valid values are between 0 and 1023. The
1625          *          function moves fewer than the requested number of bytes if the host
1626          *          sends fewer bytes than requested.
1627          *
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 28  

1628          * \return
1629          *  Number of bytes received, 0 for an invalid endpoint.
1630          *
1631          * \reentrant
1632          *  No.
1633          *
1634          *******************************************************************************/
1635          uint16 USBFS_ReadOutEP(uint8 epNumber, uint8 pData[], uint16 length)
1636                                                                                  
1637          {
1638   1          if ((pData != NULL) && (epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
1639   1          {
1640   2          #if (!USBFS_EP_MANAGEMENT_DMA_AUTO)
1641   2              /* Adjust requested length to available data. */
1642   2              length = (length > USBFS_GetEPCount(epNumber)) ? USBFS_GetEPCount(epNumber) : length;
1643   2          #endif /* (!USBFS_EP_MANAGEMENT_DMA_AUTO) */
1644   2      
1645   2          #if (USBFS_EP_MANAGEMENT_MANUAL)
1646   2              {
1647   3                  /* Copy data using arbiter data register. */
1648   3                  uint16 i;
1649   3                  for (i = 0u; i < length; ++i)
1650   3                  {
1651   4                      pData[i] = (uint8) USBFS_ARB_EP_BASE.arbEp[epNumber].rwDr;
1652   4                  }
1653   3              }
1654   2      
1655   2              /* Arm OUT endpoint after data has been copied from endpoint buffer. */
1656   2              USBFS_EnableOutEP(epNumber);
1657   2          #else
              
                      #if (CY_PSOC3 || CY_PSOC5LP)
                          /* Initialize DMA if it was not initialized. */
                          if (DMA_INVALID_TD == USBFS_DmaTd[epNumber])
                          {
                              USBFS_InitEP_DMA(epNumber, pData);
                          }
                      #endif /* (CY_PSOC3 || CY_PSOC5LP) */
              
                      #if (USBFS_EP_MANAGEMENT_DMA_MANUAL)
                      #if (CY_PSOC4)
                      {
                          uint32 channelNum = (uint32) USBFS_DmaChan[epNumber];
              
                          /* Disable DMA channel: start configuration. */
                          USBFS_CyDmaChDisable(channelNum);
              
                          /* Configure source and destination. */
                          USBFS_CyDmaSetSrcAddress(channelNum, USBFS_DMA_DESCR0, (void*) &USBFS_ARB_EP_BASE.arbEp[epNumb
             -er].rwDr);
                          USBFS_CyDmaSetDstAddress(channelNum, USBFS_DMA_DESCR0, (void*) pData);
              
                          /* Configure DMA descriptor. */
                          USBFS_CyDmaSetConfiguration(channelNum, USBFS_DMA_DESCR0, USBFS_DMA_COMMON_CFG | (uint16)(leng
             -th - 1u) |
                                                                  CYDMA_BYTE | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_ADDR |
             - CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                          /* Validate descriptor to execute on following DMA request. */
                          USBFS_CyDmaValidateDescriptor(channelNum, USBFS_DMA_DESCR0);
              
                          /* Enable DMA channel: configuration complete. */
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 29  

                          USBFS_CyDmaChEnable(channelNum);
                      }
                      #else
                          /* Configure DMA to transfer data. */
                          (void) CyDmaChDisable(USBFS_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USBFS_DmaTd[epNumber], length, CY_DMA_DISABLE_TD, TD_TERMIN_EN 
             -| TD_INC_DST_ADR);
                          (void) CyDmaTdSetAddress(USBFS_DmaTd[epNumber], LO16((uint32) &USBFS_ARB_EP_BASE.arbEp[epNumbe
             -r].rwDr), LO16((uint32)pData));
              
                          /* Enable DMA channel. */
                          (void) CyDmaChSetInitialTd(USBFS_DmaChan[epNumber], USBFS_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USBFS_DmaChan[epNumber], 1u);
                      #endif /* (CY_PSOC4) */
              
                          /* Generate DMA request. */
                          USBFS_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint8)  USBFS_ARB_EPX_CFG_DMA_REQ;
                          USBFS_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint8) ~USBFS_ARB_EPX_CFG_DMA_REQ;
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
              
                      #endif /* (USBFS_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USBFS_EP_MANAGEMENT_DMA_AUTO)
                      #if (CY_PSOC4)
                      {
                          uint32 channelNum = (uint32) USBFS_DmaChan[epNumber];
                          uint32 lengthDescr0, lengthDescr1;
              
                          /* Get number of full bursts. */
                          USBFS_DmaEpBurstCnt[epNumber] = (uint8) (length / USBFS_DMA_BYTES_PER_BURST);
              
                          /* Get number of elements in the last burst. */
                          USBFS_DmaEpLastBurstEl[epNumber] = (uint8) (length % USBFS_DMA_BYTES_PER_BURST);
              
                          /* Get total number of bursts. */
                          USBFS_DmaEpBurstCnt[epNumber] += (0u != USBFS_DmaEpLastBurstEl[epNumber]) ? 1u : 0u;
              
                          /* Adjust number of the data elements transfered in last burst. */
                          USBFS_DmaEpLastBurstEl[epNumber] = (0u != USBFS_DmaEpLastBurstEl[epNumber]) ?
                                                                                (USBFS_DmaEpLastBurstEl[epNumber] - 1u) 
             -:
                                                                                (USBFS_DMA_BYTES_PER_BURST - 1u);
              
                          /* Get number of data elements to transfer for descriptor 0 and 1. */
                          lengthDescr0 = (1u == USBFS_DmaEpBurstCnt[epNumber]) ? USBFS_DmaEpLastBurstEl[epNumber] : (USB
             -FS_DMA_BYTES_PER_BURST - 1u);
                          lengthDescr1 = (2u == USBFS_DmaEpBurstCnt[epNumber]) ? USBFS_DmaEpLastBurstEl[epNumber] : (USB
             -FS_DMA_BYTES_PER_BURST - 1u);
              
                          /* Mark if revert number of data elements in descriptor after transfer completion. */
                          USBFS_DmaEpLastBurstEl[epNumber] |= (USBFS_DmaEpBurstCnt[epNumber] > 2u) ? USBFS_DMA_DESCR_REV
             -ERT : 0u;
              
                          /* Mark last descriptor to be executed. */
                          USBFS_DmaEpLastBurstEl[epNumber] |= (0u != (USBFS_DmaEpBurstCnt[epNumber] & 0x1u)) ?
                                                                                  USBFS_DMA_DESCR0_MASK : USBFS_DMA_DESC
             -R1_MASK;
              
                          /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger after val
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 30  

             -id descriptor were executed. */
                          USBFS_DmaEpBurstCnt[epNumber] = USBFS_DMA_GET_BURST_CNT(USBFS_DmaEpBurstCnt[epNumber]);
              
                          /* Store address of buffer and burst counter for endpoint. */
                          USBFS_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
                          USBFS_DmaEpBurstCntBackup[epNumber]   = USBFS_DmaEpBurstCnt[epNumber];
              
                          /* Disable DMA channel: start configuration. */
                          USBFS_CyDmaChDisable(channelNum);
              
                          /* Set destination address. */
                          USBFS_CyDmaSetSrcAddress(channelNum, USBFS_DMA_DESCR0, (void*) &USBFS_ARB_EP_BASE.arbEp[epNumb
             -er].rwDr);
                          USBFS_CyDmaSetSrcAddress(channelNum, USBFS_DMA_DESCR1, (void*) &USBFS_ARB_EP_BASE.arbEp[epNumb
             -er].rwDr);
              
                          USBFS_CyDmaSetDstAddress(channelNum, USBFS_DMA_DESCR0, (void*) ((uint32) pData));
                          USBFS_CyDmaSetDstAddress(channelNum, USBFS_DMA_DESCR1, (void*) ((uint32) pData + USBFS_DMA_BYT
             -ES_PER_BURST));
              
                          /* Configure DMA descriptor. */
                          USBFS_CyDmaSetConfiguration(channelNum, USBFS_DMA_DESCR0, USBFS_DMA_COMMON_CFG  | lengthDescr0
             - |
                                                                  CYDMA_BYTE | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_ADDR |
             - CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                          /* Configure DMA descriptor. */
                          USBFS_CyDmaSetConfiguration(channelNum, USBFS_DMA_DESCR1, USBFS_DMA_COMMON_CFG  | lengthDescr1
             - |
                                                                  CYDMA_BYTE | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_ADDR |
             - CYDMA_CHAIN);
              
                          /* Enable interrupt from DMA channel. */
                          USBFS_CyDmaSetInterruptMask(channelNum);
              
                          /* Validate DMA descriptor 0 and 1. */
                          USBFS_CyDmaValidateDescriptor(channelNum, USBFS_DMA_DESCR0);
                          USBFS_CyDmaValidateDescriptor(channelNum, USBFS_DMA_DESCR1);
              
                          /* Enable DMA channel: configuration complete. */
                          USBFS_CyDmaChEnable(channelNum);
                      }
                      #else
                          (void) CyDmaChDisable(USBFS_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USBFS_DmaTd[epNumber], length,  USBFS_DmaTd[epNumber], TD_TERMI
             -N_EN | TD_INC_DST_ADR);
                          (void) CyDmaTdSetAddress(USBFS_DmaTd[epNumber], LO16((uint32) &USBFS_ARB_EP_BASE.arbEp[epNumbe
             -r].rwDr), LO16((uint32) pData));
              
                          /* Clear Any potential pending DMA requests before starting DMA channel to transfer data. */
                          (void) CyDmaClearPendingDrq(USBFS_DmaChan[epNumber]);
              
                          /* Enable DMA channel. */
                          (void) CyDmaChSetInitialTd(USBFS_DmaChan[epNumber], USBFS_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USBFS_DmaChan[epNumber], 1u);
                      #endif /* (CY_PSOC4) */
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
              
                      #endif /* (USBFS_EP_MANAGEMENT_DMA_AUTO) */
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 31  

                  #endif /* (USBFS_EP_MANAGEMENT_MANUAL) */
1795   2          }
1796   1          else
1797   1          {
1798   2              length = 0u;
1799   2          }
1800   1      
1801   1          return (length);
1802   1      }
1803          
1804          
1805          #if (USBFS_16BITS_EP_ACCESS_ENABLE)
              /*******************************************************************************
              * Function Name: USBFS_LoadInEP16
              ****************************************************************************//**
              *
              *  This function performs different functionality depending on the Component’s
              *  configured Endpoint Buffer Management. This parameter is defined in
              *  the Descriptor Root in Component Configure window.
              *
              *  *Manual (Static/Dynamic Allocation):*
              *  This function loads and enables the specified USB data endpoint for an IN
              *  data transfer.
              *
              *  *DMA with Manual Buffer Management:*
              *  Configures DMA for a data transfer from system RAM to endpoint buffer.
              *  Generates request for a transfer.
              *
              *  *DMA with Automatic Buffer Management:*
              *  Configures DMA. This is required only once, so it is done only when parameter
              *  pData is not NULL. When the pData pointer is NULL, the function skips this
              *  task. Sets Data ready status: This generates the first DMA transfer and
              *  prepares data in endpoint buffer.
              *
              *  \param epNumber Contains the data endpoint number.
              *        Valid values are between 1 and 8.
              *  \param *pData A pointer to a data array from which the data for the endpoint
              *        space is loaded. It shall be ensured that this pointer address is even
              *        to ensure the 16-bit transfer is aligned to even address. Else, a hard
              *        fault condition can occur.
              *  \param length The number of bytes to transfer from the array and then send as
              *        a result of an IN request. Valid values are between 0 and 512 (1023 for
              *        DMA with Automatic Buffer Management mode). The value 512 is applicable
              *        if only one endpoint is used.
              *
              * \reentrant
              *  No.
              *
              *******************************************************************************/
              void USBFS_LoadInEP16(uint8 epNumber, const uint8 pData[], uint16 length)
              {
                  /* Check array alignment on half-word boundary. */
                  CYASSERT(0u == (((uint32) pData) & 0x01u));
              
                  if ((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
                  {
                  #if (!USBFS_EP_MANAGEMENT_DMA_AUTO)
                      /* Limit length to available buffer USB IP buffer size. */
                      if (length > (USBFS_EPX_DATA_BUF_MAX - USBFS_EP[epNumber].buffOffset))
                      {
                          length = USBFS_EPX_DATA_BUF_MAX - USBFS_EP[epNumber].buffOffset;
                      }
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 32  

                  #endif /* (!USBFS_EP_MANAGEMENT_DMA_AUTO) */
              
                      /* Set count and data toggle. */
                      USBFS_SIE_EP_BASE.sieEp[epNumber].epCnt0 = (uint32) HI8(length) | USBFS_EP[epNumber].epToggle;
                      USBFS_SIE_EP_BASE.sieEp[epNumber].epCnt1 = (uint32) LO8(length);
              
                      /* Adjust requested length: 2 bytes are handled at one data register access. */
                      length += (length & 0x01u);
              
                  #if (USBFS_EP_MANAGEMENT_MANUAL)
                      if (NULL != pData)
                      {
                          /* Convert uint8 array to uint16. */
                          const uint16 *dataBuf = (uint16 *) pData;
              
                          /* Copy data using 16-bits arbiter data register. */
                          uint16 i;
                          for (i = 0u; i < (length >> 1u); ++i)
                          {
                              USBFS_ARB_EP16_BASE.arbEp[epNumber].rwDr16 = dataBuf[i];
                          }
                      }
              
                      /* IN endpoint buffer is full - read to be read. */
                      USBFS_EP[epNumber].apiEpState = USBFS_NO_EVENT_PENDING;
              
                      /* Arm IN endpoint. */
                      USBFS_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBFS_EP[epNumber].epMode;
              
                  #else
              
                      #if (USBFS_EP_MANAGEMENT_DMA_MANUAL)
                          /* IN endpoint buffer will be fully loaded by DMA shortly. */
                          USBFS_EP[epNumber].apiEpState = USBFS_NO_EVENT_PENDING;
              
                          if ((pData != NULL) && (length > 0u))
                          {
                              uint32 channelNum = (uint32) USBFS_DmaChan[epNumber];
              
                              /* Disable DMA channel: start configuration. */
                              USBFS_CyDmaChDisable(channelNum);
              
                              /* Configure source and destination. */
                              USBFS_CyDmaSetSrcAddress(channelNum, USBFS_DMA_DESCR0, (void*) pData);
                              USBFS_CyDmaSetDstAddress(channelNum, USBFS_DMA_DESCR0, (void*) &USBFS_ARB_EP16_BASE.arbEp[
             -epNumber].rwDr16);
              
                              /* Configure DMA descriptor. */
                              length = (length >> 1u) - 1u;
                              USBFS_CyDmaSetConfiguration(channelNum, USBFS_DMA_DESCR0, USBFS_DMA_COMMON_CFG | length |
                                                                      CYDMA_HALFWORD | CYDMA_ELEMENT_WORD | CYDMA_INC_SR
             -C_ADDR | CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                              /* Validate descriptor to execute on following DMA request. */
                              USBFS_CyDmaValidateDescriptor(channelNum, USBFS_DMA_DESCR0);
              
                              /* Enable DMA channel: configuration complete. */
                              USBFS_CyDmaChEnable(channelNum);
              
                              /* Generate DMA request. */
                              USBFS_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint32)  USBFS_ARB_EPX_CFG_DMA_REQ;
                              USBFS_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint32) ~USBFS_ARB_EPX_CFG_DMA_REQ;
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 33  

              
                              /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer has 
             -been completed. */
                          }
                          else
                          {
                              /* When zero-length packet: arm IN endpoint directly. */
                              USBFS_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBFS_EP[epNumber].epMode;
                          }
                      #endif /* (USBFS_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USBFS_EP_MANAGEMENT_DMA_AUTO)
                          if (pData != NULL)
                          {
                              uint32 channelNum = (uint32) USBFS_DmaChan[epNumber];
              
                              /* Store address of buffer. */
                              USBFS_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
              
                              /* Disable DMA channel: start configuration. */
                              USBFS_CyDmaChDisable(channelNum);
              
                              /* Set destination address. */
                              USBFS_CyDmaSetDstAddress(channelNum, USBFS_DMA_DESCR0, (void*) &USBFS_ARB_EP16_BASE.arbEp[
             -epNumber].rwDr16);
                              USBFS_CyDmaSetDstAddress(channelNum, USBFS_DMA_DESCR1, (void*) &USBFS_ARB_EP16_BASE.arbEp[
             -epNumber].rwDr16);
              
                              /* Configure DMA descriptor. */
                              USBFS_CyDmaSetConfiguration(channelNum, USBFS_DMA_DESCR0, USBFS_DMA_COMMON_CFG  |
                                                                      CYDMA_HALFWORD | CYDMA_ELEMENT_WORD | CYDMA_INC_SR
             -C_ADDR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                              /* Configure DMA descriptor. */
                              USBFS_CyDmaSetConfiguration(channelNum, USBFS_DMA_DESCR1, USBFS_DMA_COMMON_CFG  |
                                                                      CYDMA_HALFWORD | CYDMA_ELEMENT_WORD | CYDMA_INC_SR
             -C_ADDR | CYDMA_CHAIN);
              
                              /* Enable interrupt from DMA channel. */
                              USBFS_CyDmaSetInterruptMask(channelNum);
              
                              /* Validate descriptor 1. It will not be invalided during operation. */
                              USBFS_CyDmaValidateDescriptor(channelNum, USBFS_DMA_DESCR1);
              
                              /* Enable DMA channel: configuration complete. */
                              USBFS_CyDmaChEnable(channelNum);
                          }
                          else
                          {
                              /* IN endpoint buffer (32 bytes) will shortly be preloaded by DMA. */
                              USBFS_EP[epNumber].apiEpState = USBFS_NO_EVENT_PENDING;
              
                              if (length > 0u)
                              {
                                  uint32 lengthDescr0, lengthDescr1;
                                  uint32 channelNum = (uint32) USBFS_DmaChan[epNumber];
              
                                  /* Get number of full bursts. */
                                  USBFS_DmaEpBurstCnt[epNumber] = (uint8) (length / USBFS_DMA_BYTES_PER_BURST);
              
                                  /* Get number of elements in the last burst. */
                                  USBFS_DmaEpLastBurstEl[epNumber] = (uint8) (length % USBFS_DMA_BYTES_PER_BURST);
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 34  

              
                                  /* Get total number of bursts. */
                                  USBFS_DmaEpBurstCnt[epNumber] += (0u != USBFS_DmaEpLastBurstEl[epNumber]) ? 1u : 0u;
              
                                  /* Adjust number of data elements transferred in last burst. */
                                  USBFS_DmaEpLastBurstEl[epNumber] = (0u != USBFS_DmaEpLastBurstEl[epNumber]) ?
                                                                                        ((USBFS_DmaEpLastBurstEl[epNumbe
             -r] >> 1u) - 1u) :
                                                                                         (USBFS_DMA_HALFWORDS_PER_BURST 
             -- 1u);
              
                                  /* Get number of data elements to transfer for descriptor 0 and 1. */
                                  lengthDescr0 = (1u == USBFS_DmaEpBurstCnt[epNumber]) ? USBFS_DmaEpLastBurstEl[epNumber
             -] : (USBFS_DMA_HALFWORDS_PER_BURST - 1u);
                                  lengthDescr1 = (2u == USBFS_DmaEpBurstCnt[epNumber]) ? USBFS_DmaEpLastBurstEl[epNumber
             -] : (USBFS_DMA_HALFWORDS_PER_BURST - 1u);
              
                                  /* Mark which descriptor is last one to execute. */
                                  USBFS_DmaEpLastBurstEl[epNumber] |= (0u != (USBFS_DmaEpBurstCnt[epNumber] & 0x1u)) ?
                                                                                          USBFS_DMA_DESCR0_MASK : USBFS_
             -DMA_DESCR1_MASK;
              
                                  /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger a
             -fter valid descriptor were executed. */
                                  USBFS_DmaEpBurstCnt[epNumber] = USBFS_DMA_GET_BURST_CNT(USBFS_DmaEpBurstCnt[epNumber])
             -;
              
                                  /* Restore DMA settings for current transfer. */
                                  USBFS_CyDmaChDisable(channelNum);
              
                                  /* Restore destination address for input endpoint. */
                                  USBFS_CyDmaSetSrcAddress(channelNum, USBFS_DMA_DESCR0, (void*) ((uint32) USBFS_DmaEpBu
             -fferAddrBackup[epNumber]));
                                  USBFS_CyDmaSetSrcAddress(channelNum, USBFS_DMA_DESCR1, (void*) ((uint32) USBFS_DmaEpBu
             -fferAddrBackup[epNumber] +
                                                                                                                        
             -         USBFS_DMA_BYTES_PER_BURST));
              
                                  /* Set number of elements to transfer. */
                                  USBFS_CyDmaSetNumDataElements(channelNum, USBFS_DMA_DESCR0, lengthDescr0);
                                  USBFS_CyDmaSetNumDataElements(channelNum, USBFS_DMA_DESCR1, lengthDescr1);
              
                                  /* Validate descriptor 0 and command to start with it. */
                                  USBFS_CyDmaValidateDescriptor(channelNum, USBFS_DMA_DESCR0);
                                  USBFS_CyDmaSetDescriptor0Next(channelNum);
              
                                  /* Enable DMA channel: configuration complete. */
                                  USBFS_CyDmaChEnable(channelNum);
              
                              #if !defined (USBFS_MANUAL_IN_EP_ARM)
                                  /* Set IN data ready to generate DMA request to load data into endpoint buffer. */
                                  USBFS_ARB_EP_BASE.arbEp[epNumber].epCfg |= USBFS_ARB_EPX_CFG_IN_DATA_RDY;
                              #endif  /* (USBFS_MANUAL_IN_EP_ARM) */
              
                                  /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer 
             -has been completed. */
                              }
                              else
                              {
                                  /* When zero-length packet: arm IN endpoint directly. */
                                  USBFS_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBFS_EP[epNumber].epMode;
                              }
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 35  

                          }
                      #endif /* (USBFS_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USBFS_EP_MANAGEMENT_MANUAL) */
                  }
              }
              
              
              /*******************************************************************************
              * Function Name: USBFS_ReadOutEP16
              ****************************************************************************//**
              *
              *   This function performs different functionality depending on the Component’s
              *   configured Endpoint Buffer Management. This parameter is defined in the
              *   Descriptor Root in Component Configure window.
              *
              *   *Manual (Static/Dynamic Allocation):*
              *   This function moves the specified number of bytes from endpoint buffer to
              *   system RAM. The number of bytes actually transferred from endpoint buffer to
              *   system RAM is the lesser of the actual number of bytes sent by the host or
              *   the number of bytes requested by the length parameter.
              *
              *   *DMA with Manual Buffer Management:*
              *   Configure DMA to transfer data from endpoint buffer to system RAM. Generate
              *   a DMA request. The firmware must wait until the DMA completes the data
              *   transfer after calling the USBFS_ReadOutEP() API. For example,
              *   by checking EPstate:
              *
              *   \snippet /USBFS_sut_02.cydsn/main.c checking EPstatey
              *
              *   The USBFS_EnableOutEP() has to be called to allow host to write data into
              *   the endpoint buffer after DMA has completed transfer data from OUT endpoint
              *   buffer to SRAM.
              *
              *   *DMA with Automatic Buffer Management:*
              *   Configure DMA. This is required only once and automatically generates DMA
              *   requests as data arrives
              *
              *  \param epNumber: Contains the data endpoint number.
              *         Valid values are between 1 and 8.
              *  \param pData: A pointer to a data array into which the data for the endpoint
              *         space is copied. It shall be ensured that this pointer address is
              *         even to ensure the 16-bit transfer is aligned to even address. Else,
              *         a hard fault condition can occur.
              *  \param length: The number of bytes to transfer from the USB Out endpoint and
              *         loads it into data array. Valid values are between 0 and 1023. The
              *         function moves fewer than the requested number of bytes if the host
              *         sends fewer bytes than requested.
              *
              * \return
              *  Number of bytes received, 0 for an invalid endpoint.
              *
              * \reentrant
              *  No.
              *
              *******************************************************************************/
              uint16 USBFS_ReadOutEP16(uint8 epNumber, uint8 pData[], uint16 length)
              {
                  uint32 adjLength;
              
                  /* Check array alignment on half-word boundary */
                  CYASSERT(0u == (((uint32) pData) & 0x01u));
              
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 36  

                  if ((pData != NULL) && (epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
                  {
                  #if (!USBFS_EP_MANAGEMENT_DMA_AUTO)
                      /* Adjust requested length to available data. */
                      length = (length > USBFS_GetEPCount(epNumber)) ? USBFS_GetEPCount(epNumber) : length;
                  #endif /* (!USBFS_EP_MANAGEMENT_DMA_AUTO) */
              
                  /* Adjust requested length: 2 bytes are handled at one data register access. */
                  adjLength =  length + ((uint32)length & 1u);
              
                  #if (USBFS_EP_MANAGEMENT_MANUAL)
                      {
                          /* Convert uint8 array to uint16. */
                          uint16 *dataBuf = (uint16 *) pData;
              
                          /* Copy data using 16-bits arbiter data register. */
                          uint16 i;
                          for (i = 0u; i < (adjLength >> 1u); ++i)
                          {
                              dataBuf[i] = (uint16) USBFS_ARB_EP16_BASE.arbEp[epNumber].rwDr16;
                          }
                      }
              
                      /* Arm OUT endpoint after data has been read from endpoint buffer. */
                      USBFS_EnableOutEP(epNumber);
                  #else
              
                      #if (USBFS_EP_MANAGEMENT_DMA_MANUAL)
                      {
                          uint32 channelNum = (uint32) USBFS_DmaChan[epNumber];
              
                          /* Disable DMA channel: start configuration. */
                          USBFS_CyDmaChDisable(channelNum);
              
                          /* Configure source and destination. */
                          USBFS_CyDmaSetSrcAddress(channelNum, USBFS_DMA_DESCR0, (void*) &USBFS_ARB_EP16_BASE.arbEp[epNu
             -mber].rwDr16);
                          USBFS_CyDmaSetDstAddress(channelNum, USBFS_DMA_DESCR0, (void*) pData);
              
                          /* Configure DMA descriptor. */
                          USBFS_CyDmaSetConfiguration(channelNum, USBFS_DMA_DESCR0, USBFS_DMA_COMMON_CFG | (uint16)((adj
             -Length >> 1u) - 1u) |
                                                                  CYDMA_HALFWORD | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_AD
             -DR | CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                          /* Validate descriptor to execute on following DMA request. */
                          USBFS_CyDmaValidateDescriptor(channelNum, USBFS_DMA_DESCR0);
              
                          /* Enable DMA channel: configuration complete. */
                          USBFS_CyDmaChEnable(channelNum);
              
                          /* Generate DMA request. */
                          USBFS_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint32)  USBFS_ARB_EPX_CFG_DMA_REQ;
                          USBFS_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint32) ~USBFS_ARB_EPX_CFG_DMA_REQ;
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
                      }
                      #endif /* (USBFS_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USBFS_EP_MANAGEMENT_DMA_AUTO)
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 37  

                      {
                          uint32 lengthDescr0, lengthDescr1;
                          uint32 channelNum = (uint32) USBFS_DmaChan[epNumber];
              
                          /* Get number of full bursts. */
                          USBFS_DmaEpBurstCnt[epNumber] = (uint8) (adjLength / USBFS_DMA_BYTES_PER_BURST);
              
                          /* Get number of elements in last burst. */
                          USBFS_DmaEpLastBurstEl[epNumber] = (uint8) (adjLength % USBFS_DMA_BYTES_PER_BURST);
              
                          /* Get total number of bursts. */
                          USBFS_DmaEpBurstCnt[epNumber] += (0u != USBFS_DmaEpLastBurstEl[epNumber]) ? 1u : 0u;
              
                          /* Adjust number of data elements transferred in last burst. */
                          USBFS_DmaEpLastBurstEl[epNumber] = (0u != USBFS_DmaEpLastBurstEl[epNumber]) ?
                                                                                ((USBFS_DmaEpLastBurstEl[epNumber] >> 1u
             -) - 1u) :
                                                                                 (USBFS_DMA_HALFWORDS_PER_BURST - 1u);
              
                          /* Get number of data elements to transfer for descriptor 0 and 1. */
                          lengthDescr0 = (1u == USBFS_DmaEpBurstCnt[epNumber]) ? USBFS_DmaEpLastBurstEl[epNumber] : (USB
             -FS_DMA_HALFWORDS_PER_BURST - 1u);
                          lengthDescr1 = (2u == USBFS_DmaEpBurstCnt[epNumber]) ? USBFS_DmaEpLastBurstEl[epNumber] : (USB
             -FS_DMA_HALFWORDS_PER_BURST - 1u);
              
                          /* Mark last descriptor to be executed. */
                          USBFS_DmaEpLastBurstEl[epNumber] |= (0u != (USBFS_DmaEpBurstCnt[epNumber] & 0x1u)) ?
                                                                                  USBFS_DMA_DESCR0_MASK : USBFS_DMA_DESC
             -R1_MASK;
              
                          /* Mark if revert number of data elements in descriptor after transfer completion. */
                          USBFS_DmaEpLastBurstEl[epNumber] |= (USBFS_DmaEpBurstCnt[epNumber] > 2u) ? USBFS_DMA_DESCR_REV
             -ERT : 0u;
              
                          /* Mark that 16-bits access to data register is performed. */
                          USBFS_DmaEpLastBurstEl[epNumber] |= USBFS_DMA_DESCR_16BITS;
              
                          /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger after val
             -id descriptor were executed. */
                          USBFS_DmaEpBurstCnt[epNumber] = USBFS_DMA_GET_BURST_CNT(USBFS_DmaEpBurstCnt[epNumber]);
              
                          /* Store address of buffer and burst counter for endpoint. */
                          USBFS_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
                          USBFS_DmaEpBurstCntBackup[epNumber]   = USBFS_DmaEpBurstCnt[epNumber];
              
                          /* Disable DMA channel: start configuration. */
                          USBFS_CyDmaChDisable(channelNum);
              
                          /* Set destination address. */
                          USBFS_CyDmaSetSrcAddress(channelNum, USBFS_DMA_DESCR0, (void*) &USBFS_ARB_EP16_BASE.arbEp[epNu
             -mber].rwDr16);
                          USBFS_CyDmaSetSrcAddress(channelNum, USBFS_DMA_DESCR1, (void*) &USBFS_ARB_EP16_BASE.arbEp[epNu
             -mber].rwDr16);
              
                          USBFS_CyDmaSetDstAddress(channelNum, USBFS_DMA_DESCR0, (void*) ((uint32) pData));
                          USBFS_CyDmaSetDstAddress(channelNum, USBFS_DMA_DESCR1, (void*) ((uint32) pData + USBFS_DMA_BYT
             -ES_PER_BURST));
              
                          /* Configure DMA descriptor 0. */
                          USBFS_CyDmaSetConfiguration(channelNum, USBFS_DMA_DESCR0, USBFS_DMA_COMMON_CFG  | lengthDescr0
             - |
                                                                  CYDMA_HALFWORD | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_AD
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 38  

             -DR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                          /* Configure DMA descriptor 1. */
                          USBFS_CyDmaSetConfiguration(channelNum, USBFS_DMA_DESCR1, USBFS_DMA_COMMON_CFG  | lengthDescr1
             - |
                                                                  CYDMA_HALFWORD | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_AD
             -DR | CYDMA_CHAIN);
              
                          /* Enable interrupt from DMA channel. */
                          USBFS_CyDmaSetInterruptMask(channelNum);
              
                          /* Validate DMA descriptor 0 and 1. */
                          USBFS_CyDmaValidateDescriptor(channelNum, USBFS_DMA_DESCR0);
                          USBFS_CyDmaValidateDescriptor(channelNum, USBFS_DMA_DESCR1);
              
                          /* Enable DMA channel: configuration complete. */
                          USBFS_CyDmaChEnable(channelNum);
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
                      }
                      #endif /* (USBFS_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USBFS_EP_MANAGEMENT_MANUAL) */
                  }
                  else
                  {
                      length = 0u;
                  }
              
                  return (length);
              }
              #endif /* (USBFS_16BITS_EP_ACCESS_ENABLE) */
2227          
2228          
2229          /*******************************************************************************
2230          * Function Name: USBFS_EnableOutEP
2231          ****************************************************************************//**
2232          *
2233          *  This function enables the specified endpoint for OUT transfers. Do not call
2234          *  this function for IN endpoints.
2235          *
2236          *  \param epNumber: Contains the data endpoint number. Valid values are between
2237          *  1 and 8.
2238          *
2239          * \globalvars
2240          *
2241          *  \ref USBFS_EP[epNumber].apiEpState - set to NO_EVENT_PENDING
2242          *
2243          * \reentrant
2244          *  No.
2245          *
2246          *******************************************************************************/
2247          void USBFS_EnableOutEP(uint8 epNumber) 
2248          {
2249   1          if ((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
2250   1          {
2251   2              USBFS_EP[epNumber].apiEpState = USBFS_NO_EVENT_PENDING;
2252   2      
2253   2              /* Enable OUT endpoint to be written by Host. */
2254   2              USBFS_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBFS_EP[epNumber].epMode;
2255   2              
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 39  

2256   2          }
2257   1      }
2258          
2259          
2260          /*******************************************************************************
2261          * Function Name: USBFS_DisableOutEP
2262          ****************************************************************************//**
2263          *
2264          *  This function disables the specified USBFS OUT endpoint. Do not call this
2265          *  function for IN endpoints.
2266          *
2267          *  \param epNumber: Contains the data endpoint number.
2268          *            Valid values are between 1 and 8.
2269          *
2270          *******************************************************************************/
2271          void USBFS_DisableOutEP(uint8 epNumber) 
2272          {
2273   1          if ((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
2274   1          {
2275   2              /* Set NAK response for OUT endpoint. */
2276   2              USBFS_SIE_EP_BASE.sieEp[epNumber].epCr0 = USBFS_MODE_NAK_OUT;
2277   2          }
2278   1      }
2279          
2280          
2281          /*******************************************************************************
2282          * Function Name: USBFS_Force
2283          ****************************************************************************//**
2284          *
2285          *  This function forces a USB J, K, or SE0 state on the D+/D– lines. It provides
2286          *  the necessary mechanism for a USB device application to perform a USB Remote
2287          *  Wakeup. For more information, see the USB 2.0 Specification for details on
2288          *  Suspend and Resume.
2289          *
2290          *  \param state A byte indicating which of the four bus states to enable.
2291          *        Symbolic names  and their associated values are listed here:
2292          *    State                      |Description
2293          *    ---------------------------|----------------------------------------------
2294          *    USBFS_FORCE_J   | Force a J State onto the D+/D– lines
2295          *    USBFS_FORCE_K   | Force a K State onto the D+/D– lines
2296          *    USBFS_FORCE_SE0 | Force a Single Ended 0 onto the D+/D– lines
2297          *    USBFS_FORCE_NONE| Return bus to SIE control
2298          *
2299          *
2300          *******************************************************************************/
2301          void USBFS_Force(uint8 bState) 
2302          {
2303   1          /* This registers is used only for manual control of SIE (no masking is
2304   1          * needed before write into it).
2305   1          */
2306   1          USBFS_USBIO_CR0_REG = bState;
2307   1      }
2308          
2309          
2310          /*******************************************************************************
2311          * Function Name: USBFS_GetEPAckState
2312          ****************************************************************************//**
2313          *
2314          *  This function determines whether an ACK transaction occurred on this endpoint
2315          *  by reading the ACK bit in the control register of the endpoint. It does not
2316          *  clear the ACK bit.
2317          *
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 40  

2318          *  \param epNumber Contains the data endpoint number.
2319          *            Valid values are between 1 and 8.
2320          *
2321          *  \return
2322          *  If an ACKed transaction occurred, this function returns a non-zero value.
2323          *  Otherwise, it returns zero.
2324          *
2325          *******************************************************************************/
2326          uint8 USBFS_GetEPAckState(uint8 epNumber) 
2327          {
2328   1          uint8 cr = 0u;
2329   1      
2330   1          if ((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
2331   1          {
2332   2              cr = USBFS_SIE_EP_BASE.sieEp[epNumber].epCr0 & USBFS_MODE_ACKD;
2333   2          }
2334   1      
2335   1          return ((uint8) cr);
2336   1      }
2337          
2338          
2339          /*******************************************************************************
2340          * Function Name: USBFS_SetPowerStatus
2341          ****************************************************************************//**
2342          *
2343          *  This function sets the current power status. The device replies to USB
2344          *  GET_STATUS requests based on this value. This allows the device to properly
2345          *  report its status for USB Chapter 9 compliance. Devices can change their
2346          *  power source from self powered to bus powered at any time and report their
2347          *  current power source as part of the device status. You should call this
2348          *  function any time your device changes from self powered to bus powered or
2349          *  vice versa, and set the status appropriately.
2350          *
2351          *  \param powerStatus: Contains the desired power status, one for self powered
2352          *        or zero for bus powered. Symbolic names and their associated values are
2353          *        given here:
2354          *  Power Status                                |Description
2355          *  --------------------------------------------|---------------------------
2356          *  USBFS_DEVICE_STATUS_BUS_POWERED  | Set the device to bus powered
2357          *  USBFS_DEVICE_STATUS_SELF_POWERED | Set the device to self powered
2358          *
2359          * \globalvars
2360          *
2361          *  \ref USBFS_deviceStatus - set power status
2362          *
2363          * \reentrant
2364          *  No.
2365          *
2366          *******************************************************************************/
2367          void USBFS_SetPowerStatus(uint8 powerStatus) 
2368          {
2369   1          if (powerStatus != USBFS_DEVICE_STATUS_BUS_POWERED)
2370   1          {
2371   2              USBFS_deviceStatus |= (uint8)  USBFS_DEVICE_STATUS_SELF_POWERED;
2372   2          }
2373   1          else
2374   1          {
2375   2              USBFS_deviceStatus &= (uint8) ~USBFS_DEVICE_STATUS_SELF_POWERED;
2376   2          }
2377   1      }
2378          
2379          
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 41  

2380          #if (USBFS_VBUS_MONITORING_ENABLE)
                  /***************************************************************************
                  * Function Name: USBFS_VBusPresent
                  ************************************************************************//**
                  *
                  *  Determines VBUS presence for self-powered devices. This function is
                  *  available when the VBUS Monitoring option is enabled in the Advanced tab.
                  *
                  * \return
                  *  The return value can be the following:
                  *  Return Value | Description
                  *  -------------|-----------------
                  *  1            | VBUS is present
                  *  0            | VBUS is absent
                  *
                  *
                  ***************************************************************************/
                  uint8 USBFS_VBusPresent(void) 
                  {
                      return ((0u != (USBFS_VBUS_STATUS_REG & USBFS_VBUS_VALID)) ? (uint8) 1u : (uint8) 0u);
                  }
              #endif /* (USBFS_VBUS_MONITORING_ENABLE) */
2402          
2403          
2404          /*******************************************************************************
2405          * Function Name: USBFS_RWUEnabled
2406          ****************************************************************************//**
2407          *
2408          *  This function returns the current remote wakeup status.
2409          *  If the device supports remote wakeup, the application should use this
2410          *  function to determine if remote wakeup was enabled by the host. When the
2411          *  device is suspended and it determines the conditions to initiate a remote
2412          *  wakeup are met, the application should use the USBFS_Force() function to
2413          *  force the appropriate J and K states onto the USB bus, signaling a remote
2414          *  wakeup.
2415          *
2416          *
2417          * \return
2418          *  Returns non-zero value if remote wakeup is enabled and zero otherwise.
2419          *
2420          * \globalvars
2421          *  USBFS_deviceStatus - checked to determine remote status
2422          *
2423          *******************************************************************************/
2424          uint8 USBFS_RWUEnabled(void) 
2425          {
2426   1          uint8 result = USBFS_FALSE;
2427   1      
2428   1          if (0u != (USBFS_deviceStatus & USBFS_DEVICE_STATUS_REMOTE_WAKEUP))
2429   1          {
2430   2              result = USBFS_TRUE;
2431   2          }
2432   1      
2433   1          return (result);
2434   1      }
2435          
2436          
2437          /*******************************************************************************
2438          * Function Name: USBFS_GetDeviceAddress
2439          ****************************************************************************//**
2440          *
2441          *  This function returns the currently assigned address for the USB device.
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 42  

2442          *
2443          * \return
2444          *  Returns the currently assigned address.
2445          *  Returns 0 if the device has not yet been assigned an address.
2446          *
2447          *******************************************************************************/
2448          uint8 USBFS_GetDeviceAddress(void) 
2449          {
2450   1          return (uint8)(USBFS_CR0_REG & USBFS_CR0_DEVICE_ADDRESS_MASK);
2451   1      }
2452          
2453          
2454          /*******************************************************************************
2455          * Function Name: USBFS_EnableSofInt
2456          ****************************************************************************//**
2457          *
2458          *  This function enables interrupt generation when a Start-of-Frame (SOF)
2459          *  packet is received from the host.
2460          *
2461          *******************************************************************************/
2462          void USBFS_EnableSofInt(void) 
2463          {
2464   1      #if (CY_PSOC4)
                  /* Enable SOF interrupt interrupt source. */
                  USBFS_INTR_SIE_MASK_REG |= (uint32) USBFS_INTR_SIE_SOF_INTR;
              #else
2468   1          /* Enable SOF interrupt if it is present. */
2469   1          #if (USBFS_SOF_ISR_ACTIVE)
2470   1              CyIntEnable(USBFS_SOF_VECT_NUM);
2471   1          #endif /* (USBFS_SOF_ISR_ACTIVE) */
2472   1      #endif /* (CY_PSOC4) */
2473   1      }
2474          
2475          
2476          /*******************************************************************************
2477          * Function Name: USBFS_DisableSofInt
2478          ****************************************************************************//**
2479          *
2480          *  This function disables interrupt generation when a Start-of-Frame (SOF)
2481          *  packet is received from the host.
2482          *
2483          *******************************************************************************/
2484          void USBFS_DisableSofInt(void) 
2485          {
2486   1      #if (CY_PSOC4)
                  /* Disable SOF interrupt interrupt source. */
                  USBFS_INTR_SIE_MASK_REG &= (uint32) ~USBFS_INTR_SIE_SOF_INTR;
              #else
2490   1          /* Disable SOF interrupt if it is present. */
2491   1          #if (USBFS_SOF_ISR_ACTIVE)
2492   1              CyIntDisable(USBFS_SOF_VECT_NUM);
2493   1          #endif /* (USBFS_SOF_ISR_ACTIVE) */
2494   1      #endif /* (CY_PSOC4) */
2495   1      }
2496          
2497          
2498          #if (USBFS_BATT_CHARG_DET_ENABLE)
                  /***************************************************************************
                  * Function Name: USBFS_DetectPortType
                  ************************************************************************//**
                  *
                  *   This function implements the USB  Battery Charger Detection (BCD)
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 43  

                  *   algorithm to determine the type of USB host downstream port. This API
                  *   is available only for PSoC 4 devices, and should be called when the VBUS
                  *   voltage transition (OFF to ON) is detected on the bus. If the USB device
                  *   functionality is enabled, this API first calls USBFS_Stop() API
                  *   internally to disable the USB device functionality, and then proceeds to
                  *   implement the BCD algorithm to detect the USB host port type.
                  *   The USBFS_Start() API should be called after this API if the USB
                  *   communication needs to be initiated with the host.
                  *   *Note* This API is generated only if the “Enable Battery Charging 
                  *   Detection” option is enabled in the “Advanced” tab of the component GUI.
                  *   *Note* API implements the steps 2-4 of the BCD algorithm which are 
                  *   - Data Contact Detect
                  *   - Primary Detection 
                  *   - Secondary Detection 
                  * 
                  *   The first step of BCD algorithm, namely, VBUS detection shall be handled 
                  *   at the application firmware level.
                  *
                  * \return
                  *   The return value can be the following:
                  *   Return Value                      |Description
                  *   ----------------------------------|-------------------------------------
                  *   USBFS_BCD_PORT_SDP     | Standard downstream port detected
                  *   USBFS_BCD_PORT_CDP     | Charging downstream port detected
                  *   USBFS_BCD_PORT_DCP     | Dedicated charging port detected
                  *   USBFS_BCD_PORT_UNKNOWN | Unable to detect charging port type (proprietary charger type)
                  *   USBFS_BCD_PORT_ERR     | Error condition in detection process
                  *
                  *
                  * \sideeffects
                  *
                  *  USB device functionality is disabled by this API if not already disabled.
                  *
                  ***************************************************************************/
                  uint8 USBFS_Bcd_DetectPortType(void)
                  {
                      uint32 bkPwrCtrl;
                      uint32 cr1RegVal;
                      uint32 secondaryDetection = 0u;
                      uint8 result = USBFS_BCD_PORT_UNKNOWN;
              
                      /*Check USB Started and Stop it*/
                      if(0u != USBFS_initVar)
                      {
                          USBFS_Stop();
                      }
                      /*Initialize USBFS IP for Charger detection*/
              
                      /*Enable clock to USB IP. */
                      USBFS_USB_CLK_EN_REG = USBFS_USB_CLK_CSR_CLK_EN;
              
                      /* Enable USBIO control on drive mode of D+ and D- pins. */
                      USBFS_USBIO_CR1_REG &= ~ (uint32) USBFS_USBIO_CR1_IOMODE;
              
                      /* Select VBUS detection source and clear PHY isolate. The application
                      *  level must ensure that VBUS is valid. There is no need to wait 2us
                      *  before VBUS is valid.
                      */
                      bkPwrCtrl = USBFS_POWER_CTRL_REG;
                      USBFS_POWER_CTRL_REG = USBFS_DEFAULT_POWER_CTRL_VBUS\
                                          & (~USBFS_POWER_CTRL_ENABLE_VBUS_PULLDOWN)\
                                          & (~USBFS_POWER_CTRL_ENABLE_DM_PULLDOWN);
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 44  

              
              
                      /* Enable PHY detector and single-ended and differential receivers.
                       * Enable charger detection.  */
                      USBFS_POWER_CTRL_REG |= USBFS_DEFAULT_POWER_CTRL_PHY\
                                                       | USBFS_POWER_CTRL_ENABLE_CHGDET;
              
                      /* Suspend clear sequence. */
                      USBFS_POWER_CTRL_REG &= (uint32) ~USBFS_POWER_CTRL_SUSPEND;
                      CyDelayUs(USBFS_WAIT_SUSPEND_DEL_DISABLE);
                      USBFS_POWER_CTRL_REG &= (uint32) ~USBFS_POWER_CTRL_SUSPEND_DEL;
              
                      /* Data connection detection
                      * Realization with delay as Hard IP does not support DCD 300 ms.
                      */
                      #if defined (USBFS_NO_DCD)
                      CyDelay(USBFS_BCD_TIMEOUT);
                      #else
                      /* DCD implementation:*/
              
                      {
                          uint16 timeout = USBFS_BCD_TIMEOUT;
                          uint8 connectionApproved = 0u;
                          uint8 connected = 0u;
              
                          /*   BCD spec 1.2: Turns on Idp_src and D- pull-down resistor */
                          USBFS_POWER_CTRL_REG |= USBFS_POWER_CTRL_ENABLE_DM_PULLDOWN;
                          USBFS_CHGDET_CTRL_REG |= USBFS_CHGDET_CTRL_DCD_SRC_EN;
              
                          /* BCD spec 1.2: Waits for D+ to be low for a time of Tdcd_dbnc*/
                          while ((0u != timeout) && (0u == connectionApproved))
                          {
                              if (0u == (USBFS_USBIO_CR1_REG & USBFS_USBIO_CR1_DP0))
                              {
                                  connected++;
                              }
                              else
                              {
                                  connected = 0u;
                              }
                              connectionApproved = (USBFS_BCD_TDCD_DBNC < connected) ? 1u:0u;
                              CyDelay(1u);
                              timeout--;
                          }
              
                          /*   BCD spec 1.2: Turns off Idp_src. */
                          USBFS_CHGDET_CTRL_REG &= ~USBFS_CHGDET_CTRL_DCD_SRC_EN;
                      }
                      #endif /*(USBFS_NO_DCD)*/
              
                      /* Primary detection: enable VDP_SRC on D+ and IDM_SINK on D-. */
                      USBFS_CHGDET_CTRL_REG = USBFS_CHGDET_CTRL_PRIMARY;
                      CyDelay(USBFS_BCD_PRIMARY_WAIT);
                      cr1RegVal = USBFS_USBIO_CR1_REG;
              
                      /* Check is it SDP or DCP/CDP, read comparator 2 output. */
                      if (0u == (USBFS_CHGDET_CTRL_REG & USBFS_CHGDET_CTRL_COMP_OUT))
                      {
                          /* Check status of D- line. */
                          if (0u == (cr1RegVal & USBFS_USBIO_CR1_DM0))
                          {
                              result = USBFS_BCD_PORT_SDP;
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 45  

                          }
                          else
                          {
                              /* ERROR: such combination is impossible. Abort charger
                               * detection.
                              */
                              result = USBFS_BCD_PORT_ERR;
                          }
                      }
                      else
                      {
                              /* Need Secondary detection. Charging port: DCP or proprietary*/
                              secondaryDetection = 1u;
                      }
              
                      /* Secondary detection: Set CHGDET_CTRL register to enable VDM_SRC on D- and IDP_SINK on D+. */
              
                      if (0u != secondaryDetection)
                      {
                          USBFS_CHGDET_CTRL_REG = USBFS_CHGDET_CTRL_DEFAULT \
                                                              | USBFS_CHGDET_CTRL_SECONDARY;
                          CyDelay(USBFS_BCD_SECONDARY_WAIT);
                          cr1RegVal = USBFS_USBIO_CR1_REG;
              
                          /* Check is it SDP or DCP/CDP, read comparator 1 output. */
                          if (0u == (USBFS_CHGDET_CTRL_REG & USBFS_CHGDET_CTRL_COMP_OUT))
                          {
                              /* Check status of D+ line. */
                              if (0u == (cr1RegVal & USBFS_USBIO_CR1_DP0))
                              {
                                  result = USBFS_BCD_PORT_CDP;
                              }
                              else
                              {
                                  /* ERROR: such combination is impossible. Abort charger
                                   * detection.
                                  */
                                  result = USBFS_BCD_PORT_ERR;
                              }
                          }
                          else
                          {
                              /* Check status of D+ line. */
                              if (0u == (cr1RegVal & USBFS_USBIO_CR1_DP0))
                              {
                                  result = USBFS_BCD_PORT_DCP;
                              }
                              else
                              {
                                  /* It is may be proprietary charger. Proprietary charge is
                                   * not supported byHardware IP block.
                                  */
                                  result = USBFS_BCD_PORT_UNKNOWN;
                              }
                          }
                      }
              
                      /* Restore CHGDET_CTRL. */
                      USBFS_CHGDET_CTRL_REG = 0u;
              
                      /*Revert registers back*/
                      USBFS_POWER_CTRL_REG = bkPwrCtrl;
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 46  

                      USBFS_USBIO_CR1_REG |= (uint32) USBFS_USBIO_CR1_IOMODE;
                      USBFS_USB_CLK_EN_REG = ~USBFS_USB_CLK_CSR_CLK_EN;
              
                      return (result);
                  }
              #endif  /* (USBFS_BATT_CHARG_DET_ENABLE) */
2696          
2697          
2698          #if (USBFS_LPM_ACTIVE)
                  /***************************************************************************
                  * Function Name: USBFS_Lpm_GetBeslValue
                  ************************************************************************//**
                  *
                  *  This function returns the Best Effort Service Latency (BESL) value
                  *  sent by the host as part of the LPM token transaction.
                  *
                  * \return
                  *  4-bit BESL value received in the LPM token packet from the host
                  *
                  *
                  ***************************************************************************/
                  uint32 USBFS_Lpm_GetBeslValue(void)
                  {
                      return (uint32) (USBFS_LPM_STAT_REG & USBFS_LPM_STAT_LPM_BESL_MASK);
                  }
              
              
                  /***************************************************************************
                  * Function Name: USBFS_Lpm_RemoteWakeUpAllowed
                  ************************************************************************//**
                  *
                  *  This function returns the remote wakeup permission set for the device by
                  *  the host as part of the LPM token transaction.
                  *
                  * \return
                  *   0 - remote wakeup not allowed, 1 - remote wakeup allowed
                  *
                  *
                  ***************************************************************************/
                  uint32 USBFS_Lpm_RemoteWakeUpAllowed(void)
                  {
                      return (uint32) (USBFS_LPM_STAT_REG & USBFS_LPM_STAT_LPM_REMOTE_WAKE);
                  }
              
              
                  /***************************************************************************
                  * Function Name: USBFS_Lpm_SetResponse
                  ************************************************************************//**
                  *
                  *  This function configures the response in the handshake packet the device
                  *  has to send when an LPM token packet is received.
                  *
                  * \param response
                  *   type of response to return for an LPM token packet
                  *   Allowed response values:
                  *       - USBFS_LPM_REQ_ACK - next LPM request will be
                  *                                           responded with ACK
                  *       - USBFS_LPM_REQ_NACK - next LPM request will be
                  *                                           responded with NACK
                  *       - USBFS_LPM_REQ_NYET - next LPM request will be
                  *                                           responded with NYET
                  *
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 47  

                  ***************************************************************************/
                  void USBFS_Lpm_SetResponse(uint32 response)
                  {
                      uint32 lpmCtrl = USBFS_LPM_CTRL_REG & (uint32) ~USBFS_LPM_CTRL_ACK_NYET_MASK;
              
                      USBFS_LPM_CTRL_REG = lpmCtrl | ((uint32) response & USBFS_LPM_CTRL_ACK_NYET_MASK);
                  }
              
              
                  /***************************************************************************
                  * Function Name: USBFS_Lpm_GetResponse
                  ************************************************************************//**
                  *
                  *  This function returns the currently configured response value that the
                  *  device will send as part of the handshake packet when an LPM token
                  *  packet is received.
                  *
                  * \return
                  *   type of handshake response that will be returned by the device
                  *   for an LPM token packet
                  *   Possible response values:
                  *       - USBFS_LPM_REQ_ACK - next LPM request will be responded
                  *                                        with ACK
                  *       - USBFS_LPM_REQ_NACK - next LPM request will be responded
                  *                                        with NACK
                  *       - USBFS_LPM_REQ_NYET - next LPM request will be responded
                  *                                        with NYET
                  *
                  ***************************************************************************/
                  uint32 USBFS_Lpm_GetResponse(void)
                  {
              
                      return  ((uint32) USBFS_LPM_CTRL_REG & (uint32)USBFS_LPM_CTRL_ACK_NYET_MASK);
                  }
              
              
              #endif /* (USBFS_LPM_ACTIVE) */
2789          
2790          
2791          /* [] END OF FILE */
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 48  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _USBFS_Start (BEGIN)
                                           ; SOURCE LINE # 185
0000 900000      R     MOV     DPTR,#device
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 186
                                           ; SOURCE LINE # 187
0008 900000      R     MOV     DPTR,#USBFS_initVar
000B E0                MOVX    A,@DPTR
000C 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 189
000E 120000      R     LCALL   USBFS_Init
                                           ; SOURCE LINE # 190
0011 900000      R     MOV     DPTR,#USBFS_initVar
0014 7401              MOV     A,#01H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 191
0017         ?C0001:
                                           ; SOURCE LINE # 193
0017 900000      R     MOV     DPTR,#device
001A E0                MOVX    A,@DPTR
001B FF                MOV     R7,A
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E FD                MOV     R5,A
001F 120000      R     LCALL   _USBFS_InitComponent
                                           ; SOURCE LINE # 194
0022 22                RET     
             ; FUNCTION _USBFS_Start (END)

             ; FUNCTION USBFS_Init (BEGIN)
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 211
                                           ; SOURCE LINE # 249
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 256
0008 9043A5            MOV     DPTR,#043A5H
000B E0                MOVX    A,@DPTR
000C 4401              ORL     A,#01H
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 258
000F 9043B5            MOV     DPTR,#043B5H
0012 E0                MOVX    A,@DPTR
0013 4401              ORL     A,#01H
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 261
0016 90609D            MOV     DPTR,#0609DH
0019 7401              MOV     A,#01H
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 263
001C 906009            MOV     DPTR,#06009H
001F 04                INC     A
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 49  

0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 267
0021 906010            MOV     DPTR,#06010H
0024 E0                MOVX    A,@DPTR
0025 547F              ANL     A,#07FH
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 268
0028 E4                CLR     A
0029 FF                MOV     R7,A
002A FE                MOV     R6,A
002B 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 273
002E 904394            MOV     DPTR,#04394H
0031 E0                MOVX    A,@DPTR
0032 54F9              ANL     A,#0F9H
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 277
0035 906012            MOV     DPTR,#06012H
0038 E0                MOVX    A,@DPTR
0039 54DF              ANL     A,#0DFH
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 280
003C 904394            MOV     DPTR,#04394H
003F E0                MOVX    A,@DPTR
0040 4401              ORL     A,#01H
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 282
0043 7F01              MOV     R7,#01H
0045 7E00              MOV     R6,#00H
0047 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 284
004A 7F28              MOV     R7,#028H
004C 7E00              MOV     R6,#00H
004E 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 286
0051 9051F8            MOV     DPTR,#051F8H
0054 E0                MOVX    A,@DPTR
0055 547F              ANL     A,#07FH
0057 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 287
0058 E0                MOVX    A,@DPTR
0059 54BF              ANL     A,#0BFH
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 290
005C 904394            MOV     DPTR,#04394H
005F E0                MOVX    A,@DPTR
0060 4402              ORL     A,#02H
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 291
0063 7F02              MOV     R7,#02H
0065 7E00              MOV     R6,#00H
0067 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 293
006A 904394            MOV     DPTR,#04394H
006D E0                MOVX    A,@DPTR
006E 4404              ORL     A,#04H
0070 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 296
0071 906084            MOV     DPTR,#06084H
0074 E4                CLR     A
0075 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 297
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 50  

0076 A3                INC     DPTR
0077 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 311
0078 900000      R     MOV     DPTR,#enableInterrupts
007B E0                MOVX    A,@DPTR
007C FF                MOV     R7,A
007D 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 330
0080 7D07              MOV     R5,#07H
0082 7F17              MOV     R7,#017H
0084 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 331
0087 7C00        E     MOV     R4,#HIGH USBFS_BUS_RESET_ISR
0089 7D00        E     MOV     R5,#LOW USBFS_BUS_RESET_ISR
008B 7F17              MOV     R7,#017H
008D 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 334
0090 7D07              MOV     R5,#07H
0092 7F18              MOV     R7,#018H
0094 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 335
0097 7C00        E     MOV     R4,#HIGH USBFS_EP_0_ISR
0099 7D00        E     MOV     R5,#LOW USBFS_EP_0_ISR
009B 7F18              MOV     R7,#018H
009D 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 339
00A0 7D07              MOV     R5,#07H
00A2 7F15              MOV     R7,#015H
00A4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 340
00A7 7C00        E     MOV     R4,#HIGH USBFS_SOF_ISR
00A9 7D00        E     MOV     R5,#LOW USBFS_SOF_ISR
00AB 7F15              MOV     R7,#015H
00AD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 345
00B0 7D07              MOV     R5,#07H
00B2 E4                CLR     A
00B3 FF                MOV     R7,A
00B4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 346
00B7 7C00        E     MOV     R4,#HIGH USBFS_EP_1_ISR
00B9 7D00        E     MOV     R5,#LOW USBFS_EP_1_ISR
00BB E4                CLR     A
00BC FF                MOV     R7,A
00BD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 351
00C0 7D07              MOV     R5,#07H
00C2 7F01              MOV     R7,#01H
00C4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 352
00C7 7C00        E     MOV     R4,#HIGH USBFS_EP_2_ISR
00C9 7D00        E     MOV     R5,#LOW USBFS_EP_2_ISR
00CB 7F01              MOV     R7,#01H
00CD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 400
00D0 7D07              MOV     R5,#07H
00D2 7F0C              MOV     R7,#0CH
00D4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 401
00D7 7C00        E     MOV     R4,#HIGH USBFS_DP_ISR
00D9 7D00        E     MOV     R5,#LOW USBFS_DP_ISR
00DB 7F0C              MOV     R7,#0CH
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 51  

00DD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 408
00E0 22                RET     
             ; FUNCTION USBFS_Init (END)

             ; FUNCTION _USBFS_InitComponent (BEGIN)
                                           ; SOURCE LINE # 459
;---- Variable 'mode' assigned to Register 'R5' ----
;---- Variable 'device' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 460
                                           ; SOURCE LINE # 468
;---- Variable 'i' assigned to Register 'R6' ----
0000 E4                CLR     A
0001 FE                MOV     R6,A
0002         ?C0004:
                                           ; SOURCE LINE # 469
                                           ; SOURCE LINE # 470
0002 7E01              MOV     R6,#01H
0004 900000      E     MOV     DPTR,#USBFS_hidProtocol
0007 7401              MOV     A,#01H
0009         ?C0057:
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B DEFC              DJNZ    R6,?C0057
                                           ; SOURCE LINE # 471
000D 7E01              MOV     R6,#01H
000F         ?C0005:
                                           ; SOURCE LINE # 475
000F 900000      E     MOV     DPTR,#USBFS_device
0012 EF                MOV     A,R7
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 478
0014 E4                CLR     A
0015 900000      E     MOV     DPTR,#USBFS_transferState
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 479
0019 900000      E     MOV     DPTR,#USBFS_configurationChanged
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 480
001D 900000      E     MOV     DPTR,#USBFS_configuration
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 481
0021 900000      E     MOV     DPTR,#USBFS_interfaceNumber
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 482
0025 900000      E     MOV     DPTR,#USBFS_deviceAddress
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 483
0029 900000      E     MOV     DPTR,#USBFS_deviceStatus
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 484
002D 900000      E     MOV     DPTR,#USBFS_lastPacketSize
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 492
0031 9044C2            MOV     DPTR,#044C2H
0034 7480              MOV     A,#080H
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 493
0037 A3                INC     DPTR
0038 7401              MOV     A,#01H
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 496
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 52  

003B 9044C2            MOV     DPTR,#044C2H
003E 7420              MOV     A,#020H
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 500
0041 9044C0            MOV     DPTR,#044C0H
0044 7401              MOV     A,#01H
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 504
0047 04                INC     A
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 572
0049 ED                MOV     A,R5
004A 14                DEC     A
004B 600C              JZ      ?C0009
004D 04                INC     A
004E 7012              JNZ     ?C0010
                                           ; SOURCE LINE # 573
                                           ; SOURCE LINE # 574
0050         ?C0008:
                                           ; SOURCE LINE # 576
0050 906009            MOV     DPTR,#06009H
0053 E0                MOVX    A,@DPTR
0054 54FE              ANL     A,#0FEH
0056 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 577
0057 8010              SJMP    ?C0007
                                           ; SOURCE LINE # 579
0059         ?C0009:
                                           ; SOURCE LINE # 581
0059 906009            MOV     DPTR,#06009H
005C E0                MOVX    A,@DPTR
005D 4401              ORL     A,#01H
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 582
0060 8007              SJMP    ?C0007
                                           ; SOURCE LINE # 584
0062         ?C0010:
                                           ; SOURCE LINE # 590
0062 906009            MOV     DPTR,#06009H
0065 E0                MOVX    A,@DPTR
0066 4401              ORL     A,#01H
0068 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 592
                                           ; SOURCE LINE # 593
0069         ?C0007:
                                           ; SOURCE LINE # 626
0069 906028            MOV     DPTR,#06028H
006C 7403              MOV     A,#03H
006E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 629
006F 906008            MOV     DPTR,#06008H
0072 7480              MOV     A,#080H
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 630
0075 E4                CLR     A
0076 7F01              MOV     R7,#01H
0078 FE                MOV     R6,A
0079 FD                MOV     R5,A
007A FC                MOV     R4,A
007B 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 634
007E 906012            MOV     DPTR,#06012H
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 53  

0081 7404              MOV     A,#04H
0083 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 635
0084 22                RET     
             ; FUNCTION _USBFS_InitComponent (END)

             ; FUNCTION USBFS_ReInitComponent (BEGIN)
                                           ; SOURCE LINE # 670
                                           ; SOURCE LINE # 671
                                           ; SOURCE LINE # 678
;---- Variable 'i' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
0002         ?C0012:
                                           ; SOURCE LINE # 679
                                           ; SOURCE LINE # 680
0002 7F01              MOV     R7,#01H
0004 900000      E     MOV     DPTR,#USBFS_hidProtocol
0007 7401              MOV     A,#01H
0009         ?C0058:
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B DFFC              DJNZ    R7,?C0058
                                           ; SOURCE LINE # 681
000D         ?C0013:
                                           ; SOURCE LINE # 685
000D E4                CLR     A
000E 900000      E     MOV     DPTR,#USBFS_transferState
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 686
0012 900000      E     MOV     DPTR,#USBFS_configurationChanged
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 687
0016 900000      E     MOV     DPTR,#USBFS_configuration
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 688
001A 900000      E     MOV     DPTR,#USBFS_interfaceNumber
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 689
001E 900000      E     MOV     DPTR,#USBFS_deviceAddress
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 690
0022 900000      E     MOV     DPTR,#USBFS_deviceStatus
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 691
0026 900000      E     MOV     DPTR,#USBFS_lastPacketSize
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 698
002A 906028            MOV     DPTR,#06028H
002D 7403              MOV     A,#03H
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 702
0030 906008            MOV     DPTR,#06008H
0033 7480              MOV     A,#080H
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 703
0036 22                RET     
             ; FUNCTION USBFS_ReInitComponent (END)

             ; FUNCTION USBFS_Stop (BEGIN)
                                           ; SOURCE LINE # 728
                                           ; SOURCE LINE # 729
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 54  

                                           ; SOURCE LINE # 737
0000 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'enableInterrupts' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 740
0003 906008            MOV     DPTR,#06008H
0006 E0                MOVX    A,@DPTR
0007 547F              ANL     A,#07FH
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 743
000A 906012            MOV     DPTR,#06012H
000D E0                MOVX    A,@DPTR
000E 54FB              ANL     A,#0FBH
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 750
0011 9043A5            MOV     DPTR,#043A5H
0014 E0                MOVX    A,@DPTR
0015 54FE              ANL     A,#0FEH
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 751
0018 9043B5            MOV     DPTR,#043B5H
001B E0                MOVX    A,@DPTR
001C 54FE              ANL     A,#0FEH
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 754
001F 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 763
0022 9044CA            MOV     DPTR,#044CAH
0025 7480              MOV     A,#080H
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 764
0028 A3                INC     DPTR
0029 7401              MOV     A,#01H
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 767
002C 9044CA            MOV     DPTR,#044CAH
002F 7420              MOV     A,#020H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 771
0032 9044C8            MOV     DPTR,#044C8H
0035 7401              MOV     A,#01H
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 775
0038 04                INC     A
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 804
003A E4                CLR     A
003B 900000      E     MOV     DPTR,#USBFS_configurationChanged
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 805
003F 900000      E     MOV     DPTR,#USBFS_configuration
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 806
0043 900000      E     MOV     DPTR,#USBFS_interfaceNumber
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 807
0047 900000      E     MOV     DPTR,#USBFS_deviceAddress
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 808
004B 900000      E     MOV     DPTR,#USBFS_deviceStatus
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 811
004F 900000      R     MOV     DPTR,#USBFS_initVar
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 55  

0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 812
0053 22                RET     
             ; FUNCTION USBFS_Stop (END)

             ; FUNCTION USBFS_CheckActivity (BEGIN)
                                           ; SOURCE LINE # 835
                                           ; SOURCE LINE # 836
                                           ; SOURCE LINE # 837
0000 906009            MOV     DPTR,#06009H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
;---- Variable 'cr1Reg' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 840
0005 54FB              ANL     A,#0FBH
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 843
0008 EF                MOV     A,R7
0009 30E204            JNB     ACC.2,?C0017
000C 7F01              MOV     R7,#01H
000E 8002              SJMP    ?C0018
0010         ?C0017:
0010 7F00              MOV     R7,#00H
0012         ?C0018:
                                           ; SOURCE LINE # 844
0012         ?C0019:
0012 22                RET     
             ; FUNCTION USBFS_CheckActivity (END)

             ; FUNCTION USBFS_GetConfiguration (BEGIN)
                                           ; SOURCE LINE # 858
                                           ; SOURCE LINE # 859
                                           ; SOURCE LINE # 860
0000 900000      E     MOV     DPTR,#USBFS_configuration
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 861
0005         ?C0020:
0005 22                RET     
             ; FUNCTION USBFS_GetConfiguration (END)

             ; FUNCTION USBFS_IsConfigurationChanged (BEGIN)
                                           ; SOURCE LINE # 884
                                           ; SOURCE LINE # 885
                                           ; SOURCE LINE # 886
;---- Variable 'res' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 888
0002 900000      E     MOV     DPTR,#USBFS_configurationChanged
0005 E0                MOVX    A,@DPTR
0006 6004              JZ      ?C0021
                                           ; SOURCE LINE # 889
                                           ; SOURCE LINE # 890
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
                                           ; SOURCE LINE # 891
000A E4                CLR     A
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 892
000C         ?C0021:
                                           ; SOURCE LINE # 894
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 56  

                                           ; SOURCE LINE # 895
000C         ?C0022:
000C 22                RET     
             ; FUNCTION USBFS_IsConfigurationChanged (END)

             ; FUNCTION _USBFS_GetInterfaceSetting (BEGIN)
                                           ; SOURCE LINE # 913
;---- Variable 'interfaceNumber' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 915
                                           ; SOURCE LINE # 916
0000 7400        E     MOV     A,#LOW USBFS_interfaceSetting
0002 2F                ADD     A,R7
0003 F582              MOV     DPL,A
0005 E4                CLR     A
0006 3400        E     ADDC    A,#HIGH USBFS_interfaceSetting
0008 F583              MOV     DPH,A
000A E0                MOVX    A,@DPTR
000B FF                MOV     R7,A
                                           ; SOURCE LINE # 917
000C         ?C0023:
000C 22                RET     
             ; FUNCTION _USBFS_GetInterfaceSetting (END)

             ; FUNCTION _USBFS_GetEPState (BEGIN)
                                           ; SOURCE LINE # 945
;---- Variable 'epNumber' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 946
                                           ; SOURCE LINE # 947
0000 EF                MOV     A,R7
0001 75F00B            MOV     B,#0BH
0004 A4                MUL     AB
0005 2400        E     ADD     A,#LOW USBFS_EP+01H
0007 F582              MOV     DPL,A
0009 E4                CLR     A
000A 3400        E     ADDC    A,#HIGH USBFS_EP+01H
000C F583              MOV     DPH,A
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
                                           ; SOURCE LINE # 948
0010         ?C0024:
0010 22                RET     
             ; FUNCTION _USBFS_GetEPState (END)

             ; FUNCTION _USBFS_GetEPCount (BEGIN)
                                           ; SOURCE LINE # 968
;---- Variable 'epNumber' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 969
                                           ; SOURCE LINE # 970
;---- Variable 'cntr' assigned to Register 'R4/R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
0002 FC                MOV     R4,A
                                           ; SOURCE LINE # 972
0003 EF                MOV     A,R7
0004 D3                SETB    C
0005 9400              SUBB    A,#00H
0007 402A              JC      ?C0025
0009 EF                MOV     A,R7
000A 9409              SUBB    A,#09H
000C 5025              JNC     ?C0025
                                           ; SOURCE LINE # 973
                                           ; SOURCE LINE # 975
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 57  

000E 75F010            MOV     B,#010H
0011 EF                MOV     A,R7
0012 905FFC            MOV     DPTR,#05FFCH
0015 120000      E     LCALL   ?C?OFFXADD
0018 E0                MOVX    A,@DPTR
0019 540F              ANL     A,#0FH
001B FD                MOV     R5,A
                                           ; SOURCE LINE # 976
001C 75F010            MOV     B,#010H
001F EF                MOV     A,R7
0020 905FFD            MOV     DPTR,#05FFDH
0023 120000      E     LCALL   ?C?OFFXADD
0026 E0                MOVX    A,@DPTR
0027 FB                MOV     R3,A
0028 ED                MOV     A,R5
0029 FC                MOV     R4,A
002A EB                MOV     A,R3
002B FD                MOV     R5,A
                                           ; SOURCE LINE # 977
002C 24FE              ADD     A,#0FEH
002E FD                MOV     R5,A
002F 74FF              MOV     A,#0FFH
0031 3C                ADDC    A,R4
0032 FC                MOV     R4,A
                                           ; SOURCE LINE # 978
0033         ?C0025:
                                           ; SOURCE LINE # 980
0033 AE04              MOV     R6,AR4
0035 AF05              MOV     R7,AR5
                                           ; SOURCE LINE # 981
0037         ?C0026:
0037 22                RET     
             ; FUNCTION _USBFS_GetEPCount (END)

             ; FUNCTION _USBFS_LoadInEP (BEGIN)
                                           ; SOURCE LINE # 1328
0000 900000      R     MOV     DPTR,#pData
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#epNumber
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1330
                                           ; SOURCE LINE # 1331
000B D3                SETB    C
000C 9400              SUBB    A,#00H
000E 5003              JNC     $ + 5H
0010 020000      R     LJMP    ?C0033
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 9409              SUBB    A,#09H
0017 4003              JC      $ + 5H
0019 020000      R     LJMP    ?C0033
                                           ; SOURCE LINE # 1332
                                           ; SOURCE LINE # 1335
001C EF                MOV     A,R7
001D 75F00B            MOV     B,#0BH
0020 A4                MUL     AB
0021 2400        E     ADD     A,#LOW USBFS_EP+06H
0023 F582              MOV     DPL,A
0025 E4                CLR     A
0026 3400        E     ADDC    A,#HIGH USBFS_EP+06H
0028 F583              MOV     DPH,A
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 58  

002A E0                MOVX    A,@DPTR
002B FE                MOV     R6,A
002C A3                INC     DPTR
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
002F C3                CLR     C
0030 E4                CLR     A
0031 9F                SUBB    A,R7
0032 FF                MOV     R7,A
0033 7402              MOV     A,#02H
0035 9E                SUBB    A,R6
0036 FE                MOV     R6,A
0037 D3                SETB    C
0038 900000      R     MOV     DPTR,#length+01H
003B E0                MOVX    A,@DPTR
003C 9F                SUBB    A,R7
003D 900000      R     MOV     DPTR,#length
0040 E0                MOVX    A,@DPTR
0041 9E                SUBB    A,R6
0042 4024              JC      ?C0028
                                           ; SOURCE LINE # 1336
                                           ; SOURCE LINE # 1337
0044 900000      R     MOV     DPTR,#epNumber
0047 E0                MOVX    A,@DPTR
0048 75F00B            MOV     B,#0BH
004B A4                MUL     AB
004C 2400        E     ADD     A,#LOW USBFS_EP+06H
004E F582              MOV     DPL,A
0050 E4                CLR     A
0051 3400        E     ADDC    A,#HIGH USBFS_EP+06H
0053 F583              MOV     DPH,A
0055 E0                MOVX    A,@DPTR
0056 FE                MOV     R6,A
0057 A3                INC     DPTR
0058 E0                MOVX    A,@DPTR
0059 FF                MOV     R7,A
005A C3                CLR     C
005B E4                CLR     A
005C 9F                SUBB    A,R7
005D 900000      R     MOV     DPTR,#length+01H
0060 F0                MOVX    @DPTR,A
0061 7402              MOV     A,#02H
0063 9E                SUBB    A,R6
0064 900000      R     MOV     DPTR,#length
0067 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1338
0068         ?C0028:
                                           ; SOURCE LINE # 1342
0068 900000      R     MOV     DPTR,#length
006B E0                MOVX    A,@DPTR
006C FC                MOV     R4,A
006D A3                INC     DPTR
006E E0                MOVX    A,@DPTR
006F FD                MOV     R5,A
0070 EC                MOV     A,R4
0071 FF                MOV     R7,A
0072 900000      R     MOV     DPTR,#epNumber
0075 E0                MOVX    A,@DPTR
0076 FE                MOV     R6,A
0077 75F00B            MOV     B,#0BH
007A A4                MUL     AB
007B 2400        E     ADD     A,#LOW USBFS_EP+03H
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 59  

007D F582              MOV     DPL,A
007F E4                CLR     A
0080 3400        E     ADDC    A,#HIGH USBFS_EP+03H
0082 F583              MOV     DPH,A
0084 E0                MOVX    A,@DPTR
0085 4F                ORL     A,R7
0086 FF                MOV     R7,A
0087 75F010            MOV     B,#010H
008A EE                MOV     A,R6
008B 905FFC            MOV     DPTR,#05FFCH
008E 120000      E     LCALL   ?C?OFFXADD
0091 EF                MOV     A,R7
0092 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1343
0093 ED                MOV     A,R5
0094 900000      R     MOV     DPTR,#epNumber
0097 E0                MOVX    A,@DPTR
0098 75F010            MOV     B,#010H
009B 905FFD            MOV     DPTR,#05FFDH
009E 120000      E     LCALL   ?C?OFFXADD
00A1 ED                MOV     A,R5
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1346
00A3 900000      R     MOV     DPTR,#pData
00A6 120000      E     LCALL   ?C?PLDXDATA
00A9 E9                MOV     A,R1
00AA 4A                ORL     A,R2
00AB 4B                ORL     A,R3
00AC 6046              JZ      ?C0029
                                           ; SOURCE LINE # 1347
                                           ; SOURCE LINE # 1350
00AE E4                CLR     A
00AF 900000      R     MOV     DPTR,#i
00B2 F0                MOVX    @DPTR,A
00B3 A3                INC     DPTR
00B4 F0                MOVX    @DPTR,A
00B5         ?C0030:
00B5 900000      R     MOV     DPTR,#length
00B8 E0                MOVX    A,@DPTR
00B9 FE                MOV     R6,A
00BA A3                INC     DPTR
00BB E0                MOVX    A,@DPTR
00BC FF                MOV     R7,A
00BD A3                INC     DPTR
00BE E0                MOVX    A,@DPTR
00BF FC                MOV     R4,A
00C0 A3                INC     DPTR
00C1 E0                MOVX    A,@DPTR
00C2 FD                MOV     R5,A
00C3 C3                CLR     C
00C4 9F                SUBB    A,R7
00C5 EC                MOV     A,R4
00C6 9E                SUBB    A,R6
00C7 502B              JNC     ?C0029
                                           ; SOURCE LINE # 1351
                                           ; SOURCE LINE # 1352
00C9 900000      R     MOV     DPTR,#pData
00CC 120000      E     LCALL   ?C?PLDXDATA
00CF E9                MOV     A,R1
00D0 2D                ADD     A,R5
00D1 F9                MOV     R1,A
00D2 EA                MOV     A,R2
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 60  

00D3 3C                ADDC    A,R4
00D4 FA                MOV     R2,A
00D5 120000      E     LCALL   ?C?CLDPTR
00D8 FF                MOV     R7,A
00D9 900000      R     MOV     DPTR,#epNumber
00DC E0                MOVX    A,@DPTR
00DD 75F010            MOV     B,#010H
00E0 906078            MOV     DPTR,#06078H
00E3 120000      E     LCALL   ?C?OFFXADD
00E6 EF                MOV     A,R7
00E7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1353
00E8 900000      R     MOV     DPTR,#i
00EB E4                CLR     A
00EC 75F001            MOV     B,#01H
00EF 120000      E     LCALL   ?C?IILDX
00F2 80C1              SJMP    ?C0030
                                           ; SOURCE LINE # 1354
00F4         ?C0029:
                                           ; SOURCE LINE # 1357
00F4 900000      R     MOV     DPTR,#epNumber
00F7 E0                MOVX    A,@DPTR
00F8 FF                MOV     R7,A
00F9 75F00B            MOV     B,#0BH
00FC A4                MUL     AB
00FD 2400        E     ADD     A,#LOW USBFS_EP+01H
00FF F582              MOV     DPL,A
0101 E4                CLR     A
0102 3400        E     ADDC    A,#HIGH USBFS_EP+01H
0104 F583              MOV     DPH,A
0106 E4                CLR     A
0107 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1360
0108 EF                MOV     A,R7
0109 75F00B            MOV     B,#0BH
010C A4                MUL     AB
010D 2400        E     ADD     A,#LOW USBFS_EP+05H
010F F582              MOV     DPL,A
0111 E4                CLR     A
0112 3400        E     ADDC    A,#HIGH USBFS_EP+05H
0114 F583              MOV     DPH,A
0116 E0                MOVX    A,@DPTR
0117 FF                MOV     R7,A
0118 900000      R     MOV     DPTR,#epNumber
011B E0                MOVX    A,@DPTR
011C 75F010            MOV     B,#010H
011F 905FFE            MOV     DPTR,#05FFEH
0122 120000      E     LCALL   ?C?OFFXADD
0125 EF                MOV     A,R7
0126 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1585
                                           ; SOURCE LINE # 1586
0127         ?C0033:
0127 22                RET     
             ; FUNCTION _USBFS_LoadInEP (END)

             ; FUNCTION _USBFS_ReadOutEP (BEGIN)
                                           ; SOURCE LINE # 1635
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 61  

0006 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1637
                                           ; SOURCE LINE # 1638
0009 900000      R     MOV     DPTR,#pData
000C 120000      E     LCALL   ?C?PLDXDATA
000F E9                MOV     A,R1
0010 4A                ORL     A,R2
0011 4B                ORL     A,R3
0012 7003              JNZ     $ + 5H
0014 020000      R     LJMP    ?C0034
0017 900000      R     MOV     DPTR,#epNumber
001A E0                MOVX    A,@DPTR
001B FF                MOV     R7,A
001C D3                SETB    C
001D 9400              SUBB    A,#00H
001F 407D              JC      ?C0034
0021 EF                MOV     A,R7
0022 9409              SUBB    A,#09H
0024 5078              JNC     ?C0034
                                           ; SOURCE LINE # 1639
                                           ; SOURCE LINE # 1642
0026 120000      R     LCALL   _USBFS_GetEPCount
0029 D3                SETB    C
002A 900000      R     MOV     DPTR,#length+01H
002D E0                MOVX    A,@DPTR
002E 9F                SUBB    A,R7
002F 900000      R     MOV     DPTR,#length
0032 E0                MOVX    A,@DPTR
0033 9E                SUBB    A,R6
0034 400A              JC      ?C0035
0036 900000      R     MOV     DPTR,#epNumber
0039 E0                MOVX    A,@DPTR
003A FF                MOV     R7,A
003B 120000      R     LCALL   _USBFS_GetEPCount
003E 8008              SJMP    ?C0036
0040         ?C0035:
0040 900000      R     MOV     DPTR,#length
0043 E0                MOVX    A,@DPTR
0044 FE                MOV     R6,A
0045 A3                INC     DPTR
0046 E0                MOVX    A,@DPTR
0047 FF                MOV     R7,A
0048         ?C0036:
0048 900000      R     MOV     DPTR,#length
004B EE                MOV     A,R6
004C F0                MOVX    @DPTR,A
004D A3                INC     DPTR
004E EF                MOV     A,R7
004F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1646
                                           ; SOURCE LINE # 1649
0050 E4                CLR     A
0051 A3                INC     DPTR
0052 F0                MOVX    @DPTR,A
0053 A3                INC     DPTR
0054 F0                MOVX    @DPTR,A
0055         ?C0037:
0055 900000      R     MOV     DPTR,#length
0058 E0                MOVX    A,@DPTR
0059 FE                MOV     R6,A
005A A3                INC     DPTR
005B E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 62  

005C FF                MOV     R7,A
005D A3                INC     DPTR
005E E0                MOVX    A,@DPTR
005F FC                MOV     R4,A
0060 A3                INC     DPTR
0061 E0                MOVX    A,@DPTR
0062 FD                MOV     R5,A
0063 C3                CLR     C
0064 9F                SUBB    A,R7
0065 EC                MOV     A,R4
0066 9E                SUBB    A,R6
0067 502B              JNC     ?C0038
                                           ; SOURCE LINE # 1650
                                           ; SOURCE LINE # 1651
0069 900000      R     MOV     DPTR,#epNumber
006C E0                MOVX    A,@DPTR
006D 75F010            MOV     B,#010H
0070 906078            MOV     DPTR,#06078H
0073 120000      E     LCALL   ?C?OFFXADD
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 900000      R     MOV     DPTR,#pData
007B 120000      E     LCALL   ?C?PLDXDATA
007E E9                MOV     A,R1
007F 2D                ADD     A,R5
0080 F9                MOV     R1,A
0081 EA                MOV     A,R2
0082 3C                ADDC    A,R4
0083 FA                MOV     R2,A
0084 EF                MOV     A,R7
0085 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 1652
0088 900000      R     MOV     DPTR,#i
008B E4                CLR     A
008C 75F001            MOV     B,#01H
008F 120000      E     LCALL   ?C?IILDX
0092 80C1              SJMP    ?C0037
0094         ?C0038:
                                           ; SOURCE LINE # 1653
                                           ; SOURCE LINE # 1656
0094 900000      R     MOV     DPTR,#epNumber
0097 E0                MOVX    A,@DPTR
0098 FF                MOV     R7,A
0099 120000      R     LCALL   _USBFS_EnableOutEP
                                           ; SOURCE LINE # 1795
009C 8007              SJMP    ?C0040
009E         ?C0034:
                                           ; SOURCE LINE # 1797
                                           ; SOURCE LINE # 1798
009E E4                CLR     A
009F 900000      R     MOV     DPTR,#length
00A2 F0                MOVX    @DPTR,A
00A3 A3                INC     DPTR
00A4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1799
00A5         ?C0040:
                                           ; SOURCE LINE # 1801
00A5 900000      R     MOV     DPTR,#length
00A8 E0                MOVX    A,@DPTR
00A9 FE                MOV     R6,A
00AA A3                INC     DPTR
00AB E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 63  

00AC FF                MOV     R7,A
                                           ; SOURCE LINE # 1802
00AD         ?C0041:
00AD 22                RET     
             ; FUNCTION _USBFS_ReadOutEP (END)

             ; FUNCTION _USBFS_EnableOutEP (BEGIN)
                                           ; SOURCE LINE # 2247
;---- Variable 'epNumber' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2248
                                           ; SOURCE LINE # 2249
0000 EF                MOV     A,R7
0001 D3                SETB    C
0002 9400              SUBB    A,#00H
0004 4031              JC      ?C0043
0006 EF                MOV     A,R7
0007 9409              SUBB    A,#09H
0009 502C              JNC     ?C0043
                                           ; SOURCE LINE # 2250
                                           ; SOURCE LINE # 2251
000B EF                MOV     A,R7
000C 75F00B            MOV     B,#0BH
000F A4                MUL     AB
0010 2400        E     ADD     A,#LOW USBFS_EP+01H
0012 F582              MOV     DPL,A
0014 E4                CLR     A
0015 3400        E     ADDC    A,#HIGH USBFS_EP+01H
0017 F583              MOV     DPH,A
0019 E4                CLR     A
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2254
001B EF                MOV     A,R7
001C 75F00B            MOV     B,#0BH
001F A4                MUL     AB
0020 2400        E     ADD     A,#LOW USBFS_EP+05H
0022 F582              MOV     DPL,A
0024 E4                CLR     A
0025 3400        E     ADDC    A,#HIGH USBFS_EP+05H
0027 F583              MOV     DPH,A
0029 E0                MOVX    A,@DPTR
002A FE                MOV     R6,A
002B 75F010            MOV     B,#010H
002E EF                MOV     A,R7
002F 905FFE            MOV     DPTR,#05FFEH
0032 120000      E     LCALL   ?C?OFFXADD
0035 EE                MOV     A,R6
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2256
                                           ; SOURCE LINE # 2257
0037         ?C0043:
0037 22                RET     
             ; FUNCTION _USBFS_EnableOutEP (END)

             ; FUNCTION _USBFS_DisableOutEP (BEGIN)
                                           ; SOURCE LINE # 2271
;---- Variable 'epNumber' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2272
                                           ; SOURCE LINE # 2273
0000 EF                MOV     A,R7
0001 D3                SETB    C
0002 9400              SUBB    A,#00H
0004 4012              JC      ?C0045
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 64  

0006 EF                MOV     A,R7
0007 9409              SUBB    A,#09H
0009 500D              JNC     ?C0045
                                           ; SOURCE LINE # 2274
                                           ; SOURCE LINE # 2276
000B 75F010            MOV     B,#010H
000E EF                MOV     A,R7
000F 905FFE            MOV     DPTR,#05FFEH
0012 120000      E     LCALL   ?C?OFFXADD
0015 7408              MOV     A,#08H
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2277
                                           ; SOURCE LINE # 2278
0018         ?C0045:
0018 22                RET     
             ; FUNCTION _USBFS_DisableOutEP (END)

             ; FUNCTION _USBFS_Force (BEGIN)
                                           ; SOURCE LINE # 2301
;---- Variable 'bState' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2302
                                           ; SOURCE LINE # 2306
0000 906010            MOV     DPTR,#06010H
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2307
0005 22                RET     
             ; FUNCTION _USBFS_Force (END)

             ; FUNCTION _USBFS_GetEPAckState (BEGIN)
                                           ; SOURCE LINE # 2326
;---- Variable 'epNumber' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2327
                                           ; SOURCE LINE # 2328
;---- Variable 'cr' assigned to Register 'R6' ----
0000 E4                CLR     A
0001 FE                MOV     R6,A
                                           ; SOURCE LINE # 2330
0002 EF                MOV     A,R7
0003 D3                SETB    C
0004 9400              SUBB    A,#00H
0006 4013              JC      ?C0047
0008 EF                MOV     A,R7
0009 9409              SUBB    A,#09H
000B 500E              JNC     ?C0047
                                           ; SOURCE LINE # 2331
                                           ; SOURCE LINE # 2332
000D 75F010            MOV     B,#010H
0010 EF                MOV     A,R7
0011 905FFE            MOV     DPTR,#05FFEH
0014 120000      E     LCALL   ?C?OFFXADD
0017 E0                MOVX    A,@DPTR
0018 5410              ANL     A,#010H
001A FE                MOV     R6,A
                                           ; SOURCE LINE # 2333
001B         ?C0047:
                                           ; SOURCE LINE # 2335
001B AF06              MOV     R7,AR6
                                           ; SOURCE LINE # 2336
001D         ?C0048:
001D 22                RET     
             ; FUNCTION _USBFS_GetEPAckState (END)
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 65  


             ; FUNCTION _USBFS_SetPowerStatus (BEGIN)
                                           ; SOURCE LINE # 2367
;---- Variable 'powerStatus' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2368
                                           ; SOURCE LINE # 2369
0000 EF                MOV     A,R7
0001 6008              JZ      ?C0049
                                           ; SOURCE LINE # 2370
                                           ; SOURCE LINE # 2371
0003 900000      E     MOV     DPTR,#USBFS_deviceStatus
0006 E0                MOVX    A,@DPTR
0007 4401              ORL     A,#01H
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2372
000A 22                RET     
000B         ?C0049:
                                           ; SOURCE LINE # 2374
                                           ; SOURCE LINE # 2375
000B 900000      E     MOV     DPTR,#USBFS_deviceStatus
000E E0                MOVX    A,@DPTR
000F 54FE              ANL     A,#0FEH
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2376
                                           ; SOURCE LINE # 2377
0012         ?C0051:
0012 22                RET     
             ; FUNCTION _USBFS_SetPowerStatus (END)

             ; FUNCTION USBFS_RWUEnabled (BEGIN)
                                           ; SOURCE LINE # 2424
                                           ; SOURCE LINE # 2425
                                           ; SOURCE LINE # 2426
;---- Variable 'result' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 2428
0002 900000      E     MOV     DPTR,#USBFS_deviceStatus
0005 E0                MOVX    A,@DPTR
0006 5402              ANL     A,#02H
0008 6001              JZ      ?C0052
                                           ; SOURCE LINE # 2429
                                           ; SOURCE LINE # 2430
000A 0F                INC     R7
                                           ; SOURCE LINE # 2431
000B         ?C0052:
                                           ; SOURCE LINE # 2433
                                           ; SOURCE LINE # 2434
000B         ?C0053:
000B 22                RET     
             ; FUNCTION USBFS_RWUEnabled (END)

             ; FUNCTION USBFS_GetDeviceAddress (BEGIN)
                                           ; SOURCE LINE # 2448
                                           ; SOURCE LINE # 2449
                                           ; SOURCE LINE # 2450
0000 906008            MOV     DPTR,#06008H
0003 E0                MOVX    A,@DPTR
0004 547F              ANL     A,#07FH
0006 FF                MOV     R7,A
                                           ; SOURCE LINE # 2451
0007         ?C0054:
C51 COMPILER V9.51   USBFS                                                                 07/29/2016 09:50:43 PAGE 66  

0007 22                RET     
             ; FUNCTION USBFS_GetDeviceAddress (END)

             ; FUNCTION USBFS_EnableSofInt (BEGIN)
                                           ; SOURCE LINE # 2462
                                           ; SOURCE LINE # 2463
                                           ; SOURCE LINE # 2470
0000 9044C2            MOV     DPTR,#044C2H
0003 7420              MOV     A,#020H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2473
0006 22                RET     
             ; FUNCTION USBFS_EnableSofInt (END)

             ; FUNCTION USBFS_DisableSofInt (BEGIN)
                                           ; SOURCE LINE # 2484
                                           ; SOURCE LINE # 2485
                                           ; SOURCE LINE # 2492
0000 9044CA            MOV     DPTR,#044CAH
0003 7420              MOV     A,#020H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2495
0006 22                RET     
             ; FUNCTION USBFS_DisableSofInt (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1296    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
