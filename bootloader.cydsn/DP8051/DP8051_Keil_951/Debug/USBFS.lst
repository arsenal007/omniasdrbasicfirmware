C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USBFS
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\USBFS.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\USBFS.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(DEBUG) W
                    -L(2) PR(.\DP8051\DP8051_Keil_951\Debug/USBFS.lst) CD OT(5,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\USBFS.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: USBFS.c
   3          * Version 2.80
   4          *
   5          * Description:
   6          *  API for USBFS Component.
   7          *
   8          * Note:
   9          *  Many of the functions use endpoint number.  RAM arrays are sized with 9
  10          *  elements so they are indexed directly by epNumber.  The SIE and ARB
  11          *  registers are indexed by variations of epNumber - 1.
  12          *
  13          ********************************************************************************
  14          * Copyright 2008-2014, Cypress Semiconductor Corporation.  All rights reserved.
  15          * You may use this file only in accordance with the license, terms, conditions,
  16          * disclaimers, and limitations in the end user license agreement accompanying
  17          * the software package with which this file was provided.
  18          *******************************************************************************/
  19          
  20          #include <CyDmac.h>
  21          #include "USBFS.h"
  22          #include "USBFS_pvt.h"
  23          #include "USBFS_hid.h"
  24          #if(USBFS_DMA1_REMOVE == 0u)
                  #include "USBFS_ep1_dma.h"
              #endif   /*  USBFS_DMA1_REMOVE */
  27          #if(USBFS_DMA2_REMOVE == 0u)
                  #include "USBFS_ep2_dma.h"
              #endif   /*  USBFS_DMA2_REMOVE */
  30          #if(USBFS_DMA3_REMOVE == 0u)
                  #include "USBFS_ep3_dma.h"
              #endif   /*  USBFS_DMA3_REMOVE */
  33          #if(USBFS_DMA4_REMOVE == 0u)
                  #include "USBFS_ep4_dma.h"
              #endif   /*  USBFS_DMA4_REMOVE */
  36          #if(USBFS_DMA5_REMOVE == 0u)
                  #include "USBFS_ep5_dma.h"
              #endif   /*  USBFS_DMA5_REMOVE */
  39          #if(USBFS_DMA6_REMOVE == 0u)
                  #include "USBFS_ep6_dma.h"
              #endif   /*  USBFS_DMA6_REMOVE */
  42          #if(USBFS_DMA7_REMOVE == 0u)
                  #include "USBFS_ep7_dma.h"
              #endif   /*  USBFS_DMA7_REMOVE */
  45          #if(USBFS_DMA8_REMOVE == 0u)
                  #include "USBFS_ep8_dma.h"
              #endif   /*  USBFS_DMA8_REMOVE */
  48          #if((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u))
                  #include "USBFS_EP_DMA_Done_isr.h"
                  #include "USBFS_EP8_DMA_Done_SR.h"
                  #include "USBFS_EP17_DMA_Done_SR.h"
              #endif /* ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u)) */
  53          
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 2   

  54          
  55          /***************************************
  56          * Global data allocation
  57          ***************************************/
  58          
  59          uint8 USBFS_initVar = 0u;
  60          #if(USBFS_EP_MM != USBFS__EP_MANUAL)
                  uint8 USBFS_DmaChan[USBFS_MAX_EP];
                  uint8 USBFS_DmaTd[USBFS_MAX_EP];
              #endif /*  USBFS_EP_MM */
  64          #if((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u))
                  static uint8 clearInDataRdyStatus = USBFS_ARB_EPX_CFG_DEFAULT;
                  uint8 USBFS_DmaNextTd[USBFS_MAX_EP];
                  const uint8 USBFS_epX_TD_TERMOUT_EN[USBFS_MAX_EP] =
                  {   0u,
                      USBFS_ep1_TD_TERMOUT_EN,
                      USBFS_ep2_TD_TERMOUT_EN,
                      USBFS_ep3_TD_TERMOUT_EN,
                      USBFS_ep4_TD_TERMOUT_EN,
                      USBFS_ep5_TD_TERMOUT_EN,
                      USBFS_ep6_TD_TERMOUT_EN,
                      USBFS_ep7_TD_TERMOUT_EN,
                      USBFS_ep8_TD_TERMOUT_EN
                  };
                  volatile uint16 USBFS_inLength[USBFS_MAX_EP];
                  const uint8 *USBFS_inDataPointer[USBFS_MAX_EP];
                  volatile uint8 USBFS_inBufFull[USBFS_MAX_EP];
              #endif /* ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u)) */
  82          
  83          
  84          /*******************************************************************************
  85          * Function Name: USBFS_Start
  86          ********************************************************************************
  87          *
  88          * Summary:
  89          *  This function initialize the USB SIE, arbiter and the
  90          *  endpoint APIs, including setting the D+ Pullup
  91          *
  92          * Parameters:
  93          *  device: Contains the device number of the desired device descriptor.
  94          *          The device number can be found in the Device Descriptor Tab of
  95          *          "Configure" dialog, under the settings of desired Device Descriptor,
  96          *          in the "Device Number" field.
  97          *  mode: The operating voltage. This determines whether the voltage regulator
  98          *        is enabled for 5V operation or if pass through mode is used for 3.3V
  99          *        operation. Symbolic names and their associated values are given in the
 100          *        following table.
 101          *       USBFS_3V_OPERATION - Disable voltage regulator and pass-thru
 102          *                                       Vcc for pull-up
 103          *       USBFS_5V_OPERATION - Enable voltage regulator and use
 104          *                                       regulator for pull-up
 105          *       USBFS_DWR_VDDD_OPERATION - Enable or Disable voltage
 106          *                         regulator depend on Vddd Voltage configuration in DWR.
 107          *
 108          * Return:
 109          *   None.
 110          *
 111          * Global variables:
 112          *  The USBFS_intiVar variable is used to indicate initial
 113          *  configuration of this component. The variable is initialized to zero (0u)
 114          *  and set to one (1u) the first time USBFS_Start() is called.
 115          *  This allows for component Re-Start without unnecessary re-initialization
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 3   

 116          *  in all subsequent calls to the USBFS_Start() routine.
 117          *  If re-initialization of the component is required the variable should be set
 118          *  to zero before call of UART_Start() routine, or the user may call
 119          *  USBFS_Init() and USBFS_InitComponent() as done
 120          *  in the USBFS_Start() routine.
 121          *
 122          * Side Effects:
 123          *   This function will reset all communication states to default.
 124          *
 125          * Reentrant:
 126          *  No.
 127          *
 128          *******************************************************************************/
 129          void USBFS_Start(uint8 device, uint8 mode) 
 130          {
 131   1          /* If not Initialized then initialize all required hardware and software */
 132   1          if(USBFS_initVar == 0u)
 133   1          {
 134   2              USBFS_Init();
 135   2              USBFS_initVar = 1u;
 136   2          }
 137   1          USBFS_InitComponent(device, mode);
 138   1      }
 139          
 140          
 141          /*******************************************************************************
 142          * Function Name: USBFS_Init
 143          ********************************************************************************
 144          *
 145          * Summary:
 146          *  Initialize component's hardware. Usually called in USBFS_Start().
 147          *
 148          * Parameters:
 149          *  None.
 150          *
 151          * Return:
 152          *  None.
 153          *
 154          * Reentrant:
 155          *  No.
 156          *
 157          *******************************************************************************/
 158          void USBFS_Init(void) 
 159          {
 160   1          uint8 enableInterrupts;
 161   1          #if(USBFS_EP_MM != USBFS__EP_MANUAL)
                      uint16 i;
                  #endif   /*  USBFS_EP_MM != USBFS__EP_MANUAL */
 164   1      
 165   1          enableInterrupts = CyEnterCriticalSection();
 166   1      
 167   1          /* Enable USB block  */
 168   1          USBFS_PM_ACT_CFG_REG |= USBFS_PM_ACT_EN_FSUSB;
 169   1          /* Enable USB block for Standby Power Mode */
 170   1          USBFS_PM_STBY_CFG_REG |= USBFS_PM_STBY_EN_FSUSB;
 171   1      
 172   1          /* Enable core clock */
 173   1          USBFS_USB_CLK_EN_REG = USBFS_USB_CLK_ENABLE;
 174   1      
 175   1          USBFS_CR1_REG = USBFS_CR1_ENABLE_LOCK;
 176   1      
 177   1          /* ENABLING USBIO PADS IN USB MODE FROM I/O MODE */
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 4   

 178   1          /* Ensure USB transmit enable is low (USB_USBIO_CR0.ten). - Manual Transmission - Disabled */
 179   1          USBFS_USBIO_CR0_REG &= ((uint8)(~USBFS_USBIO_CR0_TEN));
 180   1          CyDelayUs(0u);  /*~50ns delay */
 181   1          /* Disable the USBIO by asserting PM.USB_CR0.fsusbio_pd_n(Inverted)
 182   1          *  high. This will have been set low by the power manger out of reset.
 183   1          *  Also confirm USBIO pull-up disabled
 184   1          */
 185   1          USBFS_PM_USB_CR0_REG &= ((uint8)(~(USBFS_PM_USB_CR0_PD_N |
 186   1                                                        USBFS_PM_USB_CR0_PD_PULLUP_N)));
 187   1      
 188   1          /* Select iomode to USB mode*/
 189   1          USBFS_USBIO_CR1_REG &= ((uint8)(~USBFS_USBIO_CR1_IOMODE));
 190   1      
 191   1          /* Enable the USBIO reference by setting PM.USB_CR0.fsusbio_ref_en.*/
 192   1          USBFS_PM_USB_CR0_REG |= USBFS_PM_USB_CR0_REF_EN;
 193   1          /* The reference will be available 1 us after the regulator is enabled */
 194   1          CyDelayUs(1u);
 195   1          /* OR 40us after power restored */
 196   1          CyDelayUs(40u);
 197   1          /* Ensure the single ended disable bits are low (PRT15.INP_DIS[7:6])(input receiver enabled). */
 198   1          USBFS_DM_INP_DIS_REG &= ((uint8)(~USBFS_DM_MASK));
 199   1          USBFS_DP_INP_DIS_REG &= ((uint8)(~USBFS_DP_MASK));
 200   1      
 201   1          /* Enable USBIO */
 202   1          USBFS_PM_USB_CR0_REG |= USBFS_PM_USB_CR0_PD_N;
 203   1          CyDelayUs(2u);
 204   1          /* Set the USBIO pull-up enable */
 205   1          USBFS_PM_USB_CR0_REG |= USBFS_PM_USB_CR0_PD_PULLUP_N;
 206   1      
 207   1          /* Write WAx */
 208   1          CY_SET_REG8(USBFS_ARB_RW1_WA_PTR,     0u);
 209   1          CY_SET_REG8(USBFS_ARB_RW1_WA_MSB_PTR, 0u);
 210   1      
 211   1          #if(USBFS_EP_MM != USBFS__EP_MANUAL)
                      /* Init transfer descriptor. This will be used to detect the DMA state - initialized or not. */
                      for (i = 0u; i < USBFS_MAX_EP; i++)
                      {
                          USBFS_DmaTd[i] = DMA_INVALID_TD;
                          #if ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u))
                              USBFS_DmaNextTd[i] = DMA_INVALID_TD;
                          #endif /* ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u)) */
                      }
                  #endif   /*  USBFS_EP_MM != USBFS__EP_MANUAL */
 221   1      
 222   1          CyExitCriticalSection(enableInterrupts);
 223   1      
 224   1      
 225   1          /* Set the bus reset Interrupt. */
 226   1          (void) CyIntSetVector(USBFS_BUS_RESET_VECT_NUM,   &USBFS_BUS_RESET_ISR);
 227   1          CyIntSetPriority(USBFS_BUS_RESET_VECT_NUM, USBFS_BUS_RESET_PRIOR);
 228   1      
 229   1          /* Set the SOF Interrupt. */
 230   1          #if(USBFS_SOF_ISR_REMOVE == 0u)
 231   1              (void) CyIntSetVector(USBFS_SOF_VECT_NUM,   &USBFS_SOF_ISR);
 232   1              CyIntSetPriority(USBFS_SOF_VECT_NUM, USBFS_SOF_PRIOR);
 233   1          #endif   /*  USBFS_SOF_ISR_REMOVE */
 234   1      
 235   1          /* Set the Control Endpoint Interrupt. */
 236   1          (void) CyIntSetVector(USBFS_EP_0_VECT_NUM,   &USBFS_EP_0_ISR);
 237   1          CyIntSetPriority(USBFS_EP_0_VECT_NUM, USBFS_EP_0_PRIOR);
 238   1      
 239   1          /* Set the Data Endpoint 1 Interrupt. */
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 5   

 240   1          #if(USBFS_EP1_ISR_REMOVE == 0u)
 241   1              (void) CyIntSetVector(USBFS_EP_1_VECT_NUM,   &USBFS_EP_1_ISR);
 242   1              CyIntSetPriority(USBFS_EP_1_VECT_NUM, USBFS_EP_1_PRIOR);
 243   1          #endif   /*  USBFS_EP1_ISR_REMOVE */
 244   1      
 245   1          /* Set the Data Endpoint 2 Interrupt. */
 246   1          #if(USBFS_EP2_ISR_REMOVE == 0u)
 247   1              (void) CyIntSetVector(USBFS_EP_2_VECT_NUM,   &USBFS_EP_2_ISR);
 248   1              CyIntSetPriority(USBFS_EP_2_VECT_NUM, USBFS_EP_2_PRIOR);
 249   1          #endif   /*  USBFS_EP2_ISR_REMOVE */
 250   1      
 251   1          /* Set the Data Endpoint 3 Interrupt. */
 252   1          #if(USBFS_EP3_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USBFS_EP_3_VECT_NUM,   &USBFS_EP_3_ISR);
                      CyIntSetPriority(USBFS_EP_3_VECT_NUM, USBFS_EP_3_PRIOR);
                  #endif   /*  USBFS_EP3_ISR_REMOVE */
 256   1      
 257   1          /* Set the Data Endpoint 4 Interrupt. */
 258   1          #if(USBFS_EP4_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USBFS_EP_4_VECT_NUM,   &USBFS_EP_4_ISR);
                      CyIntSetPriority(USBFS_EP_4_VECT_NUM, USBFS_EP_4_PRIOR);
                  #endif   /*  USBFS_EP4_ISR_REMOVE */
 262   1      
 263   1          /* Set the Data Endpoint 5 Interrupt. */
 264   1          #if(USBFS_EP5_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USBFS_EP_5_VECT_NUM,   &USBFS_EP_5_ISR);
                      CyIntSetPriority(USBFS_EP_5_VECT_NUM, USBFS_EP_5_PRIOR);
                  #endif   /*  USBFS_EP5_ISR_REMOVE */
 268   1      
 269   1          /* Set the Data Endpoint 6 Interrupt. */
 270   1          #if(USBFS_EP6_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USBFS_EP_6_VECT_NUM,   &USBFS_EP_6_ISR);
                      CyIntSetPriority(USBFS_EP_6_VECT_NUM, USBFS_EP_6_PRIOR);
                  #endif   /*  USBFS_EP6_ISR_REMOVE */
 274   1      
 275   1           /* Set the Data Endpoint 7 Interrupt. */
 276   1          #if(USBFS_EP7_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USBFS_EP_7_VECT_NUM,   &USBFS_EP_7_ISR);
                      CyIntSetPriority(USBFS_EP_7_VECT_NUM, USBFS_EP_7_PRIOR);
                  #endif   /*  USBFS_EP7_ISR_REMOVE */
 280   1      
 281   1          /* Set the Data Endpoint 8 Interrupt. */
 282   1          #if(USBFS_EP8_ISR_REMOVE == 0u)
                      (void) CyIntSetVector(USBFS_EP_8_VECT_NUM,   &USBFS_EP_8_ISR);
                      CyIntSetPriority(USBFS_EP_8_VECT_NUM, USBFS_EP_8_PRIOR);
                  #endif   /*  USBFS_EP8_ISR_REMOVE */
 286   1      
 287   1          #if((USBFS_EP_MM != USBFS__EP_MANUAL) && (USBFS_ARB_ISR_REMOVE == 0u))
                      /* Set the ARB Interrupt. */
                      (void) CyIntSetVector(USBFS_ARB_VECT_NUM,   &USBFS_ARB_ISR);
                      CyIntSetPriority(USBFS_ARB_VECT_NUM, USBFS_ARB_PRIOR);
                  #endif   /*  USBFS_EP_MM != USBFS__EP_MANUAL */
 292   1      
 293   1      }
 294          
 295          
 296          /*******************************************************************************
 297          * Function Name: USBFS_InitComponent
 298          ********************************************************************************
 299          *
 300          * Summary:
 301          *  Initialize the component, except for the HW which is done one time in
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 6   

 302          *  the Start function.  This function pulls up D+.
 303          *
 304          * Parameters:
 305          *  device: Contains the device number of the desired device descriptor.
 306          *          The device number can be found in the Device Descriptor Tab of
 307          *          "Configure" dialog, under the settings of desired Device Descriptor,
 308          *          in the "Device Number" field.
 309          *  mode: The operating voltage. This determines whether the voltage regulator
 310          *        is enabled for 5V operation or if pass through mode is used for 3.3V
 311          *        operation. Symbolic names and their associated values are given in the
 312          *        following table.
 313          *       USBFS_3V_OPERATION - Disable voltage regulator and pass-thru
 314          *                                       Vcc for pull-up
 315          *       USBFS_5V_OPERATION - Enable voltage regulator and use
 316          *                                       regulator for pull-up
 317          *       USBFS_DWR_VDDD_OPERATION - Enable or Disable voltage
 318          *                         regulator depend on Vddd Voltage configuration in DWR.
 319          *
 320          * Return:
 321          *   None.
 322          *
 323          * Global variables:
 324          *   USBFS_device: Contains the device number of the desired device
 325          *       descriptor. The device number can be found in the Device Descriptor Tab
 326          *       of "Configure" dialog, under the settings of desired Device Descriptor,
 327          *       in the "Device Number" field.
 328          *   USBFS_transferState: This variable used by the communication
 329          *       functions to handle current transfer state. Initialized to
 330          *       TRANS_STATE_IDLE in this API.
 331          *   USBFS_configuration: Contains current configuration number
 332          *       which is set by the Host using SET_CONFIGURATION request.
 333          *       Initialized to zero in this API.
 334          *   USBFS_deviceAddress: Contains current device address. This
 335          *       variable is initialized to zero in this API. Host starts to communicate
 336          *      to device with address 0 and then set it to whatever value using
 337          *      SET_ADDRESS request.
 338          *   USBFS_deviceStatus: initialized to 0.
 339          *       This is two bit variable which contain power status in first bit
 340          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and remote
 341          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in second bit.
 342          *   USBFS_lastPacketSize initialized to 0;
 343          *
 344          * Reentrant:
 345          *  No.
 346          *
 347          *******************************************************************************/
 348          void USBFS_InitComponent(uint8 device, uint8 mode) 
 349          {
 350   1          /* Initialize _hidProtocol variable to comply with
 351   1          *  HID 7.2.6 Set_Protocol Request:
 352   1          *  "When initialized, all devices default to report protocol."
 353   1          */
 354   1          #if defined(USBFS_ENABLE_HID_CLASS)
 355   1              uint8 i;
 356   1      
 357   1              for (i = 0u; i < USBFS_MAX_INTERFACES_NUMBER; i++)
 358   1              {
 359   2                  USBFS_hidProtocol[i] = USBFS_PROTOCOL_REPORT;
 360   2              }
 361   1          #endif /* USBFS_ENABLE_HID_CLASS */
 362   1      
 363   1          /* Enable Interrupts. */
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 7   

 364   1          CyIntEnable(USBFS_BUS_RESET_VECT_NUM);
 365   1          CyIntEnable(USBFS_EP_0_VECT_NUM);
 366   1          #if(USBFS_EP1_ISR_REMOVE == 0u)
 367   1              CyIntEnable(USBFS_EP_1_VECT_NUM);
 368   1          #endif   /*  USBFS_EP1_ISR_REMOVE */
 369   1          #if(USBFS_EP2_ISR_REMOVE == 0u)
 370   1              CyIntEnable(USBFS_EP_2_VECT_NUM);
 371   1          #endif   /*  USBFS_EP2_ISR_REMOVE */
 372   1          #if(USBFS_EP3_ISR_REMOVE == 0u)
                      CyIntEnable(USBFS_EP_3_VECT_NUM);
                  #endif   /*  USBFS_EP3_ISR_REMOVE */
 375   1          #if(USBFS_EP4_ISR_REMOVE == 0u)
                      CyIntEnable(USBFS_EP_4_VECT_NUM);
                  #endif   /*  USBFS_EP4_ISR_REMOVE */
 378   1          #if(USBFS_EP5_ISR_REMOVE == 0u)
                      CyIntEnable(USBFS_EP_5_VECT_NUM);
                  #endif   /*  USBFS_EP5_ISR_REMOVE */
 381   1          #if(USBFS_EP6_ISR_REMOVE == 0u)
                      CyIntEnable(USBFS_EP_6_VECT_NUM);
                  #endif   /*  USBFS_EP6_ISR_REMOVE */
 384   1          #if(USBFS_EP7_ISR_REMOVE == 0u)
                      CyIntEnable(USBFS_EP_7_VECT_NUM);
                  #endif   /*  USBFS_EP7_ISR_REMOVE */
 387   1          #if(USBFS_EP8_ISR_REMOVE == 0u)
                      CyIntEnable(USBFS_EP_8_VECT_NUM);
                  #endif   /*  USBFS_EP8_ISR_REMOVE */
 390   1          #if((USBFS_EP_MM != USBFS__EP_MANUAL) && (USBFS_ARB_ISR_REMOVE == 0u))
                      /* usb arb interrupt enable */
                      USBFS_ARB_INT_EN_REG = USBFS_ARB_INT_MASK;
                      CyIntEnable(USBFS_ARB_VECT_NUM);
                  #endif   /*  USBFS_EP_MM != USBFS__EP_MANUAL */
 395   1      
 396   1          /* Arbiter configuration for DMA transfers */
 397   1          #if(USBFS_EP_MM != USBFS__EP_MANUAL)
                      #if(USBFS_EP_MM == USBFS__EP_DMAMANUAL)
                          USBFS_ARB_CFG_REG = USBFS_ARB_CFG_MANUAL_DMA;
                      #endif   /*  USBFS_EP_MM == USBFS__EP_DMAMANUAL */
                      #if(USBFS_EP_MM == USBFS__EP_DMAAUTO)
                          /*Set cfg cmplt this rises DMA request when the full configuration is done */
                          USBFS_ARB_CFG_REG = USBFS_ARB_CFG_AUTO_DMA | USBFS_ARB_CFG_AUTO_MEM;
                          #if(USBFS_EP_DMA_AUTO_OPT == 0u)
                              /* Init interrupt which handles verification of the successful DMA transaction */
                              USBFS_EP_DMA_Done_isr_StartEx(&USBFS_EP_DMA_DONE_ISR);
                              USBFS_EP17_DMA_Done_SR_InterruptEnable();
                              USBFS_EP8_DMA_Done_SR_InterruptEnable();
                          #endif /* USBFS_EP_DMA_AUTO_OPT == 0u */
                      #endif   /*  USBFS_EP_MM == USBFS__EP_DMAAUTO */
                  #endif   /*  USBFS_EP_MM != USBFS__EP_MANUAL */
 412   1      
 413   1          USBFS_transferState = USBFS_TRANS_STATE_IDLE;
 414   1      
 415   1          /* USB Locking: Enabled, VRegulator: depend on mode or DWR Voltage configuration*/
 416   1          switch(mode)
 417   1          {
 418   2              case USBFS_3V_OPERATION:
 419   2                  USBFS_CR1_REG = USBFS_CR1_ENABLE_LOCK;
 420   2                  break;
 421   2              case USBFS_5V_OPERATION:
 422   2                  USBFS_CR1_REG = USBFS_CR1_ENABLE_LOCK | USBFS_CR1_REG_ENABLE;
 423   2                  break;
 424   2              default:   /*USBFS_DWR_VDDD_OPERATION */
 425   2                  #if(USBFS_VDDD_MV < USBFS_3500MV)
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 8   

                              USBFS_CR1_REG = USBFS_CR1_ENABLE_LOCK;
                          #else
 428   2                      USBFS_CR1_REG = USBFS_CR1_ENABLE_LOCK | USBFS_CR1_REG_ENABLE;
 429   2                  #endif /*  USBFS_VDDD_MV < USBFS_3500MV */
 430   2                  break;
 431   2          }
 432   1      
 433   1          /* Record the descriptor selection */
 434   1          USBFS_device = device;
 435   1      
 436   1          /* Clear all of the component data */
 437   1          USBFS_configuration = 0u;
 438   1          USBFS_interfaceNumber = 0u;
 439   1          USBFS_configurationChanged = 0u;
 440   1          USBFS_deviceAddress  = 0u;
 441   1          USBFS_deviceStatus = 0u;
 442   1      
 443   1          USBFS_lastPacketSize = 0u;
 444   1      
 445   1          /*  ACK Setup, Stall IN/OUT */
 446   1          CY_SET_REG8(USBFS_EP0_CR_PTR, USBFS_MODE_STALL_IN_OUT);
 447   1      
 448   1          /* Enable the SIE with an address 0 */
 449   1          CY_SET_REG8(USBFS_CR0_PTR, USBFS_CR0_ENABLE);
 450   1      
 451   1          /* Workaround for PSOC5LP */
 452   1          CyDelayCycles(1u);
 453   1      
 454   1          /* Finally, Enable d+ pullup and select iomode to USB mode*/
 455   1          CY_SET_REG8(USBFS_USBIO_CR1_PTR, USBFS_USBIO_CR1_USBPUEN);
 456   1      }
 457          
 458          
 459          /*******************************************************************************
 460          * Function Name: USBFS_ReInitComponent
 461          ********************************************************************************
 462          *
 463          * Summary:
 464          *  This function reinitialize the component configuration and is
 465          *  intend to be called from the Reset interrupt.
 466          *
 467          * Parameters:
 468          *  None.
 469          *
 470          * Return:
 471          *   None.
 472          *
 473          * Global variables:
 474          *   USBFS_device: Contains the device number of the desired device
 475          *        descriptor. The device number can be found in the Device Descriptor Tab
 476          *       of "Configure" dialog, under the settings of desired Device Descriptor,
 477          *       in the "Device Number" field.
 478          *   USBFS_transferState: This variable used by the communication
 479          *       functions to handle current transfer state. Initialized to
 480          *       TRANS_STATE_IDLE in this API.
 481          *   USBFS_configuration: Contains current configuration number
 482          *       which is set by the Host using SET_CONFIGURATION request.
 483          *       Initialized to zero in this API.
 484          *   USBFS_deviceAddress: Contains current device address. This
 485          *       variable is initialized to zero in this API. Host starts to communicate
 486          *      to device with address 0 and then set it to whatever value using
 487          *      SET_ADDRESS request.
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 9   

 488          *   USBFS_deviceStatus: initialized to 0.
 489          *       This is two bit variable which contain power status in first bit
 490          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and remote
 491          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in second bit.
 492          *   USBFS_lastPacketSize initialized to 0;
 493          *
 494          * Reentrant:
 495          *  No.
 496          *
 497          *******************************************************************************/
 498          void USBFS_ReInitComponent(void) 
 499          {
 500   1          /* Initialize _hidProtocol variable to comply with HID 7.2.6 Set_Protocol
 501   1          *  Request: "When initialized, all devices default to report protocol."
 502   1          */
 503   1          #if defined(USBFS_ENABLE_HID_CLASS)
 504   1              uint8 i;
 505   1      
 506   1              for (i = 0u; i < USBFS_MAX_INTERFACES_NUMBER; i++)
 507   1              {
 508   2                  USBFS_hidProtocol[i] = USBFS_PROTOCOL_REPORT;
 509   2              }
 510   1          #endif /* USBFS_ENABLE_HID_CLASS */
 511   1      
 512   1          USBFS_transferState = USBFS_TRANS_STATE_IDLE;
 513   1      
 514   1          /* Clear all of the component data */
 515   1          USBFS_configuration = 0u;
 516   1          USBFS_interfaceNumber = 0u;
 517   1          USBFS_configurationChanged = 0u;
 518   1          USBFS_deviceAddress  = 0u;
 519   1          USBFS_deviceStatus = 0u;
 520   1      
 521   1          USBFS_lastPacketSize = 0u;
 522   1      
 523   1      
 524   1          /*  ACK Setup, Stall IN/OUT */
 525   1          CY_SET_REG8(USBFS_EP0_CR_PTR, USBFS_MODE_STALL_IN_OUT);
 526   1      
 527   1          /* Enable the SIE with an address 0 */
 528   1          CY_SET_REG8(USBFS_CR0_PTR, USBFS_CR0_ENABLE);
 529   1      
 530   1      }
 531          
 532          
 533          /*******************************************************************************
 534          * Function Name: USBFS_Stop
 535          ********************************************************************************
 536          *
 537          * Summary:
 538          *  This function shuts down the USB function including to release
 539          *  the D+ Pullup and disabling the SIE.
 540          *
 541          * Parameters:
 542          *  None.
 543          *
 544          * Return:
 545          *  None.
 546          *
 547          * Global variables:
 548          *   USBFS_configuration: Contains current configuration number
 549          *       which is set by the Host using SET_CONFIGURATION request.
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 10  

 550          *       Initialized to zero in this API.
 551          *   USBFS_deviceAddress: Contains current device address. This
 552          *       variable is initialized to zero in this API. Host starts to communicate
 553          *      to device with address 0 and then set it to whatever value using
 554          *      SET_ADDRESS request.
 555          *   USBFS_deviceStatus: initialized to 0.
 556          *       This is two bit variable which contain power status in first bit
 557          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and remote
 558          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in second bit.
 559          *   USBFS_configurationChanged: This variable is set to one after
 560          *       SET_CONFIGURATION request and cleared in this function.
 561          *   USBFS_intiVar variable is set to zero
 562          *
 563          *******************************************************************************/
 564          void USBFS_Stop(void) 
 565          {
 566   1      
 567   1          #if(USBFS_EP_MM != USBFS__EP_MANUAL)
                      USBFS_Stop_DMA(USBFS_MAX_EP);     /* Stop all DMAs */
                  #endif   /*  USBFS_EP_MM != USBFS__EP_MANUAL */
 570   1      
 571   1          /* Disable the SIE */
 572   1          USBFS_CR0_REG &= (uint8)(~USBFS_CR0_ENABLE);
 573   1          /* Disable the d+ pullup */
 574   1          USBFS_USBIO_CR1_REG &= (uint8)(~USBFS_USBIO_CR1_USBPUEN);
 575   1          /* Disable USB in ACT PM */
 576   1          USBFS_PM_ACT_CFG_REG &= (uint8)(~USBFS_PM_ACT_EN_FSUSB);
 577   1          /* Disable USB block for Standby Power Mode */
 578   1          USBFS_PM_STBY_CFG_REG &= (uint8)(~USBFS_PM_STBY_EN_FSUSB);
 579   1      
 580   1          /* Disable the reset and EP interrupts */
 581   1          CyIntDisable(USBFS_BUS_RESET_VECT_NUM);
 582   1          CyIntDisable(USBFS_EP_0_VECT_NUM);
 583   1          #if(USBFS_EP1_ISR_REMOVE == 0u)
 584   1              CyIntDisable(USBFS_EP_1_VECT_NUM);
 585   1          #endif   /*  USBFS_EP1_ISR_REMOVE */
 586   1          #if(USBFS_EP2_ISR_REMOVE == 0u)
 587   1              CyIntDisable(USBFS_EP_2_VECT_NUM);
 588   1          #endif   /*  USBFS_EP2_ISR_REMOVE */
 589   1          #if(USBFS_EP3_ISR_REMOVE == 0u)
                      CyIntDisable(USBFS_EP_3_VECT_NUM);
                  #endif   /*  USBFS_EP3_ISR_REMOVE */
 592   1          #if(USBFS_EP4_ISR_REMOVE == 0u)
                      CyIntDisable(USBFS_EP_4_VECT_NUM);
                  #endif   /*  USBFS_EP4_ISR_REMOVE */
 595   1          #if(USBFS_EP5_ISR_REMOVE == 0u)
                      CyIntDisable(USBFS_EP_5_VECT_NUM);
                  #endif   /*  USBFS_EP5_ISR_REMOVE */
 598   1          #if(USBFS_EP6_ISR_REMOVE == 0u)
                      CyIntDisable(USBFS_EP_6_VECT_NUM);
                  #endif   /*  USBFS_EP6_ISR_REMOVE */
 601   1          #if(USBFS_EP7_ISR_REMOVE == 0u)
                      CyIntDisable(USBFS_EP_7_VECT_NUM);
                  #endif   /*  USBFS_EP7_ISR_REMOVE */
 604   1          #if(USBFS_EP8_ISR_REMOVE == 0u)
                      CyIntDisable(USBFS_EP_8_VECT_NUM);
                  #endif   /*  USBFS_EP8_ISR_REMOVE */
 607   1      
 608   1          /* Clear all of the component data */
 609   1          USBFS_configuration = 0u;
 610   1          USBFS_interfaceNumber = 0u;
 611   1          USBFS_configurationChanged = 0u;
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 11  

 612   1          USBFS_deviceAddress  = 0u;
 613   1          USBFS_deviceStatus = 0u;
 614   1          USBFS_initVar = 0u;
 615   1      
 616   1      }
 617          
 618          
 619          /*******************************************************************************
 620          * Function Name: USBFS_CheckActivity
 621          ********************************************************************************
 622          *
 623          * Summary:
 624          *  Returns the activity status of the bus.  Clears the status hardware to
 625          *  provide fresh activity status on the next call of this routine.
 626          *
 627          * Parameters:
 628          *  None.
 629          *
 630          * Return:
 631          *  1 - If bus activity was detected since the last call to this function
 632          *  0 - If bus activity not was detected since the last call to this function
 633          *
 634          *******************************************************************************/
 635          uint8 USBFS_CheckActivity(void) 
 636          {
 637   1          uint8 r;
 638   1      
 639   1          r = CY_GET_REG8(USBFS_CR1_PTR);
 640   1          CY_SET_REG8(USBFS_CR1_PTR, (r & ((uint8)(~USBFS_CR1_BUS_ACTIVITY))));
 641   1      
 642   1          return((r & USBFS_CR1_BUS_ACTIVITY) >> USBFS_CR1_BUS_ACTIVITY_SHIFT);
 643   1      }
 644          
 645          
 646          /*******************************************************************************
 647          * Function Name: USBFS_GetConfiguration
 648          ********************************************************************************
 649          *
 650          * Summary:
 651          *  Returns the current configuration setting
 652          *
 653          * Parameters:
 654          *  None.
 655          *
 656          * Return:
 657          *  configuration.
 658          *
 659          *******************************************************************************/
 660          uint8 USBFS_GetConfiguration(void) 
 661          {
 662   1          return(USBFS_configuration);
 663   1      }
 664          
 665          
 666          /*******************************************************************************
 667          * Function Name: USBFS_IsConfigurationChanged
 668          ********************************************************************************
 669          *
 670          * Summary:
 671          *  Returns the clear on read configuration state. It is usefull when PC send
 672          *  double SET_CONFIGURATION request with same configuration number.
 673          *
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 12  

 674          * Parameters:
 675          *  None.
 676          *
 677          * Return:
 678          *  Not zero value when new configuration has been changed, otherwise zero is
 679          *  returned.
 680          *
 681          * Global variables:
 682          *   USBFS_configurationChanged: This variable is set to one after
 683          *       SET_CONFIGURATION request and cleared in this function.
 684          *
 685          *******************************************************************************/
 686          uint8 USBFS_IsConfigurationChanged(void) 
 687          {
 688   1          uint8 res = 0u;
 689   1      
 690   1          if(USBFS_configurationChanged != 0u)
 691   1          {
 692   2              res = USBFS_configurationChanged;
 693   2              USBFS_configurationChanged = 0u;
 694   2          }
 695   1      
 696   1          return(res);
 697   1      }
 698          
 699          
 700          /*******************************************************************************
 701          * Function Name: USBFS_GetInterfaceSetting
 702          ********************************************************************************
 703          *
 704          * Summary:
 705          *  Returns the alternate setting from current interface
 706          *
 707          * Parameters:
 708          *  uint8 interfaceNumber, interface number
 709          *
 710          * Return:
 711          *  Alternate setting.
 712          *
 713          *******************************************************************************/
 714          uint8  USBFS_GetInterfaceSetting(uint8 interfaceNumber)
 715                                                              
 716          {
 717   1          return(USBFS_interfaceSetting[interfaceNumber]);
 718   1      }
 719          
 720          
 721          /*******************************************************************************
 722          * Function Name: USBFS_GetEPState
 723          ********************************************************************************
 724          *
 725          * Summary:
 726          *  Returned the state of the requested endpoint.
 727          *
 728          * Parameters:
 729          *  epNumber: Endpoint Number
 730          *
 731          * Return:
 732          *  State of the requested endpoint.
 733          *
 734          *******************************************************************************/
 735          uint8 USBFS_GetEPState(uint8 epNumber) 
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 13  

 736          {
 737   1          return(USBFS_EP[epNumber].apiEpState);
 738   1      }
 739          
 740          
 741          /*******************************************************************************
 742          * Function Name: USBFS_GetEPCount
 743          ********************************************************************************
 744          *
 745          * Summary:
 746          *  This function supports Data Endpoints only(EP1-EP8).
 747          *  Returns the transfer count for the requested endpoint.  The value from
 748          *  the count registers includes 2 counts for the two byte checksum of the
 749          *  packet.  This function subtracts the two counts.
 750          *
 751          * Parameters:
 752          *  epNumber: Data Endpoint Number.
 753          *            Valid values are between 1 and 8.
 754          *
 755          * Return:
 756          *  Returns the current byte count from the specified endpoint or 0 for an
 757          *  invalid endpoint.
 758          *
 759          *******************************************************************************/
 760          uint16 USBFS_GetEPCount(uint8 epNumber) 
 761          {
 762   1          uint8 ri;
 763   1          uint16 result = 0u;
 764   1      
 765   1          if((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
 766   1          {
 767   2              ri = ((epNumber - USBFS_EP1) << USBFS_EPX_CNTX_ADDR_SHIFT);
 768   2      
 769   2              result = (uint8)(CY_GET_REG8((reg8 *)(USBFS_SIE_EP1_CNT0_IND + ri)) &
 770   2                                USBFS_EPX_CNT0_MASK);
 771   2              result = (result << 8u) | CY_GET_REG8((reg8 *)(USBFS_SIE_EP1_CNT1_IND + ri));
 772   2              result -= USBFS_EPX_CNTX_CRC_COUNT;
 773   2          }
 774   1          return(result);
 775   1      }
 776          
 777          
 778          #if(USBFS_EP_MM != USBFS__EP_MANUAL)
              
              
                  /*******************************************************************************
                  * Function Name: USBFS_InitEP_DMA
                  ********************************************************************************
                  *
                  * Summary:
                  *  This function allocates and initializes a DMA channel to be used by the
                  *  USBFS_LoadInEP() or USBFS_ReadOutEP() APIs for data
                  *  transfer.
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number.
                  *            Valid values are between 1 and 8.
                  *  *pData: Pointer to a data array that is related to the EP transfers.
                  *
                  * Return:
                  *  None.
                  *
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 14  

                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  void USBFS_InitEP_DMA(uint8 epNumber, const uint8* pData)
                                                                                  
                  {
                      uint16 src;
                      uint16 dst;
                      #if (CY_PSOC3)                  /* PSoC 3 */
                          src = HI16(CYDEV_SRAM_BASE);
                          dst = HI16(CYDEV_PERIPH_BASE);
                          pData = pData;
                      #else                           /* PSoC 5 */
                          if((USBFS_EP[epNumber].addr & USBFS_DIR_IN) != 0u )
                          {   /* for the IN EP source is the SRAM memory buffer */
                              src = HI16(pData);
                              dst = HI16(CYDEV_PERIPH_BASE);
                          }
                          else
                          {   /* for the OUT EP source is the SIE register */
                              src = HI16(CYDEV_PERIPH_BASE);
                              dst = HI16(pData);
                          }
                      #endif  /*  C51 */
                      switch(epNumber)
                      {
                          case USBFS_EP1:
                              #if(USBFS_DMA1_REMOVE == 0u)
                                  USBFS_DmaChan[epNumber] = USBFS_ep1_DmaInitialize(
                                      USBFS_DMA_BYTES_PER_BURST, USBFS_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBFS_DMA1_REMOVE */
                              break;
                          case USBFS_EP2:
                              #if(USBFS_DMA2_REMOVE == 0u)
                                  USBFS_DmaChan[epNumber] = USBFS_ep2_DmaInitialize(
                                      USBFS_DMA_BYTES_PER_BURST, USBFS_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBFS_DMA2_REMOVE */
                              break;
                          case USBFS_EP3:
                              #if(USBFS_DMA3_REMOVE == 0u)
                                  USBFS_DmaChan[epNumber] = USBFS_ep3_DmaInitialize(
                                      USBFS_DMA_BYTES_PER_BURST, USBFS_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBFS_DMA3_REMOVE */
                              break;
                          case USBFS_EP4:
                              #if(USBFS_DMA4_REMOVE == 0u)
                                  USBFS_DmaChan[epNumber] = USBFS_ep4_DmaInitialize(
                                      USBFS_DMA_BYTES_PER_BURST, USBFS_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBFS_DMA4_REMOVE */
                              break;
                          case USBFS_EP5:
                              #if(USBFS_DMA5_REMOVE == 0u)
                                  USBFS_DmaChan[epNumber] = USBFS_ep5_DmaInitialize(
                                      USBFS_DMA_BYTES_PER_BURST, USBFS_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBFS_DMA5_REMOVE */
                              break;
                          case USBFS_EP6:
                              #if(USBFS_DMA6_REMOVE == 0u)
                                  USBFS_DmaChan[epNumber] = USBFS_ep6_DmaInitialize(
                                      USBFS_DMA_BYTES_PER_BURST, USBFS_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBFS_DMA6_REMOVE */
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 15  

                              break;
                          case USBFS_EP7:
                              #if(USBFS_DMA7_REMOVE == 0u)
                                  USBFS_DmaChan[epNumber] = USBFS_ep7_DmaInitialize(
                                      USBFS_DMA_BYTES_PER_BURST, USBFS_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBFS_DMA7_REMOVE */
                              break;
                          case USBFS_EP8:
                              #if(USBFS_DMA8_REMOVE == 0u)
                                  USBFS_DmaChan[epNumber] = USBFS_ep8_DmaInitialize(
                                      USBFS_DMA_BYTES_PER_BURST, USBFS_DMA_REQUEST_PER_BURST, src, dst);
                              #endif   /*  USBFS_DMA8_REMOVE */
                              break;
                          default:
                              /* Do not support EP0 DMA transfers */
                              break;
                      }
                      if((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
                      {
                          USBFS_DmaTd[epNumber] = CyDmaTdAllocate();
                          #if ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u))
                              USBFS_DmaNextTd[epNumber] = CyDmaTdAllocate();
                          #endif /*  ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u)) */
              
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: USBFS_Stop_DMA
                  ********************************************************************************
                  *
                  * Summary: Stops and free DMA
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number or
                  *           USBFS_MAX_EP to stop all DMAs
                  *
                  * Return:
                  *  None.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  void USBFS_Stop_DMA(uint8 epNumber) 
                  {
                      uint8 i;
                      i = (epNumber < USBFS_MAX_EP) ? epNumber : USBFS_EP1;
                      do
                      {
                          if(USBFS_DmaTd[i] != DMA_INVALID_TD)
                          {
                              (void) CyDmaChDisable(USBFS_DmaChan[i]);
                              CyDmaTdFree(USBFS_DmaTd[i]);
                              USBFS_DmaTd[i] = DMA_INVALID_TD;
                          }
                          #if ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u))
                              if(USBFS_DmaNextTd[i] != DMA_INVALID_TD)
                              {
                                  CyDmaTdFree(USBFS_DmaNextTd[i]);
                                  USBFS_DmaNextTd[i] = DMA_INVALID_TD;
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 16  

                              }
                          #endif /* ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u)) */
                          i++;
                      }while((i < USBFS_MAX_EP) && (epNumber == USBFS_MAX_EP));
                  }
              
              #endif /*  USBFS_EP_MM != USBFS__EP_MANUAL */
 929          
 930          
 931          #if ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u))
              
              
                  /*******************************************************************************
                  * Function Name: USBFS_LoadNextInEP
                  ********************************************************************************
                  *
                  * Summary:
                  *  This internal function is used for IN endpoint DMA reconfiguration in
                  *  Auto DMA mode.
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number.
                  *  mode:   0 - Configure DMA to send the the rest of data.
                  *          1 - Configure DMA to repeat 2 last bytes of the first burst.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void USBFS_LoadNextInEP(uint8 epNumber, uint8 mode) 
                  {
                      reg16 *convert;
              
                      if(mode == 0u)
                      {
                          /* Configure DMA to send the the rest of data */
                          /* CyDmaTdSetConfiguration API is optimised to change only transfer length and configure TD */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBFS_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length */
                          CY_SET_REG16(convert, USBFS_inLength[epNumber] - USBFS_DMA_BYTES_PER_BURST);
                          /* CyDmaTdSetAddress API is optimized to change only source address */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBFS_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert, LO16((uint32)USBFS_inDataPointer[epNumber] +
                                                          USBFS_DMA_BYTES_PER_BURST));
                          USBFS_inBufFull[epNumber] = 1u;
                      }
                      else
                      {
                          /* Configure DMA to repeat 2 last bytes of the first burst. */
                          /* CyDmaTdSetConfiguration API is optimised to change only transfer length and configure TD */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBFS_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length */
                          CY_SET_REG16(convert, USBFS_DMA_BYTES_REPEAT);
                          /* CyDmaTdSetAddress API is optimized to change only source address */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USBFS_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert,  LO16((uint32)USBFS_inDataPointer[epNumber] +
                                                 USBFS_DMA_BYTES_PER_BURST - USBFS_DMA_BYTES_REPEAT));
                      }
              
                      /* CyDmaChSetInitialTd API is optimised to init TD */
                      CY_DMA_CH_STRUCT_PTR[USBFS_DmaChan[epNumber]].basic_status[1u] = USBFS_DmaTd[epNumber];
                  }
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 17  

              #endif /* ((USBFS_EP_MM == USBFS__EP_DMAAUTO) && (USBFS_EP_DMA_AUTO_OPT == 0u)) */
 985          
 986          
 987          /*******************************************************************************
 988          * Function Name: USBFS_LoadInEP
 989          ********************************************************************************
 990          *
 991          * Summary:
 992          *  Loads and enables the specified USB data endpoint for an IN transfer.
 993          *
 994          * Parameters:
 995          *  epNumber: Contains the data endpoint number.
 996          *            Valid values are between 1 and 8.
 997          *  *pData: A pointer to a data array from which the data for the endpoint space
 998          *          is loaded.
 999          *  length: The number of bytes to transfer from the array and then send as a
1000          *          result of an IN request. Valid values are between 0 and 512.
1001          *
1002          * Return:
1003          *  None.
1004          *
1005          * Reentrant:
1006          *  No.
1007          *
1008          *******************************************************************************/
1009          void USBFS_LoadInEP(uint8 epNumber, const uint8 pData[], uint16 length)
1010                                                                                  
1011          {
1012   1          uint8 ri;
1013   1          reg8 *p;
1014   1          #if(USBFS_EP_MM == USBFS__EP_MANUAL)
1015   1              uint16 i;
1016   1          #endif /*  USBFS_EP_MM == USBFS__EP_MANUAL */
1017   1      
1018   1          if((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
1019   1          {
1020   2              ri = ((epNumber - USBFS_EP1) << USBFS_EPX_CNTX_ADDR_SHIFT);
1021   2              p = (reg8 *)(USBFS_ARB_RW1_DR_IND + ri);
1022   2      
1023   2              #if(USBFS_EP_MM != USBFS__EP_DMAAUTO)
1024   2                  /* Limits length to available buffer space, auto MM could send packets up to 1024 bytes */
1025   2                  if(length > (USBFS_EPX_DATA_BUF_MAX - USBFS_EP[epNumber].buffOffset))
1026   2                  {
1027   3                      length = USBFS_EPX_DATA_BUF_MAX - USBFS_EP[epNumber].buffOffset;
1028   3                  }
1029   2              #endif /*  USBFS_EP_MM != USBFS__EP_DMAAUTO */
1030   2      
1031   2              /* Set the count and data toggle */
1032   2              CY_SET_REG8((reg8 *)(USBFS_SIE_EP1_CNT0_IND + ri),
1033   2                                  (length >> 8u) | (USBFS_EP[epNumber].epToggle));
1034   2              CY_SET_REG8((reg8 *)(USBFS_SIE_EP1_CNT1_IND + ri),  length & 0xFFu);
1035   2      
1036   2              #if(USBFS_EP_MM == USBFS__EP_MANUAL)
1037   2                  if(pData != NULL)
1038   2                  {
1039   3                      /* Copy the data using the arbiter data register */
1040   3                      for (i = 0u; i < length; i++)
1041   3                      {
1042   4                          CY_SET_REG8(p, pData[i]);
1043   4                      }
1044   3                  }
1045   2                  USBFS_EP[epNumber].apiEpState = USBFS_NO_EVENT_PENDING;
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 18  

1046   2                  /* Write the Mode register */
1047   2                  CY_SET_REG8((reg8 *)(USBFS_SIE_EP1_CR0_IND + ri), USBFS_EP[epNumber].epMode);
1048   2              #else
                          /* Init DMA if it was not initialized */
                          if (USBFS_DmaTd[epNumber] == DMA_INVALID_TD)
                          {
                              USBFS_InitEP_DMA(epNumber, pData);
                          }
                      #endif /*  USBFS_EP_MM == USBFS__EP_MANUAL */
1055   2      
1056   2              #if(USBFS_EP_MM == USBFS__EP_DMAMANUAL)
                          USBFS_EP[epNumber].apiEpState = USBFS_NO_EVENT_PENDING;
                          if ((pData != NULL) && (length > 0u))
                          {
                              /* Enable DMA in mode2 for transferring data */
                              (void) CyDmaChDisable(USBFS_DmaChan[epNumber]);
                              (void) CyDmaTdSetConfiguration(USBFS_DmaTd[epNumber], length, CY_DMA_DISABLE_TD,
                                                                                               TD_TERMIN_EN | TD_INC_SRC
             -_ADR);
                              (void) CyDmaTdSetAddress(USBFS_DmaTd[epNumber],  LO16((uint32)pData), LO16((uint32)p));
                              /* Enable the DMA */
                              (void) CyDmaChSetInitialTd(USBFS_DmaChan[epNumber], USBFS_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USBFS_DmaChan[epNumber], 1u);
                              /* Generate DMA request */
                              * (reg8 *)(USBFS_ARB_EP1_CFG_IND + ri) |= USBFS_ARB_EPX_CFG_DMA_REQ;
                              * (reg8 *)(USBFS_ARB_EP1_CFG_IND + ri) &= ((uint8)(~USBFS_ARB_EPX_CFG_DMA_REQ));
                              /* Mode register will be written in arb ISR after DMA transfer complete */
                          }
                          else
                          {
                              /* When zero-length packet - write the Mode register directly */
                              CY_SET_REG8((reg8 *)(USBFS_SIE_EP1_CR0_IND + ri), USBFS_EP[epNumber].epMode);
                          }
                      #endif /*  USBFS_EP_MM == USBFS__EP_DMAMANUAL */
1079   2      
1080   2              #if(USBFS_EP_MM == USBFS__EP_DMAAUTO)
                          if (pData != NULL)
                          {
                              /* Enable DMA in mode3 for transferring data */
                              (void) CyDmaChDisable(USBFS_DmaChan[epNumber]);
                          #if (USBFS_EP_DMA_AUTO_OPT == 0u)
                              USBFS_inLength[epNumber] = length;
                              USBFS_inDataPointer[epNumber] = pData;
                              /* Configure DMA to send the data only for the first burst */
                              (void) CyDmaTdSetConfiguration(USBFS_DmaTd[epNumber],
                                  (length > USBFS_DMA_BYTES_PER_BURST) ? USBFS_DMA_BYTES_PER_BURST : length,
                                  USBFS_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR);
                              (void) CyDmaTdSetAddress(USBFS_DmaTd[epNumber],  LO16((uint32)pData), LO16((uint32)p));
                              /* The second TD will be executed only when the first one fails.
                              *  The intention of this TD is to generate NRQ interrupt
                              *  and repeat 2 last bytes of the first burst.
                              */
                              (void) CyDmaTdSetConfiguration(USBFS_DmaNextTd[epNumber], 1u,
                                                             USBFS_DmaNextTd[epNumber],
                                                             USBFS_epX_TD_TERMOUT_EN[epNumber]);
                              /* Configure DmaNextTd to clear Data ready status */
                              (void) CyDmaTdSetAddress(USBFS_DmaNextTd[epNumber],  LO16((uint32)&clearInDataRdyStatus),
                                                                              LO16((uint32)(USBFS_ARB_EP1_CFG_IND + ri))
             -);
                          #else /* Configure DMA to send all data*/
                              (void) CyDmaTdSetConfiguration(USBFS_DmaTd[epNumber], length,
                                                             USBFS_DmaTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR);
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 19  

                              (void) CyDmaTdSetAddress(USBFS_DmaTd[epNumber],  LO16((uint32)pData), LO16((uint32)p));
                          #endif /* USBFS_EP_DMA_AUTO_OPT == 0u */
              
                              /* Clear Any potential pending DMA requests before starting the DMA channel to transfer da
             -ta */
                              (void) CyDmaClearPendingDrq(USBFS_DmaChan[epNumber]);
                              /* Enable the DMA */
                              (void) CyDmaChSetInitialTd(USBFS_DmaChan[epNumber], USBFS_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USBFS_DmaChan[epNumber], 1u);
                          }
                          else
                          {
                              USBFS_EP[epNumber].apiEpState = USBFS_NO_EVENT_PENDING;
                              if(length > 0u)
                              {
                              #if (USBFS_EP_DMA_AUTO_OPT == 0u)
                                  USBFS_inLength[epNumber] = length;
                                  USBFS_inBufFull[epNumber] = 0u;
                                  (void) CyDmaChDisable(USBFS_DmaChan[epNumber]);
                                  /* Configure DMA to send the data only for the first burst */
                                  (void) CyDmaTdSetConfiguration(
                                      USBFS_DmaTd[epNumber], (length > USBFS_DMA_BYTES_PER_BURST) ?
                                      USBFS_DMA_BYTES_PER_BURST : length,
                                      USBFS_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR );
                                  (void) CyDmaTdSetAddress(USBFS_DmaTd[epNumber],
                                                           LO16((uint32)USBFS_inDataPointer[epNumber]), LO16((uint32)p))
             -;
                                  /* Clear Any potential pending DMA requests before starting the DMA channel to transfe
             -r data */
                                  (void) CyDmaClearPendingDrq(USBFS_DmaChan[epNumber]);
                                  /* Enable the DMA */
                                  (void) CyDmaChSetInitialTd(USBFS_DmaChan[epNumber], USBFS_DmaTd[epNumber]);
                                  (void) CyDmaChEnable(USBFS_DmaChan[epNumber], 1u);
                              #endif /* (USBFS_EP_DMA_AUTO_OPT == 0u) */
              
                                  /* Set Data ready status, This will generate DMA request */
                                  #ifndef USBFS_MANUAL_IN_EP_ARM
                                      * (reg8 *)(USBFS_ARB_EP1_CFG_IND + ri) |= USBFS_ARB_EPX_CFG_IN_DATA_RDY;
                                  #endif  /* USBFS_MANUAL_IN_EP_ARM */
                                  /* Mode register will be written in arb ISR(In Buffer Full) after first DMA transfer c
             -omplete */
                              }
                              else
                              {
                                  /* When zero-length packet - write the Mode register directly */
                                  CY_SET_REG8((reg8 *)(USBFS_SIE_EP1_CR0_IND + ri), USBFS_EP[epNumber].epMode);
                              }
                          }
                      #endif /*  USBFS_EP_MM == USBFS__EP_DMAAUTO */
1151   2          }
1152   1      }
1153          
1154          
1155          /*******************************************************************************
1156          * Function Name: USBFS_ReadOutEP
1157          ********************************************************************************
1158          *
1159          * Summary:
1160          *  Read data from an endpoint.  The application must call
1161          *  USBFS_GetEPState to see if an event is pending.
1162          *
1163          * Parameters:
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 20  

1164          *  epNumber: Contains the data endpoint number.
1165          *            Valid values are between 1 and 8.
1166          *  pData: A pointer to a data array from which the data for the endpoint space
1167          *         is loaded.
1168          *  length: The number of bytes to transfer from the USB Out endpoint and loads
1169          *          it into data array. Valid values are between 0 and 1023. The function
1170          *          moves fewer than the requested number of bytes if the host sends
1171          *          fewer bytes than requested.
1172          *
1173          * Returns:
1174          *  Number of bytes received, 0 for an invalid endpoint.
1175          *
1176          * Reentrant:
1177          *  No.
1178          *
1179          *******************************************************************************/
1180          uint16 USBFS_ReadOutEP(uint8 epNumber, uint8 pData[], uint16 length)
1181                                                                                  
1182          {
1183   1          uint8 ri;
1184   1          reg8 *p;
1185   1          #if(USBFS_EP_MM == USBFS__EP_MANUAL)
1186   1              uint16 i;
1187   1          #endif /*  USBFS_EP_MM == USBFS__EP_MANUAL */
1188   1          #if(USBFS_EP_MM != USBFS__EP_DMAAUTO)
1189   1              uint16 xferCount;
1190   1          #endif /*  USBFS_EP_MM != USBFS__EP_DMAAUTO */
1191   1      
1192   1          if((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP) && (pData != NULL))
1193   1          {
1194   2              ri = ((epNumber - USBFS_EP1) << USBFS_EPX_CNTX_ADDR_SHIFT);
1195   2              p = (reg8 *)(USBFS_ARB_RW1_DR_IND + ri);
1196   2      
1197   2              #if(USBFS_EP_MM != USBFS__EP_DMAAUTO)
1198   2                  /* Determine which is smaller the requested data or the available data */
1199   2                  xferCount = USBFS_GetEPCount(epNumber);
1200   2                  if (length > xferCount)
1201   2                  {
1202   3                      length = xferCount;
1203   3                  }
1204   2              #endif /*  USBFS_EP_MM != USBFS__EP_DMAAUTO */
1205   2      
1206   2              #if(USBFS_EP_MM == USBFS__EP_MANUAL)
1207   2                  /* Copy the data using the arbiter data register */
1208   2                  for (i = 0u; i < length; i++)
1209   2                  {
1210   3                      pData[i] = CY_GET_REG8(p);
1211   3                  }
1212   2      
1213   2                  /* (re)arming of OUT endpoint */
1214   2                  USBFS_EnableOutEP(epNumber);
1215   2              #else
                          /*Init DMA if it was not initialized */
                          if(USBFS_DmaTd[epNumber] == DMA_INVALID_TD)
                          {
                              USBFS_InitEP_DMA(epNumber, pData);
                          }
              
                      #endif /*  USBFS_EP_MM == USBFS__EP_MANUAL */
1223   2      
1224   2              #if(USBFS_EP_MM == USBFS__EP_DMAMANUAL)
                          /* Enable DMA in mode2 for transferring data */
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 21  

                          (void) CyDmaChDisable(USBFS_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USBFS_DmaTd[epNumber], length, CY_DMA_DISABLE_TD,
                                                                                              TD_TERMIN_EN | TD_INC_DST_
             -ADR);
                          (void) CyDmaTdSetAddress(USBFS_DmaTd[epNumber],  LO16((uint32)p), LO16((uint32)pData));
                          /* Enable the DMA */
                          (void) CyDmaChSetInitialTd(USBFS_DmaChan[epNumber], USBFS_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USBFS_DmaChan[epNumber], 1u);
              
                          /* Generate DMA request */
                          * (reg8 *)(USBFS_ARB_EP1_CFG_IND + ri) |= USBFS_ARB_EPX_CFG_DMA_REQ;
                          * (reg8 *)(USBFS_ARB_EP1_CFG_IND + ri) &= ((uint8)(~USBFS_ARB_EPX_CFG_DMA_REQ));
                          /* Out EP will be (re)armed in arb ISR after transfer complete */
                      #endif /*  USBFS_EP_MM == USBFS__EP_DMAMANUAL */
1239   2      
1240   2              #if(USBFS_EP_MM == USBFS__EP_DMAAUTO)
                          /* Enable DMA in mode3 for transferring data */
                          (void) CyDmaChDisable(USBFS_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USBFS_DmaTd[epNumber], length, USBFS_DmaTd[epNumber],
                                                                                              TD_TERMIN_EN | TD_INC_DST_
             -ADR);
                          (void) CyDmaTdSetAddress(USBFS_DmaTd[epNumber],  LO16((uint32)p), LO16((uint32)pData));
              
                          /* Clear Any potential pending DMA requests before starting the DMA channel to transfer data *
             -/
                          (void) CyDmaClearPendingDrq(USBFS_DmaChan[epNumber]);
                          /* Enable the DMA */
                          (void) CyDmaChSetInitialTd(USBFS_DmaChan[epNumber], USBFS_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USBFS_DmaChan[epNumber], 1u);
                          /* Out EP will be (re)armed in arb ISR after transfer complete */
                      #endif /*  USBFS_EP_MM == USBFS__EP_DMAAUTO */
1254   2      
1255   2          }
1256   1          else
1257   1          {
1258   2              length = 0u;
1259   2          }
1260   1      
1261   1          return(length);
1262   1      }
1263          
1264          
1265          /*******************************************************************************
1266          * Function Name: USBFS_EnableOutEP
1267          ********************************************************************************
1268          *
1269          * Summary:
1270          *  This function enables an OUT endpoint.  It should not be
1271          *  called for an IN endpoint.
1272          *
1273          * Parameters:
1274          *  epNumber: Endpoint Number
1275          *            Valid values are between 1 and 8.
1276          *
1277          * Return:
1278          *   None.
1279          *
1280          * Global variables:
1281          *  USBFS_EP[epNumber].apiEpState - set to NO_EVENT_PENDING
1282          *
1283          * Reentrant:
1284          *  No.
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 22  

1285          *
1286          *******************************************************************************/
1287          void USBFS_EnableOutEP(uint8 epNumber) 
1288          {
1289   1          uint8 ri;
1290   1      
1291   1          if((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
1292   1          {
1293   2              ri = ((epNumber - USBFS_EP1) << USBFS_EPX_CNTX_ADDR_SHIFT);
1294   2              USBFS_EP[epNumber].apiEpState = USBFS_NO_EVENT_PENDING;
1295   2              /* Write the Mode register */
1296   2              CY_SET_REG8((reg8 *)(USBFS_SIE_EP1_CR0_IND + ri), USBFS_EP[epNumber].epMode);
1297   2          }
1298   1      }
1299          
1300          
1301          /*******************************************************************************
1302          * Function Name: USBFS_DisableOutEP
1303          ********************************************************************************
1304          *
1305          * Summary:
1306          *  This function disables an OUT endpoint.  It should not be
1307          *  called for an IN endpoint.
1308          *
1309          * Parameters:
1310          *  epNumber: Endpoint Number
1311          *            Valid values are between 1 and 8.
1312          *
1313          * Return:
1314          *  None.
1315          *
1316          *******************************************************************************/
1317          void USBFS_DisableOutEP(uint8 epNumber) 
1318          {
1319   1          uint8 ri ;
1320   1      
1321   1          if((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
1322   1          {
1323   2              ri = ((epNumber - USBFS_EP1) << USBFS_EPX_CNTX_ADDR_SHIFT);
1324   2              /* Write the Mode register */
1325   2              CY_SET_REG8((reg8 *)(USBFS_SIE_EP1_CR0_IND + ri), USBFS_MODE_NAK_OUT);
1326   2          }
1327   1      }
1328          
1329          
1330          /*******************************************************************************
1331          * Function Name: USBFS_Force
1332          ********************************************************************************
1333          *
1334          * Summary:
1335          *  Forces the bus state
1336          *
1337          * Parameters:
1338          *  bState
1339          *    USBFS_FORCE_J
1340          *    USBFS_FORCE_K
1341          *    USBFS_FORCE_SE0
1342          *    USBFS_FORCE_NONE
1343          *
1344          * Return:
1345          *  None.
1346          *
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 23  

1347          *******************************************************************************/
1348          void USBFS_Force(uint8 bState) 
1349          {
1350   1          CY_SET_REG8(USBFS_USBIO_CR0_PTR, bState);
1351   1      }
1352          
1353          
1354          /*******************************************************************************
1355          * Function Name: USBFS_GetEPAckState
1356          ********************************************************************************
1357          *
1358          * Summary:
1359          *  Returns the ACK of the CR0 Register (ACKD)
1360          *
1361          * Parameters:
1362          *  epNumber: Endpoint Number
1363          *            Valid values are between 1 and 8.
1364          *
1365          * Returns
1366          *  0 if nothing has been ACKD, non-=zero something has been ACKD
1367          *
1368          *******************************************************************************/
1369          uint8 USBFS_GetEPAckState(uint8 epNumber) 
1370          {
1371   1          uint8 ri;
1372   1          uint8 cr = 0u;
1373   1      
1374   1          if((epNumber > USBFS_EP0) && (epNumber < USBFS_MAX_EP))
1375   1          {
1376   2              ri = ((epNumber - USBFS_EP1) << USBFS_EPX_CNTX_ADDR_SHIFT);
1377   2              cr = CY_GET_REG8((reg8 *)(USBFS_SIE_EP1_CR0_IND + ri)) & USBFS_MODE_ACKD;
1378   2          }
1379   1      
1380   1          return(cr);
1381   1      }
1382          
1383          
1384          /*******************************************************************************
1385          * Function Name: USBFS_SetPowerStatus
1386          ********************************************************************************
1387          *
1388          * Summary:
1389          *  Sets the device power status for reporting in the Get Device Status
1390          *  request
1391          *
1392          * Parameters:
1393          *  powerStatus: USBFS_DEVICE_STATUS_BUS_POWERED(0) - Bus Powered,
1394          *               USBFS_DEVICE_STATUS_SELF_POWERED(1) - Self Powered
1395          *
1396          * Return:
1397          *   None.
1398          *
1399          * Global variables:
1400          *  USBFS_deviceStatus - set power status
1401          *
1402          * Reentrant:
1403          *  No.
1404          *
1405          *******************************************************************************/
1406          void USBFS_SetPowerStatus(uint8 powerStatus) 
1407          {
1408   1          if (powerStatus != USBFS_DEVICE_STATUS_BUS_POWERED)
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 24  

1409   1          {
1410   2              USBFS_deviceStatus |=  USBFS_DEVICE_STATUS_SELF_POWERED;
1411   2          }
1412   1          else
1413   1          {
1414   2              USBFS_deviceStatus &=  ((uint8)(~USBFS_DEVICE_STATUS_SELF_POWERED));
1415   2          }
1416   1      }
1417          
1418          
1419          #if (USBFS_MON_VBUS == 1u)
              
                  /*******************************************************************************
                  * Function Name: USBFS_VBusPresent
                  ********************************************************************************
                  *
                  * Summary:
                  *  Determines VBUS presence for Self Powered Devices.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  1 if VBUS is present, otherwise 0.
                  *
                  *******************************************************************************/
                  uint8 USBFS_VBusPresent(void) 
                  {
                      return((0u != (CY_GET_REG8(USBFS_VBUS_PS_PTR) & USBFS_VBUS_MASK)) ? 1u : 0u);
                  }
              
              #endif /* USBFS_MON_VBUS */
1441          
1442          
1443          /*******************************************************************************
1444          * Function Name: USBFS_RWUEnabled
1445          ********************************************************************************
1446          *
1447          * Summary:
1448          *  Returns TRUE if Remote Wake Up is enabled, otherwise FALSE
1449          *
1450          * Parameters:
1451          *   None.
1452          *
1453          * Return:
1454          *  TRUE -  Remote Wake Up Enabled
1455          *  FALSE - Remote Wake Up Disabled
1456          *
1457          * Global variables:
1458          *  USBFS_deviceStatus - checked to determine remote status
1459          *
1460          *******************************************************************************/
1461          uint8 USBFS_RWUEnabled(void) 
1462          {
1463   1          uint8 result = USBFS_FALSE;
1464   1          if((USBFS_deviceStatus & USBFS_DEVICE_STATUS_REMOTE_WAKEUP) != 0u)
1465   1          {
1466   2              result = USBFS_TRUE;
1467   2          }
1468   1      
1469   1          return(result);
1470   1      }
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 25  

1471          
1472          
1473          /* [] END OF FILE */
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 26  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _USBFS_Start (BEGIN)
                                           ; SOURCE LINE # 129
0000 900000      R     MOV     DPTR,#device
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 130
                                           ; SOURCE LINE # 132
0008 900000      R     MOV     DPTR,#USBFS_initVar
000B E0                MOVX    A,@DPTR
000C 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 133
                                           ; SOURCE LINE # 134
000E 120000      R     LCALL   USBFS_Init
                                           ; SOURCE LINE # 135
0011 900000      R     MOV     DPTR,#USBFS_initVar
0014 7401              MOV     A,#01H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 136
0017         ?C0001:
                                           ; SOURCE LINE # 137
0017 900000      R     MOV     DPTR,#device
001A E0                MOVX    A,@DPTR
001B FF                MOV     R7,A
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E FD                MOV     R5,A
001F 120000      R     LCALL   _USBFS_InitComponent
                                           ; SOURCE LINE # 138
0022 22                RET     
             ; FUNCTION _USBFS_Start (END)

             ; FUNCTION USBFS_Init (BEGIN)
                                           ; SOURCE LINE # 158
                                           ; SOURCE LINE # 159
                                           ; SOURCE LINE # 165
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 168
0008 9043A5            MOV     DPTR,#043A5H
000B E0                MOVX    A,@DPTR
000C 4401              ORL     A,#01H
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 170
000F 9043B5            MOV     DPTR,#043B5H
0012 E0                MOVX    A,@DPTR
0013 4401              ORL     A,#01H
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 173
0016 90609D            MOV     DPTR,#0609DH
0019 7401              MOV     A,#01H
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 175
001C 906009            MOV     DPTR,#06009H
001F 04                INC     A
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 27  

0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 179
0021 906010            MOV     DPTR,#06010H
0024 E0                MOVX    A,@DPTR
0025 547F              ANL     A,#07FH
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 180
0028 E4                CLR     A
0029 FF                MOV     R7,A
002A FE                MOV     R6,A
002B 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 185
002E 904394            MOV     DPTR,#04394H
0031 E0                MOVX    A,@DPTR
0032 54F9              ANL     A,#0F9H
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 189
0035 906012            MOV     DPTR,#06012H
0038 E0                MOVX    A,@DPTR
0039 54DF              ANL     A,#0DFH
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 192
003C 904394            MOV     DPTR,#04394H
003F E0                MOVX    A,@DPTR
0040 4401              ORL     A,#01H
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 194
0043 7F01              MOV     R7,#01H
0045 7E00              MOV     R6,#00H
0047 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 196
004A 7F28              MOV     R7,#028H
004C 7E00              MOV     R6,#00H
004E 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 198
0051 9051F8            MOV     DPTR,#051F8H
0054 E0                MOVX    A,@DPTR
0055 547F              ANL     A,#07FH
0057 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 199
0058 E0                MOVX    A,@DPTR
0059 54BF              ANL     A,#0BFH
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 202
005C 904394            MOV     DPTR,#04394H
005F E0                MOVX    A,@DPTR
0060 4402              ORL     A,#02H
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 203
0063 7F02              MOV     R7,#02H
0065 7E00              MOV     R6,#00H
0067 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 205
006A 904394            MOV     DPTR,#04394H
006D E0                MOVX    A,@DPTR
006E 4404              ORL     A,#04H
0070 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 208
0071 906084            MOV     DPTR,#06084H
0074 E4                CLR     A
0075 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 209
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 28  

0076 A3                INC     DPTR
0077 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 222
0078 900000      R     MOV     DPTR,#enableInterrupts
007B E0                MOVX    A,@DPTR
007C FF                MOV     R7,A
007D 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 226
0080 7C00        E     MOV     R4,#HIGH USBFS_BUS_RESET_ISR
0082 7D00        E     MOV     R5,#LOW USBFS_BUS_RESET_ISR
0084 7F17              MOV     R7,#017H
0086 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 227
0089 7D07              MOV     R5,#07H
008B 7F17              MOV     R7,#017H
008D 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 231
0090 7C00        E     MOV     R4,#HIGH USBFS_SOF_ISR
0092 7D00        E     MOV     R5,#LOW USBFS_SOF_ISR
0094 7F15              MOV     R7,#015H
0096 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 232
0099 7D07              MOV     R5,#07H
009B 7F15              MOV     R7,#015H
009D 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 236
00A0 7C00        E     MOV     R4,#HIGH USBFS_EP_0_ISR
00A2 7D00        E     MOV     R5,#LOW USBFS_EP_0_ISR
00A4 7F18              MOV     R7,#018H
00A6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 237
00A9 7D07              MOV     R5,#07H
00AB 7F18              MOV     R7,#018H
00AD 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 241
00B0 7C00        E     MOV     R4,#HIGH USBFS_EP_1_ISR
00B2 7D00        E     MOV     R5,#LOW USBFS_EP_1_ISR
00B4 E4                CLR     A
00B5 FF                MOV     R7,A
00B6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 242
00B9 7D07              MOV     R5,#07H
00BB E4                CLR     A
00BC FF                MOV     R7,A
00BD 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 247
00C0 7C00        E     MOV     R4,#HIGH USBFS_EP_2_ISR
00C2 7D00        E     MOV     R5,#LOW USBFS_EP_2_ISR
00C4 7F01              MOV     R7,#01H
00C6 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 248
00C9 7D07              MOV     R5,#07H
00CB 7F01              MOV     R7,#01H
00CD 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 293
00D0 22                RET     
             ; FUNCTION USBFS_Init (END)

             ; FUNCTION _USBFS_InitComponent (BEGIN)
                                           ; SOURCE LINE # 348
;---- Variable 'mode' assigned to Register 'R5' ----
;---- Variable 'device' assigned to Register 'R7' ----
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 29  

                                           ; SOURCE LINE # 349
                                           ; SOURCE LINE # 357
;---- Variable 'i' assigned to Register 'R6' ----
0000 E4                CLR     A
0001 FE                MOV     R6,A
0002         ?C0004:
                                           ; SOURCE LINE # 358
                                           ; SOURCE LINE # 359
0002 7E01              MOV     R6,#01H
0004 900000      E     MOV     DPTR,#USBFS_hidProtocol
0007 7401              MOV     A,#01H
0009         ?C0051:
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B DEFC              DJNZ    R6,?C0051
                                           ; SOURCE LINE # 360
000D 7E01              MOV     R6,#01H
000F         ?C0005:
                                           ; SOURCE LINE # 364
000F 9044C2            MOV     DPTR,#044C2H
0012 7480              MOV     A,#080H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 365
0015 A3                INC     DPTR
0016 7401              MOV     A,#01H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 367
0019 9044C0            MOV     DPTR,#044C0H
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 370
001D 04                INC     A
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 413
001F E4                CLR     A
0020 900000      E     MOV     DPTR,#USBFS_transferState
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 416
0024 ED                MOV     A,R5
0025 14                DEC     A
0026 600B              JZ      ?C0009
0028 04                INC     A
0029 7010              JNZ     ?C0010
                                           ; SOURCE LINE # 417
                                           ; SOURCE LINE # 418
002B         ?C0008:
                                           ; SOURCE LINE # 419
002B 906009            MOV     DPTR,#06009H
002E 7402              MOV     A,#02H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 420
0031 800E              SJMP    ?C0007
                                           ; SOURCE LINE # 421
0033         ?C0009:
                                           ; SOURCE LINE # 422
0033 906009            MOV     DPTR,#06009H
0036 7403              MOV     A,#03H
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 423
0039 8006              SJMP    ?C0007
                                           ; SOURCE LINE # 424
003B         ?C0010:
                                           ; SOURCE LINE # 428
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 30  

003B 906009            MOV     DPTR,#06009H
003E 7403              MOV     A,#03H
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 430
                                           ; SOURCE LINE # 431
0041         ?C0007:
                                           ; SOURCE LINE # 434
0041 900000      E     MOV     DPTR,#USBFS_device
0044 EF                MOV     A,R7
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 437
0046 E4                CLR     A
0047 900000      E     MOV     DPTR,#USBFS_configuration
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 438
004B 900000      E     MOV     DPTR,#USBFS_interfaceNumber
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 439
004F 900000      E     MOV     DPTR,#USBFS_configurationChanged
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 440
0053 900000      E     MOV     DPTR,#USBFS_deviceAddress
0056 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 441
0057 900000      E     MOV     DPTR,#USBFS_deviceStatus
005A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 443
005B 900000      E     MOV     DPTR,#USBFS_lastPacketSize
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 446
005F 906028            MOV     DPTR,#06028H
0062 7403              MOV     A,#03H
0064 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 449
0065 906008            MOV     DPTR,#06008H
0068 7480              MOV     A,#080H
006A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 452
006B E4                CLR     A
006C 7F01              MOV     R7,#01H
006E FE                MOV     R6,A
006F FD                MOV     R5,A
0070 FC                MOV     R4,A
0071 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 455
0074 906012            MOV     DPTR,#06012H
0077 7404              MOV     A,#04H
0079 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 456
007A 22                RET     
             ; FUNCTION _USBFS_InitComponent (END)

             ; FUNCTION USBFS_ReInitComponent (BEGIN)
                                           ; SOURCE LINE # 498
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 506
;---- Variable 'i' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
0002         ?C0012:
                                           ; SOURCE LINE # 507
                                           ; SOURCE LINE # 508
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 31  

0002 7F01              MOV     R7,#01H
0004 900000      E     MOV     DPTR,#USBFS_hidProtocol
0007 7401              MOV     A,#01H
0009         ?C0052:
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B DFFC              DJNZ    R7,?C0052
                                           ; SOURCE LINE # 509
000D         ?C0013:
                                           ; SOURCE LINE # 512
000D E4                CLR     A
000E 900000      E     MOV     DPTR,#USBFS_transferState
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 515
0012 900000      E     MOV     DPTR,#USBFS_configuration
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 516
0016 900000      E     MOV     DPTR,#USBFS_interfaceNumber
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 517
001A 900000      E     MOV     DPTR,#USBFS_configurationChanged
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 518
001E 900000      E     MOV     DPTR,#USBFS_deviceAddress
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 519
0022 900000      E     MOV     DPTR,#USBFS_deviceStatus
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 521
0026 900000      E     MOV     DPTR,#USBFS_lastPacketSize
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 525
002A 906028            MOV     DPTR,#06028H
002D 7403              MOV     A,#03H
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 528
0030 906008            MOV     DPTR,#06008H
0033 7480              MOV     A,#080H
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 530
0036 22                RET     
             ; FUNCTION USBFS_ReInitComponent (END)

             ; FUNCTION USBFS_Stop (BEGIN)
                                           ; SOURCE LINE # 564
                                           ; SOURCE LINE # 565
                                           ; SOURCE LINE # 572
0000 906008            MOV     DPTR,#06008H
0003 E0                MOVX    A,@DPTR
0004 547F              ANL     A,#07FH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 574
0007 906012            MOV     DPTR,#06012H
000A E0                MOVX    A,@DPTR
000B 54FB              ANL     A,#0FBH
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 576
000E 9043A5            MOV     DPTR,#043A5H
0011 E0                MOVX    A,@DPTR
0012 54FE              ANL     A,#0FEH
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 578
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 32  

0015 9043B5            MOV     DPTR,#043B5H
0018 E0                MOVX    A,@DPTR
0019 54FE              ANL     A,#0FEH
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 581
001C 9044CA            MOV     DPTR,#044CAH
001F 7480              MOV     A,#080H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 582
0022 A3                INC     DPTR
0023 7401              MOV     A,#01H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 584
0026 9044C8            MOV     DPTR,#044C8H
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 587
002A 04                INC     A
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 609
002C E4                CLR     A
002D 900000      E     MOV     DPTR,#USBFS_configuration
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 610
0031 900000      E     MOV     DPTR,#USBFS_interfaceNumber
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 611
0035 900000      E     MOV     DPTR,#USBFS_configurationChanged
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 612
0039 900000      E     MOV     DPTR,#USBFS_deviceAddress
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 613
003D 900000      E     MOV     DPTR,#USBFS_deviceStatus
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 614
0041 900000      R     MOV     DPTR,#USBFS_initVar
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 616
0045 22                RET     
             ; FUNCTION USBFS_Stop (END)

             ; FUNCTION USBFS_CheckActivity (BEGIN)
                                           ; SOURCE LINE # 635
                                           ; SOURCE LINE # 636
                                           ; SOURCE LINE # 639
0000 906009            MOV     DPTR,#06009H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
;---- Variable 'r' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 640
0005 54FB              ANL     A,#0FBH
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 642
0008 EF                MOV     A,R7
0009 5404              ANL     A,#04H
000B FF                MOV     R7,A
000C 13                RRC     A
000D 13                RRC     A
000E 543F              ANL     A,#03FH
0010 FF                MOV     R7,A
                                           ; SOURCE LINE # 643
0011         ?C0017:
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 33  

0011 22                RET     
             ; FUNCTION USBFS_CheckActivity (END)

             ; FUNCTION USBFS_GetConfiguration (BEGIN)
                                           ; SOURCE LINE # 660
                                           ; SOURCE LINE # 661
                                           ; SOURCE LINE # 662
0000 900000      E     MOV     DPTR,#USBFS_configuration
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 663
0005         ?C0018:
0005 22                RET     
             ; FUNCTION USBFS_GetConfiguration (END)

             ; FUNCTION USBFS_IsConfigurationChanged (BEGIN)
                                           ; SOURCE LINE # 686
                                           ; SOURCE LINE # 687
                                           ; SOURCE LINE # 688
;---- Variable 'res' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 690
0002 900000      E     MOV     DPTR,#USBFS_configurationChanged
0005 E0                MOVX    A,@DPTR
0006 6004              JZ      ?C0019
                                           ; SOURCE LINE # 691
                                           ; SOURCE LINE # 692
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
                                           ; SOURCE LINE # 693
000A E4                CLR     A
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 694
000C         ?C0019:
                                           ; SOURCE LINE # 696
                                           ; SOURCE LINE # 697
000C         ?C0020:
000C 22                RET     
             ; FUNCTION USBFS_IsConfigurationChanged (END)

             ; FUNCTION _USBFS_GetInterfaceSetting (BEGIN)
                                           ; SOURCE LINE # 714
;---- Variable 'interfaceNumber' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 716
                                           ; SOURCE LINE # 717
0000 7400        E     MOV     A,#LOW USBFS_interfaceSetting
0002 2F                ADD     A,R7
0003 F582              MOV     DPL,A
0005 E4                CLR     A
0006 3400        E     ADDC    A,#HIGH USBFS_interfaceSetting
0008 F583              MOV     DPH,A
000A E0                MOVX    A,@DPTR
000B FF                MOV     R7,A
                                           ; SOURCE LINE # 718
000C         ?C0021:
000C 22                RET     
             ; FUNCTION _USBFS_GetInterfaceSetting (END)

             ; FUNCTION _USBFS_GetEPState (BEGIN)
                                           ; SOURCE LINE # 735
;---- Variable 'epNumber' assigned to Register 'R7' ----
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 34  

                                           ; SOURCE LINE # 736
                                           ; SOURCE LINE # 737
0000 EF                MOV     A,R7
0001 75F00B            MOV     B,#0BH
0004 A4                MUL     AB
0005 2400        E     ADD     A,#LOW USBFS_EP+01H
0007 F582              MOV     DPL,A
0009 E4                CLR     A
000A 3400        E     ADDC    A,#HIGH USBFS_EP+01H
000C F583              MOV     DPH,A
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
                                           ; SOURCE LINE # 738
0010         ?C0022:
0010 22                RET     
             ; FUNCTION _USBFS_GetEPState (END)

             ; FUNCTION _USBFS_GetEPCount (BEGIN)
                                           ; SOURCE LINE # 760
;---- Variable 'epNumber' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 761
                                           ; SOURCE LINE # 763
;---- Variable 'result' assigned to Register 'R4/R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
0002 FC                MOV     R4,A
                                           ; SOURCE LINE # 765
0003 EF                MOV     A,R7
0004 D3                SETB    C
0005 9400              SUBB    A,#00H
0007 4041              JC      ?C0023
0009 EF                MOV     A,R7
000A 9409              SUBB    A,#09H
000C 503C              JNC     ?C0023
                                           ; SOURCE LINE # 766
                                           ; SOURCE LINE # 767
000E EF                MOV     A,R7
000F 24FF              ADD     A,#0FFH
0011 FF                MOV     R7,A
0012 E4                CLR     A
0013 34FF              ADDC    A,#0FFH
0015 FE                MOV     R6,A
0016 EF                MOV     A,R7
0017 C4                SWAP    A
0018 F8                MOV     R0,A
0019 540F              ANL     A,#0FH
001B C8                XCH     A,R0
001C 68                XRL     A,R0
001D FF                MOV     R7,A
001E EE                MOV     A,R6
001F C4                SWAP    A
0020 54F0              ANL     A,#0F0H
0022 48                ORL     A,R0
;---- Variable 'ri' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 769
0023 EF                MOV     A,R7
0024 240C              ADD     A,#0CH
0026 FB                MOV     R3,A
0027 E4                CLR     A
0028 3460              ADDC    A,#060H
002A 8B82              MOV     DPL,R3
002C F583              MOV     DPH,A
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 35  

002E E0                MOVX    A,@DPTR
002F 540F              ANL     A,#0FH
0031 FD                MOV     R5,A
                                           ; SOURCE LINE # 771
0032 EF                MOV     A,R7
0033 240D              ADD     A,#0DH
0035 FF                MOV     R7,A
0036 E4                CLR     A
0037 3460              ADDC    A,#060H
0039 8F82              MOV     DPL,R7
003B F583              MOV     DPH,A
003D E0                MOVX    A,@DPTR
003E FB                MOV     R3,A
003F ED                MOV     A,R5
0040 FC                MOV     R4,A
0041 EB                MOV     A,R3
0042 FD                MOV     R5,A
                                           ; SOURCE LINE # 772
0043 24FE              ADD     A,#0FEH
0045 FD                MOV     R5,A
0046 74FF              MOV     A,#0FFH
0048 3C                ADDC    A,R4
0049 FC                MOV     R4,A
                                           ; SOURCE LINE # 773
004A         ?C0023:
                                           ; SOURCE LINE # 774
004A AE04              MOV     R6,AR4
004C AF05              MOV     R7,AR5
                                           ; SOURCE LINE # 775
004E         ?C0024:
004E 22                RET     
             ; FUNCTION _USBFS_GetEPCount (END)

             ; FUNCTION _USBFS_LoadInEP (BEGIN)
                                           ; SOURCE LINE # 1009
0000 900000      R     MOV     DPTR,#pData
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#epNumber
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1011
                                           ; SOURCE LINE # 1018
000B D3                SETB    C
000C 9400              SUBB    A,#00H
000E 5003              JNC     $ + 5H
0010 020000      R     LJMP    ?C0031
0013 E0                MOVX    A,@DPTR
0014 9409              SUBB    A,#09H
0016 4003              JC      $ + 5H
0018 020000      R     LJMP    ?C0031
                                           ; SOURCE LINE # 1019
                                           ; SOURCE LINE # 1020
001B E0                MOVX    A,@DPTR
001C FD                MOV     R5,A
001D 24FF              ADD     A,#0FFH
001F FF                MOV     R7,A
0020 E4                CLR     A
0021 34FF              ADDC    A,#0FFH
0023 FE                MOV     R6,A
0024 EF                MOV     A,R7
0025 C4                SWAP    A
0026 F8                MOV     R0,A
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 36  

0027 540F              ANL     A,#0FH
0029 C8                XCH     A,R0
002A 68                XRL     A,R0
002B FF                MOV     R7,A
002C EE                MOV     A,R6
002D C4                SWAP    A
002E 54F0              ANL     A,#0F0H
0030 48                ORL     A,R0
0031 900000      R     MOV     DPTR,#ri
0034 EF                MOV     A,R7
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1021
0036 FB                MOV     R3,A
0037 7A00              MOV     R2,#00H
0039 2488              ADD     A,#088H
003B FE                MOV     R6,A
003C EA                MOV     A,R2
003D 3460              ADDC    A,#060H
003F A3                INC     DPTR
0040 F0                MOVX    @DPTR,A
0041 A3                INC     DPTR
0042 CE                XCH     A,R6
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1025
0044 ED                MOV     A,R5
0045 75F00B            MOV     B,#0BH
0048 A4                MUL     AB
0049 2400        E     ADD     A,#LOW USBFS_EP+06H
004B F582              MOV     DPL,A
004D E4                CLR     A
004E 3400        E     ADDC    A,#HIGH USBFS_EP+06H
0050 F583              MOV     DPH,A
0052 E0                MOVX    A,@DPTR
0053 FE                MOV     R6,A
0054 A3                INC     DPTR
0055 E0                MOVX    A,@DPTR
0056 FF                MOV     R7,A
0057 C3                CLR     C
0058 E4                CLR     A
0059 9F                SUBB    A,R7
005A FF                MOV     R7,A
005B 7402              MOV     A,#02H
005D 9E                SUBB    A,R6
005E FE                MOV     R6,A
005F D3                SETB    C
0060 900000      R     MOV     DPTR,#length+01H
0063 E0                MOVX    A,@DPTR
0064 9F                SUBB    A,R7
0065 900000      R     MOV     DPTR,#length
0068 E0                MOVX    A,@DPTR
0069 9E                SUBB    A,R6
006A 4024              JC      ?C0026
                                           ; SOURCE LINE # 1026
                                           ; SOURCE LINE # 1027
006C 900000      R     MOV     DPTR,#epNumber
006F E0                MOVX    A,@DPTR
0070 75F00B            MOV     B,#0BH
0073 A4                MUL     AB
0074 2400        E     ADD     A,#LOW USBFS_EP+06H
0076 F582              MOV     DPL,A
0078 E4                CLR     A
0079 3400        E     ADDC    A,#HIGH USBFS_EP+06H
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 37  

007B F583              MOV     DPH,A
007D E0                MOVX    A,@DPTR
007E FE                MOV     R6,A
007F A3                INC     DPTR
0080 E0                MOVX    A,@DPTR
0081 FF                MOV     R7,A
0082 C3                CLR     C
0083 E4                CLR     A
0084 9F                SUBB    A,R7
0085 900000      R     MOV     DPTR,#length+01H
0088 F0                MOVX    @DPTR,A
0089 7402              MOV     A,#02H
008B 9E                SUBB    A,R6
008C 900000      R     MOV     DPTR,#length
008F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1028
0090         ?C0026:
                                           ; SOURCE LINE # 1033
0090 900000      R     MOV     DPTR,#length
0093 E0                MOVX    A,@DPTR
0094 FF                MOV     R7,A
0095 900000      R     MOV     DPTR,#epNumber
0098 E0                MOVX    A,@DPTR
0099 75F00B            MOV     B,#0BH
009C A4                MUL     AB
009D 2400        E     ADD     A,#LOW USBFS_EP+03H
009F F582              MOV     DPL,A
00A1 E4                CLR     A
00A2 3400        E     ADDC    A,#HIGH USBFS_EP+03H
00A4 F583              MOV     DPH,A
00A6 E0                MOVX    A,@DPTR
00A7 4F                ORL     A,R7
00A8 FF                MOV     R7,A
00A9 EB                MOV     A,R3
00AA 240C              ADD     A,#0CH
00AC FD                MOV     R5,A
00AD EA                MOV     A,R2
00AE 3460              ADDC    A,#060H
00B0 8D82              MOV     DPL,R5
00B2 F583              MOV     DPH,A
00B4 EF                MOV     A,R7
00B5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1034
00B6 900000      R     MOV     DPTR,#length
00B9 E0                MOVX    A,@DPTR
00BA A3                INC     DPTR
00BB E0                MOVX    A,@DPTR
00BC FF                MOV     R7,A
00BD EB                MOV     A,R3
00BE 240D              ADD     A,#0DH
00C0 FD                MOV     R5,A
00C1 EA                MOV     A,R2
00C2 3460              ADDC    A,#060H
00C4 8D82              MOV     DPL,R5
00C6 F583              MOV     DPH,A
00C8 EF                MOV     A,R7
00C9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1037
00CA 900000      R     MOV     DPTR,#pData
00CD 120000      E     LCALL   ?C?PLDXDATA
00D0 E9                MOV     A,R1
00D1 4A                ORL     A,R2
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 38  

00D2 4B                ORL     A,R3
00D3 6046              JZ      ?C0027
                                           ; SOURCE LINE # 1038
                                           ; SOURCE LINE # 1040
00D5 E4                CLR     A
00D6 900000      R     MOV     DPTR,#i
00D9 F0                MOVX    @DPTR,A
00DA A3                INC     DPTR
00DB F0                MOVX    @DPTR,A
00DC         ?C0028:
00DC 900000      R     MOV     DPTR,#length
00DF E0                MOVX    A,@DPTR
00E0 FE                MOV     R6,A
00E1 A3                INC     DPTR
00E2 E0                MOVX    A,@DPTR
00E3 FF                MOV     R7,A
00E4 900000      R     MOV     DPTR,#i
00E7 E0                MOVX    A,@DPTR
00E8 FC                MOV     R4,A
00E9 A3                INC     DPTR
00EA E0                MOVX    A,@DPTR
00EB FD                MOV     R5,A
00EC C3                CLR     C
00ED 9F                SUBB    A,R7
00EE EC                MOV     A,R4
00EF 9E                SUBB    A,R6
00F0 5029              JNC     ?C0027
                                           ; SOURCE LINE # 1041
                                           ; SOURCE LINE # 1042
00F2 900000      R     MOV     DPTR,#pData
00F5 120000      E     LCALL   ?C?PLDXDATA
00F8 E9                MOV     A,R1
00F9 2D                ADD     A,R5
00FA F9                MOV     R1,A
00FB EA                MOV     A,R2
00FC 3C                ADDC    A,R4
00FD FA                MOV     R2,A
00FE 120000      E     LCALL   ?C?CLDPTR
0101 FF                MOV     R7,A
0102 900000      R     MOV     DPTR,#p
0105 E0                MOVX    A,@DPTR
0106 FC                MOV     R4,A
0107 A3                INC     DPTR
0108 E0                MOVX    A,@DPTR
0109 F582              MOV     DPL,A
010B 8C83              MOV     DPH,R4
010D EF                MOV     A,R7
010E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1043
010F 900000      R     MOV     DPTR,#i
0112 E4                CLR     A
0113 75F001            MOV     B,#01H
0116 120000      E     LCALL   ?C?IILDX
0119 80C1              SJMP    ?C0028
                                           ; SOURCE LINE # 1044
011B         ?C0027:
                                           ; SOURCE LINE # 1045
011B 900000      R     MOV     DPTR,#epNumber
011E E0                MOVX    A,@DPTR
011F FF                MOV     R7,A
0120 75F00B            MOV     B,#0BH
0123 A4                MUL     AB
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 39  

0124 2400        E     ADD     A,#LOW USBFS_EP+01H
0126 F582              MOV     DPL,A
0128 E4                CLR     A
0129 3400        E     ADDC    A,#HIGH USBFS_EP+01H
012B F583              MOV     DPH,A
012D E4                CLR     A
012E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1047
012F EF                MOV     A,R7
0130 75F00B            MOV     B,#0BH
0133 A4                MUL     AB
0134 2400        E     ADD     A,#LOW USBFS_EP+05H
0136 F582              MOV     DPL,A
0138 E4                CLR     A
0139 3400        E     ADDC    A,#HIGH USBFS_EP+05H
013B F583              MOV     DPH,A
013D E0                MOVX    A,@DPTR
013E FF                MOV     R7,A
013F 900000      R     MOV     DPTR,#ri
0142 E0                MOVX    A,@DPTR
0143 240E              ADD     A,#0EH
0145 FD                MOV     R5,A
0146 E4                CLR     A
0147 3460              ADDC    A,#060H
0149 8D82              MOV     DPL,R5
014B F583              MOV     DPH,A
014D EF                MOV     A,R7
014E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1151
                                           ; SOURCE LINE # 1152
014F         ?C0031:
014F 22                RET     
             ; FUNCTION _USBFS_LoadInEP (END)

             ; FUNCTION _USBFS_ReadOutEP (BEGIN)
                                           ; SOURCE LINE # 1180
0000 900000      R     MOV     DPTR,#pData
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#epNumber
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1182
                                           ; SOURCE LINE # 1192
000B D3                SETB    C
000C 9400              SUBB    A,#00H
000E 5003              JNC     $ + 5H
0010 020000      R     LJMP    ?C0032
0013 E0                MOVX    A,@DPTR
0014 9409              SUBB    A,#09H
0016 4003              JC      $ + 5H
0018 020000      R     LJMP    ?C0032
001B A3                INC     DPTR
001C 120000      E     LCALL   ?C?PLDXDATA
001F E9                MOV     A,R1
0020 4A                ORL     A,R2
0021 4B                ORL     A,R3
0022 607C              JZ      ?C0032
                                           ; SOURCE LINE # 1193
                                           ; SOURCE LINE # 1194
0024 900000      R     MOV     DPTR,#epNumber
0027 E0                MOVX    A,@DPTR
0028 FD                MOV     R5,A
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 40  

0029 24FF              ADD     A,#0FFH
002B FF                MOV     R7,A
002C E4                CLR     A
002D 34FF              ADDC    A,#0FFH
002F FE                MOV     R6,A
0030 EF                MOV     A,R7
0031 C4                SWAP    A
0032 F8                MOV     R0,A
0033 540F              ANL     A,#0FH
0035 C8                XCH     A,R0
0036 68                XRL     A,R0
0037 FF                MOV     R7,A
0038 EE                MOV     A,R6
0039 C4                SWAP    A
003A 54F0              ANL     A,#0F0H
003C 48                ORL     A,R0
;---- Variable 'ri' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1195
003D EF                MOV     A,R7
003E 2488              ADD     A,#088H
0040 FE                MOV     R6,A
0041 E4                CLR     A
0042 3460              ADDC    A,#060H
0044 900000      R     MOV     DPTR,#p
0047 F0                MOVX    @DPTR,A
0048 A3                INC     DPTR
0049 CE                XCH     A,R6
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1199
004B AF05              MOV     R7,AR5
004D 120000      R     LCALL   _USBFS_GetEPCount
;---- Variable 'xferCount' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 1200
0050 D3                SETB    C
0051 900000      R     MOV     DPTR,#length+01H
0054 E0                MOVX    A,@DPTR
0055 9F                SUBB    A,R7
0056 900000      R     MOV     DPTR,#length
0059 E0                MOVX    A,@DPTR
005A 9E                SUBB    A,R6
005B 4005              JC      ?C0033
                                           ; SOURCE LINE # 1201
                                           ; SOURCE LINE # 1202
005D EE                MOV     A,R6
005E F0                MOVX    @DPTR,A
005F A3                INC     DPTR
0060 EF                MOV     A,R7
0061 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1203
0062         ?C0033:
                                           ; SOURCE LINE # 1208
;---- Variable 'i' assigned to Register 'R6/R7' ----
0062 E4                CLR     A
0063 FF                MOV     R7,A
0064 FE                MOV     R6,A
0065         ?C0034:
0065 D3                SETB    C
0066 900000      R     MOV     DPTR,#length+01H
0069 E0                MOVX    A,@DPTR
006A 9F                SUBB    A,R7
006B 900000      R     MOV     DPTR,#length
006E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 41  

006F 9E                SUBB    A,R6
0070 4024              JC      ?C0035
                                           ; SOURCE LINE # 1209
                                           ; SOURCE LINE # 1210
0072 900000      R     MOV     DPTR,#p
0075 E0                MOVX    A,@DPTR
0076 FC                MOV     R4,A
0077 A3                INC     DPTR
0078 E0                MOVX    A,@DPTR
0079 F582              MOV     DPL,A
007B 8C83              MOV     DPH,R4
007D E0                MOVX    A,@DPTR
007E FD                MOV     R5,A
007F 900000      R     MOV     DPTR,#pData
0082 120000      E     LCALL   ?C?PLDXDATA
0085 E9                MOV     A,R1
0086 2F                ADD     A,R7
0087 F9                MOV     R1,A
0088 EA                MOV     A,R2
0089 3E                ADDC    A,R6
008A FA                MOV     R2,A
008B ED                MOV     A,R5
008C 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 1211
008F 0F                INC     R7
0090 EF                MOV     A,R7
0091 7001              JNZ     ?C0055
0093 0E                INC     R6
0094         ?C0055:
0094 80CF              SJMP    ?C0034
0096         ?C0035:
                                           ; SOURCE LINE # 1214
0096 900000      R     MOV     DPTR,#epNumber
0099 E0                MOVX    A,@DPTR
009A FF                MOV     R7,A
009B 120000      R     LCALL   _USBFS_EnableOutEP
                                           ; SOURCE LINE # 1255
009E 8007              SJMP    ?C0037
00A0         ?C0032:
                                           ; SOURCE LINE # 1257
                                           ; SOURCE LINE # 1258
00A0 E4                CLR     A
00A1 900000      R     MOV     DPTR,#length
00A4 F0                MOVX    @DPTR,A
00A5 A3                INC     DPTR
00A6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1259
00A7         ?C0037:
                                           ; SOURCE LINE # 1261
00A7 900000      R     MOV     DPTR,#length
00AA E0                MOVX    A,@DPTR
00AB FE                MOV     R6,A
00AC A3                INC     DPTR
00AD E0                MOVX    A,@DPTR
00AE FF                MOV     R7,A
                                           ; SOURCE LINE # 1262
00AF         ?C0038:
00AF 22                RET     
             ; FUNCTION _USBFS_ReadOutEP (END)

             ; FUNCTION _USBFS_EnableOutEP (BEGIN)
                                           ; SOURCE LINE # 1287
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 42  

;---- Variable 'epNumber' assigned to Register 'R5' ----
0000 AD07              MOV     R5,AR7
                                           ; SOURCE LINE # 1288
                                           ; SOURCE LINE # 1291
0002 ED                MOV     A,R5
0003 D3                SETB    C
0004 9400              SUBB    A,#00H
0006 4047              JC      ?C0040
0008 ED                MOV     A,R5
0009 9409              SUBB    A,#09H
000B 5042              JNC     ?C0040
                                           ; SOURCE LINE # 1292
                                           ; SOURCE LINE # 1293
000D ED                MOV     A,R5
000E 24FF              ADD     A,#0FFH
0010 FF                MOV     R7,A
0011 E4                CLR     A
0012 34FF              ADDC    A,#0FFH
0014 FE                MOV     R6,A
0015 EF                MOV     A,R7
0016 C4                SWAP    A
0017 F8                MOV     R0,A
0018 540F              ANL     A,#0FH
001A C8                XCH     A,R0
001B 68                XRL     A,R0
001C FF                MOV     R7,A
001D EE                MOV     A,R6
001E C4                SWAP    A
001F 54F0              ANL     A,#0F0H
0021 48                ORL     A,R0
;---- Variable 'ri' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1294
0022 ED                MOV     A,R5
0023 75F00B            MOV     B,#0BH
0026 A4                MUL     AB
0027 2400        E     ADD     A,#LOW USBFS_EP+01H
0029 F582              MOV     DPL,A
002B E4                CLR     A
002C 3400        E     ADDC    A,#HIGH USBFS_EP+01H
002E F583              MOV     DPH,A
0030 E4                CLR     A
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1296
0032 ED                MOV     A,R5
0033 75F00B            MOV     B,#0BH
0036 A4                MUL     AB
0037 2400        E     ADD     A,#LOW USBFS_EP+05H
0039 F582              MOV     DPL,A
003B E4                CLR     A
003C 3400        E     ADDC    A,#HIGH USBFS_EP+05H
003E F583              MOV     DPH,A
0040 E0                MOVX    A,@DPTR
0041 FE                MOV     R6,A
0042 EF                MOV     A,R7
0043 240E              ADD     A,#0EH
0045 FD                MOV     R5,A
0046 E4                CLR     A
0047 3460              ADDC    A,#060H
0049 8D82              MOV     DPL,R5
004B F583              MOV     DPH,A
004D EE                MOV     A,R6
004E F0                MOVX    @DPTR,A
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 43  

                                           ; SOURCE LINE # 1297
                                           ; SOURCE LINE # 1298
004F         ?C0040:
004F 22                RET     
             ; FUNCTION _USBFS_EnableOutEP (END)

             ; FUNCTION _USBFS_DisableOutEP (BEGIN)
                                           ; SOURCE LINE # 1317
;---- Variable 'epNumber' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1318
                                           ; SOURCE LINE # 1321
0000 EF                MOV     A,R7
0001 D3                SETB    C
0002 9400              SUBB    A,#00H
0004 4028              JC      ?C0042
0006 EF                MOV     A,R7
0007 9409              SUBB    A,#09H
0009 5023              JNC     ?C0042
                                           ; SOURCE LINE # 1322
                                           ; SOURCE LINE # 1323
000B EF                MOV     A,R7
000C 24FF              ADD     A,#0FFH
000E FF                MOV     R7,A
000F E4                CLR     A
0010 34FF              ADDC    A,#0FFH
0012 FE                MOV     R6,A
0013 EF                MOV     A,R7
0014 C4                SWAP    A
0015 F8                MOV     R0,A
0016 540F              ANL     A,#0FH
0018 C8                XCH     A,R0
0019 68                XRL     A,R0
001A FF                MOV     R7,A
001B EE                MOV     A,R6
001C C4                SWAP    A
001D 54F0              ANL     A,#0F0H
001F 48                ORL     A,R0
;---- Variable 'ri' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1325
0020 EF                MOV     A,R7
0021 240E              ADD     A,#0EH
0023 FF                MOV     R7,A
0024 E4                CLR     A
0025 3460              ADDC    A,#060H
0027 8F82              MOV     DPL,R7
0029 F583              MOV     DPH,A
002B 7408              MOV     A,#08H
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1326
                                           ; SOURCE LINE # 1327
002E         ?C0042:
002E 22                RET     
             ; FUNCTION _USBFS_DisableOutEP (END)

             ; FUNCTION _USBFS_Force (BEGIN)
                                           ; SOURCE LINE # 1348
;---- Variable 'bState' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1349
                                           ; SOURCE LINE # 1350
0000 906010            MOV     DPTR,#06010H
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 44  

                                           ; SOURCE LINE # 1351
0005 22                RET     
             ; FUNCTION _USBFS_Force (END)

             ; FUNCTION _USBFS_GetEPAckState (BEGIN)
                                           ; SOURCE LINE # 1369
;---- Variable 'epNumber' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1370
                                           ; SOURCE LINE # 1372
;---- Variable 'cr' assigned to Register 'R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
                                           ; SOURCE LINE # 1374
0002 EF                MOV     A,R7
0003 D3                SETB    C
0004 9400              SUBB    A,#00H
0006 4029              JC      ?C0044
0008 EF                MOV     A,R7
0009 9409              SUBB    A,#09H
000B 5024              JNC     ?C0044
                                           ; SOURCE LINE # 1375
                                           ; SOURCE LINE # 1376
000D EF                MOV     A,R7
000E 24FF              ADD     A,#0FFH
0010 FF                MOV     R7,A
0011 E4                CLR     A
0012 34FF              ADDC    A,#0FFH
0014 FE                MOV     R6,A
0015 EF                MOV     A,R7
0016 C4                SWAP    A
0017 F8                MOV     R0,A
0018 540F              ANL     A,#0FH
001A C8                XCH     A,R0
001B 68                XRL     A,R0
001C FF                MOV     R7,A
001D EE                MOV     A,R6
001E C4                SWAP    A
001F 54F0              ANL     A,#0F0H
0021 48                ORL     A,R0
;---- Variable 'ri' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1377
0022 EF                MOV     A,R7
0023 240E              ADD     A,#0EH
0025 FF                MOV     R7,A
0026 E4                CLR     A
0027 3460              ADDC    A,#060H
0029 8F82              MOV     DPL,R7
002B F583              MOV     DPH,A
002D E0                MOVX    A,@DPTR
002E 5410              ANL     A,#010H
0030 FD                MOV     R5,A
                                           ; SOURCE LINE # 1378
0031         ?C0044:
                                           ; SOURCE LINE # 1380
0031 AF05              MOV     R7,AR5
                                           ; SOURCE LINE # 1381
0033         ?C0045:
0033 22                RET     
             ; FUNCTION _USBFS_GetEPAckState (END)

             ; FUNCTION _USBFS_SetPowerStatus (BEGIN)
                                           ; SOURCE LINE # 1406
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 45  

;---- Variable 'powerStatus' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1407
                                           ; SOURCE LINE # 1408
0000 EF                MOV     A,R7
0001 6008              JZ      ?C0046
                                           ; SOURCE LINE # 1409
                                           ; SOURCE LINE # 1410
0003 900000      E     MOV     DPTR,#USBFS_deviceStatus
0006 E0                MOVX    A,@DPTR
0007 4401              ORL     A,#01H
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1411
000A 22                RET     
000B         ?C0046:
                                           ; SOURCE LINE # 1413
                                           ; SOURCE LINE # 1414
000B 900000      E     MOV     DPTR,#USBFS_deviceStatus
000E E0                MOVX    A,@DPTR
000F 54FE              ANL     A,#0FEH
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1415
                                           ; SOURCE LINE # 1416
0012         ?C0048:
0012 22                RET     
             ; FUNCTION _USBFS_SetPowerStatus (END)

             ; FUNCTION USBFS_RWUEnabled (BEGIN)
                                           ; SOURCE LINE # 1461
                                           ; SOURCE LINE # 1462
                                           ; SOURCE LINE # 1463
;---- Variable 'result' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 1464
0002 900000      E     MOV     DPTR,#USBFS_deviceStatus
0005 E0                MOVX    A,@DPTR
0006 5402              ANL     A,#02H
0008 6001              JZ      ?C0049
                                           ; SOURCE LINE # 1465
                                           ; SOURCE LINE # 1466
000A 0F                INC     R7
                                           ; SOURCE LINE # 1467
000B         ?C0049:
                                           ; SOURCE LINE # 1469
                                           ; SOURCE LINE # 1470
000B         ?C0050:
000B 22                RET     
             ; FUNCTION USBFS_RWUEnabled (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1366    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      22
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
C51 COMPILER V9.51   USBFS                                                                 02/23/2016 09:17:10 PAGE 46  

   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
