C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USBFS_DRV
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\USBFS_drv.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\USBFS_drv.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(DEBU
                    -G) WL(2) PR(.\DP8051\DP8051_Keil_951\Debug/USBFS_drv.lst) CD OT(5,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\USBFS_drv.obj)

line level    source

   1          /***************************************************************************//**
   2          * \file USBFS_drv.c
   3          * \version 3.0
   4          *
   5          * \brief
   6          *  This file contains the Endpoint 0 Driver for the USBFS Component.  
   7          *
   8          ********************************************************************************
   9          * \copyright
  10          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  11          * You may use this file only in accordance with the license, terms, conditions,
  12          * disclaimers, and limitations in the end user license agreement accompanying
  13          * the software package with which this file was provided.
  14          *******************************************************************************/
  15          
  16          #include "USBFS_pvt.h"
  17          
  18          
  19          
  20          /***************************************
  21          * Global data allocation
  22          ***************************************/
  23          
  24          volatile T_USBFS_EP_CTL_BLOCK USBFS_EP[USBFS_MAX_EP];
  25          
  26          /** Contains the current configuration number, which is set by the host using a 
  27           * SET_CONFIGURATION request. This variable is initialized to zero in 
  28           * USBFS_InitComponent() API and can be read by the USBFS_GetConfiguration() 
  29           * API.*/
  30          volatile uint8 USBFS_configuration;
  31          
  32          /** Contains the current interface number.*/
  33          volatile uint8 USBFS_interfaceNumber;
  34          
  35          /** This variable is set to one after SET_CONFIGURATION and SET_INTERFACE 
  36           *requests. It can be read by the USBFS_IsConfigurationChanged() API */
  37          volatile uint8 USBFS_configurationChanged;
  38          
  39          /** Contains the current device address.*/
  40          volatile uint8 USBFS_deviceAddress;
  41          
  42          /** This is a two-bit variable that contains power status in the bit 0 
  43           * (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and remote wakeup 
  44           * status (DEVICE_STATUS_REMOTE_WAKEUP) in the bit 1. This variable is 
  45           * initialized to zero in USBFS_InitComponent() API, configured by the 
  46           * USBFS_SetPowerStatus() API. The remote wakeup status cannot be set using the 
  47           * API SetPowerStatus(). */
  48          volatile uint8 USBFS_deviceStatus;
  49          
  50          volatile uint8 USBFS_interfaceSetting[USBFS_MAX_INTERFACES_NUMBER];
  51          volatile uint8 USBFS_interfaceSetting_last[USBFS_MAX_INTERFACES_NUMBER];
  52          volatile uint8 USBFS_interfaceStatus[USBFS_MAX_INTERFACES_NUMBER];
  53          
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 2   

  54          /** Contains the started device number. This variable is set by the 
  55           * USBFS_Start() or USBFS_InitComponent() APIs.*/
  56          volatile uint8 USBFS_device;
  57          
  58          /** Initialized class array for each interface. It is used for handling Class 
  59           * specific requests depend on interface class. Different classes in multiple 
  60           * alternate settings are not supported.*/
  61          const uint8 CYCODE *USBFS_interfaceClass;
  62          
  63          
  64          /***************************************
  65          * Local data allocation
  66          ***************************************/
  67          
  68          volatile uint8  USBFS_ep0Toggle;
  69          volatile uint8  USBFS_lastPacketSize;
  70          
  71          /** This variable is used by the communication functions to handle the current 
  72          * transfer state.
  73          * Initialized to TRANS_STATE_IDLE in the USBFS_InitComponent() API and after a 
  74          * complete transfer in the status stage.
  75          * Changed to the TRANS_STATE_CONTROL_READ or TRANS_STATE_CONTROL_WRITE in setup 
  76          * transaction depending on the request type.
  77          */
  78          volatile uint8  USBFS_transferState;
  79          volatile T_USBFS_TD USBFS_currentTD;
  80          volatile uint8  USBFS_ep0Mode;
  81          volatile uint8  USBFS_ep0Count;
  82          volatile uint16 USBFS_transferByteCount;
  83          
  84          
  85          /*******************************************************************************
  86          * Function Name: USBFS_ep_0_Interrupt
  87          ****************************************************************************//**
  88          *
  89          *  This Interrupt Service Routine handles Endpoint 0 (Control Pipe) traffic.
  90          *  It dispatches setup requests and handles the data and status stages.
  91          *
  92          *
  93          *******************************************************************************/
  94          CY_ISR(USBFS_EP_0_ISR)
  95          {
  96   1          uint8 tempReg;
  97   1          uint8 modifyReg;
  98   1      
  99   1      #ifdef USBFS_EP_0_ISR_ENTRY_CALLBACK
                  USBFS_EP_0_ISR_EntryCallback();
              #endif /* (USBFS_EP_0_ISR_ENTRY_CALLBACK) */
 102   1          
 103   1          tempReg = USBFS_EP0_CR_REG;
 104   1          if ((tempReg & USBFS_MODE_ACKD) != 0u)
 105   1          {
 106   2              modifyReg = 1u;
 107   2              if ((tempReg & USBFS_MODE_SETUP_RCVD) != 0u)
 108   2              {
 109   3                  if ((tempReg & USBFS_MODE_MASK) != USBFS_MODE_NAK_IN_OUT)
 110   3                  {
 111   4                      /* Mode not equal to NAK_IN_OUT: invalid setup */
 112   4                      modifyReg = 0u;
 113   4                  }
 114   3                  else
 115   3                  {
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 3   

 116   4                      USBFS_HandleSetup();
 117   4                      
 118   4                      if ((USBFS_ep0Mode & USBFS_MODE_SETUP_RCVD) != 0u)
 119   4                      {
 120   5                          /* SETUP bit set: exit without mode modificaiton */
 121   5                          modifyReg = 0u;
 122   5                      }
 123   4                  }
 124   3              }
 125   2              else if ((tempReg & USBFS_MODE_IN_RCVD) != 0u)
 126   2              {
 127   3                  USBFS_HandleIN();
 128   3              }
 129   2              else if ((tempReg & USBFS_MODE_OUT_RCVD) != 0u)
 130   2              {
 131   3                  USBFS_HandleOUT();
 132   3              }
 133   2              else
 134   2              {
 135   3                  modifyReg = 0u;
 136   3              }
 137   2              
 138   2              /* Modify the EP0_CR register */
 139   2              if (modifyReg != 0u)
 140   2              {
 141   3                  
 142   3                  tempReg = USBFS_EP0_CR_REG;
 143   3                  
 144   3                  /* Make sure that SETUP bit is cleared before modification */
 145   3                  if ((tempReg & USBFS_MODE_SETUP_RCVD) == 0u)
 146   3                  {
 147   4                      /* Update count register */
 148   4                      tempReg = (uint8) USBFS_ep0Toggle | USBFS_ep0Count;
 149   4                      USBFS_EP0_CNT_REG = tempReg;
 150   4                     
 151   4                      /* Make sure that previous write operaiton was successful */
 152   4                      if (tempReg == USBFS_EP0_CNT_REG)
 153   4                      {
 154   5                          /* Repeat until next successful write operation */
 155   5                          do
 156   5                          {
 157   6                              /* Init temporary variable */
 158   6                              modifyReg = USBFS_ep0Mode;
 159   6                              
 160   6                              /* Unlock register */
 161   6                              tempReg = (uint8) (USBFS_EP0_CR_REG & USBFS_MODE_SETUP_RCVD);
 162   6                              
 163   6                              /* Check if SETUP bit is not set */
 164   6                              if (0u == tempReg)
 165   6                              {
 166   7                                  /* Set the Mode Register  */
 167   7                                  USBFS_EP0_CR_REG = USBFS_ep0Mode;
 168   7                                  
 169   7                                  /* Writing check */
 170   7                                  modifyReg = USBFS_EP0_CR_REG & USBFS_MODE_MASK;
 171   7                              }
 172   6                          }
 173   5                          while (modifyReg != USBFS_ep0Mode);
 174   5                      }
 175   4                  }
 176   3              }
 177   2          }
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 4   

 178   1      
 179   1          USBFS_ClearSieInterruptSource(USBFS_INTR_SIE_EP0_INTR);
 180   1              
 181   1      #ifdef USBFS_EP_0_ISR_EXIT_CALLBACK
                  USBFS_EP_0_ISR_ExitCallback();
              #endif /* (USBFS_EP_0_ISR_EXIT_CALLBACK) */
 184   1      }
 185          
 186          
 187          /*******************************************************************************
 188          * Function Name: USBFS_HandleSetup
 189          ****************************************************************************//**
 190          *
 191          *  This Routine dispatches requests for the four USB request types
 192          *
 193          *
 194          * \reentrant
 195          *  No.
 196          *
 197          *******************************************************************************/
 198          void USBFS_HandleSetup(void) 
 199          {
 200   1          uint8 requestHandled;
 201   1          
 202   1          /* Clear register lock by SIE (read register) and clear setup bit 
 203   1          * (write any value in register).
 204   1          */
 205   1          requestHandled = (uint8) USBFS_EP0_CR_REG;
 206   1          USBFS_EP0_CR_REG = (uint8) requestHandled;
 207   1          requestHandled = (uint8) USBFS_EP0_CR_REG;
 208   1      
 209   1          if ((requestHandled & USBFS_MODE_SETUP_RCVD) != 0u)
 210   1          {
 211   2              /* SETUP bit is set: exit without mode modification. */
 212   2              USBFS_ep0Mode = requestHandled;
 213   2          }
 214   1          else
 215   1          {
 216   2              /* In case the previous transfer did not complete, close it out */
 217   2              USBFS_UpdateStatusBlock(USBFS_XFER_PREMATURE);
 218   2      
 219   2              /* Check request type. */
 220   2              switch (USBFS_bmRequestTypeReg & USBFS_RQST_TYPE_MASK)
 221   2              {
 222   3                  case USBFS_RQST_TYPE_STD:
 223   3                      requestHandled = USBFS_HandleStandardRqst();
 224   3                      break;
 225   3                      
 226   3                  case USBFS_RQST_TYPE_CLS:
 227   3                      requestHandled = USBFS_DispatchClassRqst();
 228   3                      break;
 229   3                      
 230   3                  case USBFS_RQST_TYPE_VND:
 231   3                      requestHandled = USBFS_HandleVendorRqst();
 232   3                      break;
 233   3                      
 234   3                  default:
 235   3                      requestHandled = USBFS_FALSE;
 236   3                      break;
 237   3              }
 238   2              
 239   2              /* If request is not recognized. Stall endpoint 0 IN and OUT. */
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 5   

 240   2              if (requestHandled == USBFS_FALSE)
 241   2              {
 242   3                  USBFS_ep0Mode = USBFS_MODE_STALL_IN_OUT;
 243   3              }
 244   2          }
 245   1      }
 246          
 247          
 248          /*******************************************************************************
 249          * Function Name: USBFS_HandleIN
 250          ****************************************************************************//**
 251          *
 252          *  This routine handles EP0 IN transfers.
 253          *
 254          *
 255          * \reentrant
 256          *  No.
 257          *
 258          *******************************************************************************/
 259          void USBFS_HandleIN(void) 
 260          {
 261   1          switch (USBFS_transferState)
 262   1          {
 263   2              case USBFS_TRANS_STATE_IDLE:
 264   2                  break;
 265   2              
 266   2              case USBFS_TRANS_STATE_CONTROL_READ:
 267   2                  USBFS_ControlReadDataStage();
 268   2                  break;
 269   2                  
 270   2              case USBFS_TRANS_STATE_CONTROL_WRITE:
 271   2                  USBFS_ControlWriteStatusStage();
 272   2                  break;
 273   2                  
 274   2              case USBFS_TRANS_STATE_NO_DATA_CONTROL:
 275   2                  USBFS_NoDataControlStatusStage();
 276   2                  break;
 277   2                  
 278   2              default:    /* there are no more states */
 279   2                  break;
 280   2          }
 281   1      }
 282          
 283          
 284          /*******************************************************************************
 285          * Function Name: USBFS_HandleOUT
 286          ****************************************************************************//**
 287          *
 288          *  This routine handles EP0 OUT transfers.
 289          *
 290          *
 291          * \reentrant
 292          *  No.
 293          *
 294          *******************************************************************************/
 295          void USBFS_HandleOUT(void) 
 296          {
 297   1          switch (USBFS_transferState)
 298   1          {
 299   2              case USBFS_TRANS_STATE_IDLE:
 300   2                  break;
 301   2              
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 6   

 302   2              case USBFS_TRANS_STATE_CONTROL_READ:
 303   2                  USBFS_ControlReadStatusStage();
 304   2                  break;
 305   2                  
 306   2              case USBFS_TRANS_STATE_CONTROL_WRITE:
 307   2                  USBFS_ControlWriteDataStage();
 308   2                  break;
 309   2                  
 310   2              case USBFS_TRANS_STATE_NO_DATA_CONTROL:
 311   2                  /* Update the completion block */
 312   2                  USBFS_UpdateStatusBlock(USBFS_XFER_ERROR);
 313   2                  
 314   2                  /* We expect no more data, so stall INs and OUTs */
 315   2                  USBFS_ep0Mode = USBFS_MODE_STALL_IN_OUT;
 316   2                  break;
 317   2                  
 318   2              default:    
 319   2                  /* There are no more states */
 320   2                  break;
 321   2          }
 322   1      }
 323          
 324          
 325          /*******************************************************************************
 326          * Function Name: USBFS_LoadEP0
 327          ****************************************************************************//**
 328          *
 329          *  This routine loads the EP0 data registers for OUT transfers. It uses the
 330          *  currentTD (previously initialized by the _InitControlWrite function and
 331          *  updated for each OUT transfer, and the bLastPacketSize) to determine how
 332          *  many uint8s to transfer on the current OUT.
 333          *
 334          *  If the number of uint8s remaining is zero and the last transfer was full,
 335          *  we need to send a zero length packet.  Otherwise we send the minimum
 336          *  of the control endpoint size (8) or remaining number of uint8s for the
 337          *  transaction.
 338          *
 339          *
 340          * \globalvars
 341          *  USBFS_transferByteCount - Update the transfer byte count from the
 342          *     last transaction.
 343          *  USBFS_ep0Count - counts the data loaded to the SIE memory in
 344          *     current packet.
 345          *  USBFS_lastPacketSize - remembers the USBFS_ep0Count value for the
 346          *     next packet.
 347          *  USBFS_transferByteCount - sum of the previous bytes transferred
 348          *     on previous packets(sum of USBFS_lastPacketSize)
 349          *  USBFS_ep0Toggle - inverted
 350          *  USBFS_ep0Mode  - prepare for mode register content.
 351          *  USBFS_transferState - set to TRANS_STATE_CONTROL_READ
 352          *
 353          * \reentrant
 354          *  No.
 355          *
 356          *******************************************************************************/
 357          void USBFS_LoadEP0(void) 
 358          {
 359   1          uint8 ep0Count = 0u;
 360   1      
 361   1          /* Update the transfer byte count from the last transaction */
 362   1          USBFS_transferByteCount += USBFS_lastPacketSize;
 363   1      
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 7   

 364   1          /* Now load the next transaction */
 365   1          while ((USBFS_currentTD.count > 0u) && (ep0Count < 8u))
 366   1          {
 367   2              USBFS_EP0_DR_BASE.epData[ep0Count] = (uint8) *USBFS_currentTD.pData;
 368   2              USBFS_currentTD.pData = &USBFS_currentTD.pData[1u];
 369   2              ep0Count++;
 370   2              USBFS_currentTD.count--;
 371   2          }
 372   1      
 373   1          /* Support zero-length packet */
 374   1          if ((USBFS_lastPacketSize == 8u) || (ep0Count > 0u))
 375   1          {
 376   2              /* Update the data toggle */
 377   2              USBFS_ep0Toggle ^= USBFS_EP0_CNT_DATA_TOGGLE;
 378   2              /* Set the Mode Register  */
 379   2              USBFS_ep0Mode = USBFS_MODE_ACK_IN_STATUS_OUT;
 380   2              /* Update the state (or stay the same) */
 381   2              USBFS_transferState = USBFS_TRANS_STATE_CONTROL_READ;
 382   2          }
 383   1          else
 384   1          {
 385   2              /* Expect Status Stage Out */
 386   2              USBFS_ep0Mode = USBFS_MODE_STATUS_OUT_ONLY;
 387   2              /* Update the state (or stay the same) */
 388   2              USBFS_transferState = USBFS_TRANS_STATE_CONTROL_READ;
 389   2          }
 390   1      
 391   1          /* Save the packet size for next time */
 392   1          USBFS_ep0Count =       (uint8) ep0Count;
 393   1          USBFS_lastPacketSize = (uint8) ep0Count;
 394   1      }
 395          
 396          
 397          /*******************************************************************************
 398          * Function Name: USBFS_InitControlRead
 399          ****************************************************************************//**
 400          *
 401          *  Initialize a control read transaction. It is used to send data to the host.
 402          *  The following global variables should be initialized before this function
 403          *  called. To send zero length packet use InitZeroLengthControlTransfer
 404          *  function.
 405          *
 406          *
 407          * \return
 408          *  requestHandled state.
 409          *
 410          * \globalvars
 411          *  USBFS_currentTD.count - counts of data to be sent.
 412          *  USBFS_currentTD.pData - data pointer.
 413          *
 414          * \reentrant
 415          *  No.
 416          *
 417          *******************************************************************************/
 418          uint8 USBFS_InitControlRead(void) 
 419          {
 420   1          uint16 xferCount;
 421   1      
 422   1          if (USBFS_currentTD.count == 0u)
 423   1          {
 424   2              (void) USBFS_InitZeroLengthControlTransfer();
 425   2          }
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 8   

 426   1          else
 427   1          {
 428   2              /* Set up the state machine */
 429   2              USBFS_transferState = USBFS_TRANS_STATE_CONTROL_READ;
 430   2              
 431   2              /* Set the toggle, it gets updated in LoadEP */
 432   2              USBFS_ep0Toggle = 0u;
 433   2              
 434   2              /* Initialize the Status Block */
 435   2              USBFS_InitializeStatusBlock();
 436   2              
 437   2              xferCount = ((uint16)((uint16) USBFS_lengthHiReg << 8u) | ((uint16) USBFS_lengthLoReg));
 438   2      
 439   2              if (USBFS_currentTD.count > xferCount)
 440   2              {
 441   3                  USBFS_currentTD.count = xferCount;
 442   3              }
 443   2              
 444   2              USBFS_LoadEP0();
 445   2          }
 446   1      
 447   1          return (USBFS_TRUE);
 448   1      }
 449          
 450          
 451          /*******************************************************************************
 452          * Function Name: USBFS_InitZeroLengthControlTransfer
 453          ****************************************************************************//**
 454          *
 455          *  Initialize a zero length data IN transfer.
 456          *
 457          * \return
 458          *  requestHandled state.
 459          *
 460          * \globalvars
 461          *  USBFS_ep0Toggle - set to EP0_CNT_DATA_TOGGLE
 462          *  USBFS_ep0Mode  - prepare for mode register content.
 463          *  USBFS_transferState - set to TRANS_STATE_CONTROL_READ
 464          *  USBFS_ep0Count - cleared, means the zero-length packet.
 465          *  USBFS_lastPacketSize - cleared.
 466          *
 467          * \reentrant
 468          *  No.
 469          *
 470          *******************************************************************************/
 471          uint8 USBFS_InitZeroLengthControlTransfer(void)
 472                                                          
 473          {
 474   1          /* Update the state */
 475   1          USBFS_transferState = USBFS_TRANS_STATE_CONTROL_READ;
 476   1          
 477   1          /* Set the data toggle */
 478   1          USBFS_ep0Toggle = USBFS_EP0_CNT_DATA_TOGGLE;
 479   1          
 480   1          /* Set the Mode Register  */
 481   1          USBFS_ep0Mode = USBFS_MODE_ACK_IN_STATUS_OUT;
 482   1          
 483   1          /* Save the packet size for next time */
 484   1          USBFS_lastPacketSize = 0u;
 485   1          
 486   1          USBFS_ep0Count = 0u;
 487   1      
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 9   

 488   1          return (USBFS_TRUE);
 489   1      }
 490          
 491          
 492          /*******************************************************************************
 493          * Function Name: USBFS_ControlReadDataStage
 494          ****************************************************************************//**
 495          *
 496          *  Handle the Data Stage of a control read transfer.
 497          *
 498          *
 499          * \reentrant
 500          *  No.
 501          *
 502          *******************************************************************************/
 503          void USBFS_ControlReadDataStage(void) 
 504          
 505          {
 506   1          USBFS_LoadEP0();
 507   1      }
 508          
 509          
 510          /*******************************************************************************
 511          * Function Name: USBFS_ControlReadStatusStage
 512          ****************************************************************************//**
 513          *
 514          *  Handle the Status Stage of a control read transfer.
 515          *
 516          *
 517          * \globalvars
 518          *  USBFS_USBFS_transferByteCount - updated with last packet size.
 519          *  USBFS_transferState - set to TRANS_STATE_IDLE.
 520          *  USBFS_ep0Mode  - set to MODE_STALL_IN_OUT.
 521          *
 522          * \reentrant
 523          *  No.
 524          *
 525          *******************************************************************************/
 526          void USBFS_ControlReadStatusStage(void) 
 527          {
 528   1          /* Update the transfer byte count */
 529   1          USBFS_transferByteCount += USBFS_lastPacketSize;
 530   1          
 531   1          /* Go Idle */
 532   1          USBFS_transferState = USBFS_TRANS_STATE_IDLE;
 533   1          
 534   1          /* Update the completion block */
 535   1          USBFS_UpdateStatusBlock(USBFS_XFER_STATUS_ACK);
 536   1          
 537   1          /* We expect no more data, so stall INs and OUTs */
 538   1          USBFS_ep0Mode = USBFS_MODE_STALL_IN_OUT;
 539   1      }
 540          
 541          
 542          /*******************************************************************************
 543          * Function Name: USBFS_InitControlWrite
 544          ****************************************************************************//**
 545          *
 546          *  Initialize a control write transaction
 547          *
 548          * \return
 549          *  requestHandled state.
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 10  

 550          *
 551          * \globalvars
 552          *  USBFS_USBFS_transferState - set to TRANS_STATE_CONTROL_WRITE
 553          *  USBFS_ep0Toggle - set to EP0_CNT_DATA_TOGGLE
 554          *  USBFS_ep0Mode  - set to MODE_ACK_OUT_STATUS_IN
 555          *
 556          * \reentrant
 557          *  No.
 558          *
 559          *******************************************************************************/
 560          uint8 USBFS_InitControlWrite(void) 
 561          {
 562   1          uint16 xferCount;
 563   1      
 564   1          /* Set up the state machine */
 565   1          USBFS_transferState = USBFS_TRANS_STATE_CONTROL_WRITE;
 566   1          
 567   1          /* This might not be necessary */
 568   1          USBFS_ep0Toggle = USBFS_EP0_CNT_DATA_TOGGLE;
 569   1          
 570   1          /* Initialize the Status Block */
 571   1          USBFS_InitializeStatusBlock();
 572   1      
 573   1          xferCount = ((uint16)((uint16) USBFS_lengthHiReg << 8u) | ((uint16) USBFS_lengthLoReg));
 574   1      
 575   1          if (USBFS_currentTD.count > xferCount)
 576   1          {
 577   2              USBFS_currentTD.count = xferCount;
 578   2          }
 579   1      
 580   1          /* Expect Data or Status Stage */
 581   1          USBFS_ep0Mode = USBFS_MODE_ACK_OUT_STATUS_IN;
 582   1      
 583   1          return(USBFS_TRUE);
 584   1      }
 585          
 586          
 587          /*******************************************************************************
 588          * Function Name: USBFS_ControlWriteDataStage
 589          ****************************************************************************//**
 590          *
 591          *  Handle the Data Stage of a control write transfer
 592          *       1. Get the data (We assume the destination was validated previously)
 593          *       2. Update the count and data toggle
 594          *       3. Update the mode register for the next transaction
 595          *
 596          *
 597          * \globalvars
 598          *  USBFS_transferByteCount - Update the transfer byte count from the
 599          *    last transaction.
 600          *  USBFS_ep0Count - counts the data loaded from the SIE memory
 601          *    in current packet.
 602          *  USBFS_transferByteCount - sum of the previous bytes transferred
 603          *    on previous packets(sum of USBFS_lastPacketSize)
 604          *  USBFS_ep0Toggle - inverted
 605          *  USBFS_ep0Mode  - set to MODE_ACK_OUT_STATUS_IN.
 606          *
 607          * \reentrant
 608          *  No.
 609          *
 610          *******************************************************************************/
 611          void USBFS_ControlWriteDataStage(void) 
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 11  

 612          {
 613   1          uint8 ep0Count;
 614   1          uint8 regIndex = 0u;
 615   1      
 616   1          ep0Count = (USBFS_EP0_CNT_REG & USBFS_EPX_CNT0_MASK) - USBFS_EPX_CNTX_CRC_COUNT;
 617   1      
 618   1          USBFS_transferByteCount += (uint8)ep0Count;
 619   1      
 620   1          while ((USBFS_currentTD.count > 0u) && (ep0Count > 0u))
 621   1          {
 622   2              *USBFS_currentTD.pData = (uint8) USBFS_EP0_DR_BASE.epData[regIndex];
 623   2              USBFS_currentTD.pData = &USBFS_currentTD.pData[1u];
 624   2              regIndex++;
 625   2              ep0Count--;
 626   2              USBFS_currentTD.count--;
 627   2          }
 628   1          
 629   1          USBFS_ep0Count = (uint8)ep0Count;
 630   1          
 631   1          /* Update the data toggle */
 632   1          USBFS_ep0Toggle ^= USBFS_EP0_CNT_DATA_TOGGLE;
 633   1          
 634   1          /* Expect Data or Status Stage */
 635   1          USBFS_ep0Mode = USBFS_MODE_ACK_OUT_STATUS_IN;
 636   1      }
 637          
 638          
 639          /*******************************************************************************
 640          * Function Name: USBFS_ControlWriteStatusStage
 641          ****************************************************************************//**
 642          *
 643          *  Handle the Status Stage of a control write transfer
 644          *
 645          * \globalvars
 646          *  USBFS_transferState - set to TRANS_STATE_IDLE.
 647          *  USBFS_USBFS_ep0Mode  - set to MODE_STALL_IN_OUT.
 648          *
 649          * \reentrant
 650          *  No.
 651          *
 652          *******************************************************************************/
 653          void USBFS_ControlWriteStatusStage(void) 
 654          {
 655   1          /* Go Idle */
 656   1          USBFS_transferState = USBFS_TRANS_STATE_IDLE;
 657   1          
 658   1          /* Update the completion block */    
 659   1          USBFS_UpdateStatusBlock(USBFS_XFER_STATUS_ACK);
 660   1          
 661   1          /* We expect no more data, so stall INs and OUTs */
 662   1          USBFS_ep0Mode = USBFS_MODE_STALL_IN_OUT;
 663   1      }
 664          
 665          
 666          /*******************************************************************************
 667          * Function Name: USBFS_InitNoDataControlTransfer
 668          ****************************************************************************//**
 669          *
 670          *  Initialize a no data control transfer
 671          *
 672          * \return
 673          *  requestHandled state.
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 12  

 674          *
 675          * \globalvars
 676          *  USBFS_transferState - set to TRANS_STATE_NO_DATA_CONTROL.
 677          *  USBFS_ep0Mode  - set to MODE_STATUS_IN_ONLY.
 678          *  USBFS_ep0Count - cleared.
 679          *  USBFS_ep0Toggle - set to EP0_CNT_DATA_TOGGLE
 680          *
 681          * \reentrant
 682          *  No.
 683          *
 684          *******************************************************************************/
 685          uint8 USBFS_InitNoDataControlTransfer(void) 
 686          {
 687   1          USBFS_transferState = USBFS_TRANS_STATE_NO_DATA_CONTROL;
 688   1          USBFS_ep0Mode       = USBFS_MODE_STATUS_IN_ONLY;
 689   1          USBFS_ep0Toggle     = USBFS_EP0_CNT_DATA_TOGGLE;
 690   1          USBFS_ep0Count      = 0u;
 691   1      
 692   1          return (USBFS_TRUE);
 693   1      }
 694          
 695          
 696          /*******************************************************************************
 697          * Function Name: USBFS_NoDataControlStatusStage
 698          ****************************************************************************//**
 699          *  Handle the Status Stage of a no data control transfer.
 700          *
 701          *  SET_ADDRESS is special, since we need to receive the status stage with
 702          *  the old address.
 703          *
 704          * \globalvars
 705          *  USBFS_transferState - set to TRANS_STATE_IDLE.
 706          *  USBFS_ep0Mode  - set to MODE_STALL_IN_OUT.
 707          *  USBFS_ep0Toggle - set to EP0_CNT_DATA_TOGGLE
 708          *  USBFS_deviceAddress - used to set new address and cleared
 709          *
 710          * \reentrant
 711          *  No.
 712          *
 713          *******************************************************************************/
 714          void USBFS_NoDataControlStatusStage(void) 
 715          {
 716   1          if (0u != USBFS_deviceAddress)
 717   1          {
 718   2              /* Update device address if we got new address. */
 719   2              USBFS_CR0_REG = (uint8) USBFS_deviceAddress | USBFS_CR0_ENABLE;
 720   2              USBFS_deviceAddress = 0u;
 721   2          }
 722   1      
 723   1          USBFS_transferState = USBFS_TRANS_STATE_IDLE;
 724   1          
 725   1          /* Update the completion block. */
 726   1          USBFS_UpdateStatusBlock(USBFS_XFER_STATUS_ACK);
 727   1          
 728   1          /* Stall IN and OUT, no more data is expected. */
 729   1          USBFS_ep0Mode = USBFS_MODE_STALL_IN_OUT;
 730   1      }
 731          
 732          
 733          /*******************************************************************************
 734          * Function Name: USBFS_UpdateStatusBlock
 735          ****************************************************************************//**
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 13  

 736          *
 737          *  Update the Completion Status Block for a Request.  The block is updated
 738          *  with the completion code the USBFS_transferByteCount.  The
 739          *  StatusBlock Pointer is set to NULL.
 740          *
 741          *  completionCode - status.
 742          *
 743          *
 744          * \globalvars
 745          *  USBFS_currentTD.pStatusBlock->status - updated by the
 746          *    completionCode parameter.
 747          *  USBFS_currentTD.pStatusBlock->length - updated.
 748          *  USBFS_currentTD.pStatusBlock - cleared.
 749          *
 750          * \reentrant
 751          *  No.
 752          *
 753          *******************************************************************************/
 754          void USBFS_UpdateStatusBlock(uint8 completionCode) 
 755          {
 756   1          if (USBFS_currentTD.pStatusBlock != NULL)
 757   1          {
 758   2              USBFS_currentTD.pStatusBlock->status = completionCode;
 759   2              USBFS_currentTD.pStatusBlock->length = USBFS_transferByteCount;
 760   2              USBFS_currentTD.pStatusBlock = NULL;
 761   2          }
 762   1      }
 763          
 764          
 765          /*******************************************************************************
 766          * Function Name: USBFS_InitializeStatusBlock
 767          ****************************************************************************//**
 768          *
 769          *  Initialize the Completion Status Block for a Request.  The completion
 770          *  code is set to USB_XFER_IDLE.
 771          *
 772          *  Also, initializes USBFS_transferByteCount.  Save some space,
 773          *  this is the only consumer.
 774          *
 775          * \globalvars
 776          *  USBFS_currentTD.pStatusBlock->status - set to XFER_IDLE.
 777          *  USBFS_currentTD.pStatusBlock->length - cleared.
 778          *  USBFS_transferByteCount - cleared.
 779          *
 780          * \reentrant
 781          *  No.
 782          *
 783          *******************************************************************************/
 784          void USBFS_InitializeStatusBlock(void) 
 785          {
 786   1          USBFS_transferByteCount = 0u;
 787   1          
 788   1          if (USBFS_currentTD.pStatusBlock != NULL)
 789   1          {
 790   2              USBFS_currentTD.pStatusBlock->status = USBFS_XFER_IDLE;
 791   2              USBFS_currentTD.pStatusBlock->length = 0u;
 792   2          }
 793   1      }
 794          
 795          
 796          /* [] END OF FILE */
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 14  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION USBFS_EP_0_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C085              PUSH    DPH1
000A C084              PUSH    DPL1
000C C086              PUSH    DPS
000E 758600            MOV     DPS,#00H
0011 C000        E     PUSH    ?C?XPAGE1SFR
0013 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0016 C0D0              PUSH    PSW
0018 75D000            MOV     PSW,#00H
001B C000              PUSH    AR0
001D C001              PUSH    AR1
001F C002              PUSH    AR2
0021 C003              PUSH    AR3
0023 C004              PUSH    AR4
0025 C005              PUSH    AR5
0027 C006              PUSH    AR6
0029 C007              PUSH    AR7
                                           ; SOURCE LINE # 94
                                           ; SOURCE LINE # 103
002B 906028            MOV     DPTR,#06028H
002E E0                MOVX    A,@DPTR
002F 900000      R     MOV     DPTR,#tempReg
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 104
0033 E0                MOVX    A,@DPTR
0034 FF                MOV     R7,A
0035 5410              ANL     A,#010H
0037 7003              JNZ     $ + 5H
0039 020000      R     LJMP    ?C0021
                                           ; SOURCE LINE # 105
                                           ; SOURCE LINE # 106
003C A3                INC     DPTR
003D 7401              MOV     A,#01H
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 107
0040 EF                MOV     A,R7
0041 5480              ANL     A,#080H
0043 6021              JZ      ?C0002
                                           ; SOURCE LINE # 108
                                           ; SOURCE LINE # 109
0045 900000      R     MOV     DPTR,#tempReg
0048 E0                MOVX    A,@DPTR
0049 540F              ANL     A,#0FH
004B 6401              XRL     A,#01H
004D 6005              JZ      ?C0003
                                           ; SOURCE LINE # 110
                                           ; SOURCE LINE # 112
004F A3                INC     DPTR
0050 E4                CLR     A
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 113
0052 8031              SJMP    ?C0006
0054         ?C0003:
                                           ; SOURCE LINE # 115
                                           ; SOURCE LINE # 116
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 15  

0054 120000      R     LCALL   USBFS_HandleSetup
                                           ; SOURCE LINE # 118
0057 900000      R     MOV     DPTR,#USBFS_ep0Mode
005A E0                MOVX    A,@DPTR
005B 5480              ANL     A,#080H
005D 6026              JZ      ?C0006
                                           ; SOURCE LINE # 119
                                           ; SOURCE LINE # 121
005F 900000      R     MOV     DPTR,#modifyReg
0062 E4                CLR     A
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 122
                                           ; SOURCE LINE # 123
                                           ; SOURCE LINE # 124
0064 801F              SJMP    ?C0006
0066         ?C0002:
                                           ; SOURCE LINE # 125
0066 900000      R     MOV     DPTR,#tempReg
0069 E0                MOVX    A,@DPTR
006A 5440              ANL     A,#040H
006C 6005              JZ      ?C0007
                                           ; SOURCE LINE # 126
                                           ; SOURCE LINE # 127
006E 120000      R     LCALL   USBFS_HandleIN
                                           ; SOURCE LINE # 128
0071 8012              SJMP    ?C0006
0073         ?C0007:
                                           ; SOURCE LINE # 129
0073 900000      R     MOV     DPTR,#tempReg
0076 E0                MOVX    A,@DPTR
0077 5420              ANL     A,#020H
0079 6005              JZ      ?C0009
                                           ; SOURCE LINE # 130
                                           ; SOURCE LINE # 131
007B 120000      R     LCALL   USBFS_HandleOUT
                                           ; SOURCE LINE # 132
007E 8005              SJMP    ?C0006
0080         ?C0009:
                                           ; SOURCE LINE # 134
                                           ; SOURCE LINE # 135
0080 900000      R     MOV     DPTR,#modifyReg
0083 E4                CLR     A
0084 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 136
0085         ?C0006:
                                           ; SOURCE LINE # 139
0085 900000      R     MOV     DPTR,#modifyReg
0088 E0                MOVX    A,@DPTR
0089 6057              JZ      ?C0021
                                           ; SOURCE LINE # 140
                                           ; SOURCE LINE # 142
008B 906028            MOV     DPTR,#06028H
008E E0                MOVX    A,@DPTR
008F 900000      R     MOV     DPTR,#tempReg
0092 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 145
0093 E0                MOVX    A,@DPTR
0094 5480              ANL     A,#080H
0096 704A              JNZ     ?C0021
                                           ; SOURCE LINE # 146
                                           ; SOURCE LINE # 148
0098 900000      R     MOV     DPTR,#USBFS_ep0Count
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 16  

009B E0                MOVX    A,@DPTR
009C FF                MOV     R7,A
009D 900000      R     MOV     DPTR,#USBFS_ep0Toggle
00A0 E0                MOVX    A,@DPTR
00A1 4F                ORL     A,R7
00A2 900000      R     MOV     DPTR,#tempReg
00A5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 149
00A6 E0                MOVX    A,@DPTR
00A7 FF                MOV     R7,A
00A8 906029            MOV     DPTR,#06029H
00AB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 152
00AC E0                MOVX    A,@DPTR
00AD FE                MOV     R6,A
00AE EF                MOV     A,R7
00AF 6E                XRL     A,R6
00B0 7030              JNZ     ?C0021
                                           ; SOURCE LINE # 153
00B2         ?C0016:
                                           ; SOURCE LINE # 156
                                           ; SOURCE LINE # 158
00B2 900000      R     MOV     DPTR,#USBFS_ep0Mode
00B5 E0                MOVX    A,@DPTR
00B6 900000      R     MOV     DPTR,#modifyReg
00B9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 161
00BA 906028            MOV     DPTR,#06028H
00BD E0                MOVX    A,@DPTR
00BE 5480              ANL     A,#080H
00C0 900000      R     MOV     DPTR,#tempReg
00C3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 164
00C4 E0                MOVX    A,@DPTR
00C5 700F              JNZ     ?C0014
                                           ; SOURCE LINE # 165
                                           ; SOURCE LINE # 167
00C7 900000      R     MOV     DPTR,#USBFS_ep0Mode
00CA E0                MOVX    A,@DPTR
00CB 906028            MOV     DPTR,#06028H
00CE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 170
00CF E0                MOVX    A,@DPTR
00D0 540F              ANL     A,#0FH
00D2 900000      R     MOV     DPTR,#modifyReg
00D5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 171
                                           ; SOURCE LINE # 172
00D6         ?C0014:
                                           ; SOURCE LINE # 173
00D6 900000      R     MOV     DPTR,#USBFS_ep0Mode
00D9 E0                MOVX    A,@DPTR
00DA FF                MOV     R7,A
00DB 900000      R     MOV     DPTR,#modifyReg
00DE E0                MOVX    A,@DPTR
00DF B507D0            CJNE    A,AR7,?C0016
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
                                           ; SOURCE LINE # 176
                                           ; SOURCE LINE # 177
                                           ; SOURCE LINE # 179
                                           ; SOURCE LINE # 184
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 17  

00E2         ?C0021:
00E2 D007              POP     AR7
00E4 D006              POP     AR6
00E6 D005              POP     AR5
00E8 D004              POP     AR4
00EA D003              POP     AR3
00EC D002              POP     AR2
00EE D001              POP     AR1
00F0 D000              POP     AR0
00F2 D0D0              POP     PSW
00F4 D000        E     POP     ?C?XPAGE1SFR
00F6 D086              POP     DPS
00F8 D084              POP     DPL1
00FA D085              POP     DPH1
00FC D082              POP     DPL
00FE D083              POP     DPH
0100 D0F0              POP     B
0102 D0E0              POP     ACC
0104 32                RETI    
             ; FUNCTION USBFS_EP_0_ISR (END)

             ; FUNCTION USBFS_HandleSetup (BEGIN)
                                           ; SOURCE LINE # 198
                                           ; SOURCE LINE # 199
                                           ; SOURCE LINE # 205
0000 906028            MOV     DPTR,#06028H
0003 E0                MOVX    A,@DPTR
0004 900000      R     MOV     DPTR,#requestHandled
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 206
0008 E0                MOVX    A,@DPTR
0009 906028            MOV     DPTR,#06028H
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 207
000D E0                MOVX    A,@DPTR
000E 900000      R     MOV     DPTR,#requestHandled
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 209
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 5480              ANL     A,#080H
0016 6006              JZ      ?C0022
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 212
0018 900000      R     MOV     DPTR,#USBFS_ep0Mode
001B EF                MOV     A,R7
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 213
001D 22                RET     
001E         ?C0022:
                                           ; SOURCE LINE # 215
                                           ; SOURCE LINE # 217
001E 7F02              MOV     R7,#02H
0020 120000      R     LCALL   _USBFS_UpdateStatusBlock
                                           ; SOURCE LINE # 220
0023 906000            MOV     DPTR,#06000H
0026 E0                MOVX    A,@DPTR
0027 5460              ANL     A,#060H
0029 24E0              ADD     A,#0E0H
002B 6012              JZ      ?C0026
002D 24E0              ADD     A,#0E0H
002F 6018              JZ      ?C0027
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 18  

0031 2440              ADD     A,#040H
0033 701E              JNZ     ?C0028
                                           ; SOURCE LINE # 221
                                           ; SOURCE LINE # 222
0035         ?C0025:
                                           ; SOURCE LINE # 223
0035 120000      E     LCALL   USBFS_HandleStandardRqst
0038 900000      R     MOV     DPTR,#requestHandled
003B EF                MOV     A,R7
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 224
003D 8019              SJMP    ?C0024
                                           ; SOURCE LINE # 226
003F         ?C0026:
                                           ; SOURCE LINE # 227
003F 120000      E     LCALL   USBFS_DispatchClassRqst
0042 900000      R     MOV     DPTR,#requestHandled
0045 EF                MOV     A,R7
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 228
0047 800F              SJMP    ?C0024
                                           ; SOURCE LINE # 230
0049         ?C0027:
                                           ; SOURCE LINE # 231
0049 120000      E     LCALL   USBFS_HandleVendorRqst
004C 900000      R     MOV     DPTR,#requestHandled
004F EF                MOV     A,R7
0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 232
0051 8005              SJMP    ?C0024
                                           ; SOURCE LINE # 234
0053         ?C0028:
                                           ; SOURCE LINE # 235
0053 E4                CLR     A
0054 900000      R     MOV     DPTR,#requestHandled
0057 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 236
                                           ; SOURCE LINE # 237
0058         ?C0024:
                                           ; SOURCE LINE # 240
0058 900000      R     MOV     DPTR,#requestHandled
005B E0                MOVX    A,@DPTR
005C 7006              JNZ     ?C0030
                                           ; SOURCE LINE # 241
                                           ; SOURCE LINE # 242
005E 900000      R     MOV     DPTR,#USBFS_ep0Mode
0061 7403              MOV     A,#03H
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 243
                                           ; SOURCE LINE # 244
                                           ; SOURCE LINE # 245
0064         ?C0030:
0064 22                RET     
             ; FUNCTION USBFS_HandleSetup (END)

             ; FUNCTION USBFS_HandleIN (BEGIN)
                                           ; SOURCE LINE # 259
                                           ; SOURCE LINE # 260
                                           ; SOURCE LINE # 261
0000 900000      R     MOV     DPTR,#USBFS_transferState
0003 E0                MOVX    A,@DPTR
0004 24FC              ADD     A,#0FCH
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 19  

0006 600C              JZ      ?C0034
0008 24FE              ADD     A,#0FEH
000A 600C              JZ      ?C0035
000C 2404              ADD     A,#04H
000E 700B              JNZ     ?C0037
                                           ; SOURCE LINE # 262
                                           ; SOURCE LINE # 263
                                           ; SOURCE LINE # 264
                                           ; SOURCE LINE # 266
0010         ?C0033:
                                           ; SOURCE LINE # 267
0010 120000      R     LCALL   USBFS_ControlReadDataStage
                                           ; SOURCE LINE # 268
0013 22                RET     
                                           ; SOURCE LINE # 270
0014         ?C0034:
                                           ; SOURCE LINE # 271
0014 120000      R     LCALL   USBFS_ControlWriteStatusStage
                                           ; SOURCE LINE # 272
0017 22                RET     
                                           ; SOURCE LINE # 274
0018         ?C0035:
                                           ; SOURCE LINE # 275
0018 120000      R     LCALL   USBFS_NoDataControlStatusStage
                                           ; SOURCE LINE # 276
                                           ; SOURCE LINE # 278
                                           ; SOURCE LINE # 279
                                           ; SOURCE LINE # 280
                                           ; SOURCE LINE # 281
001B         ?C0037:
001B 22                RET     
             ; FUNCTION USBFS_HandleIN (END)

             ; FUNCTION USBFS_HandleOUT (BEGIN)
                                           ; SOURCE LINE # 295
                                           ; SOURCE LINE # 296
                                           ; SOURCE LINE # 297
0000 900000      R     MOV     DPTR,#USBFS_transferState
0003 E0                MOVX    A,@DPTR
0004 24FC              ADD     A,#0FCH
0006 600C              JZ      ?C0041
0008 24FE              ADD     A,#0FEH
000A 600C              JZ      ?C0042
000C 2404              ADD     A,#04H
000E 7013              JNZ     ?C0044
                                           ; SOURCE LINE # 298
                                           ; SOURCE LINE # 299
                                           ; SOURCE LINE # 300
                                           ; SOURCE LINE # 302
0010         ?C0040:
                                           ; SOURCE LINE # 303
0010 120000      R     LCALL   USBFS_ControlReadStatusStage
                                           ; SOURCE LINE # 304
0013 22                RET     
                                           ; SOURCE LINE # 306
0014         ?C0041:
                                           ; SOURCE LINE # 307
0014 120000      R     LCALL   USBFS_ControlWriteDataStage
                                           ; SOURCE LINE # 308
0017 22                RET     
                                           ; SOURCE LINE # 310
0018         ?C0042:
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 20  

                                           ; SOURCE LINE # 312
0018 7F03              MOV     R7,#03H
001A 120000      R     LCALL   _USBFS_UpdateStatusBlock
                                           ; SOURCE LINE # 315
001D 900000      R     MOV     DPTR,#USBFS_ep0Mode
0020 7403              MOV     A,#03H
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 316
                                           ; SOURCE LINE # 318
                                           ; SOURCE LINE # 320
                                           ; SOURCE LINE # 321
                                           ; SOURCE LINE # 322
0023         ?C0044:
0023 22                RET     
             ; FUNCTION USBFS_HandleOUT (END)

             ; FUNCTION USBFS_LoadEP0 (BEGIN)
                                           ; SOURCE LINE # 357
                                           ; SOURCE LINE # 358
                                           ; SOURCE LINE # 359
;---- Variable 'ep0Count' assigned to Register 'R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
                                           ; SOURCE LINE # 362
0002 900000      R     MOV     DPTR,#USBFS_lastPacketSize
0005 E0                MOVX    A,@DPTR
0006 FF                MOV     R7,A
0007 900000      R     MOV     DPTR,#USBFS_transferByteCount
000A E4                CLR     A
000B 8FF0              MOV     B,R7
000D 120000      E     LCALL   ?C?IILDX
0010         ?C0045:
                                           ; SOURCE LINE # 365
0010 D3                SETB    C
0011 900000      R     MOV     DPTR,#USBFS_currentTD+01H
0014 E0                MOVX    A,@DPTR
0015 9400              SUBB    A,#00H
0017 900000      R     MOV     DPTR,#USBFS_currentTD
001A E0                MOVX    A,@DPTR
001B 9400              SUBB    A,#00H
001D 403A              JC      ?C0046
001F ED                MOV     A,R5
0020 9408              SUBB    A,#08H
0022 5035              JNC     ?C0046
                                           ; SOURCE LINE # 366
                                           ; SOURCE LINE # 367
0024 900000      R     MOV     DPTR,#USBFS_currentTD+02H
0027 120000      E     LCALL   ?C?PLDXDATA
002A 120000      E     LCALL   ?C?CLDPTR
002D FF                MOV     R7,A
002E E4                CLR     A
002F 2D                ADD     A,R5
0030 F582              MOV     DPL,A
0032 E4                CLR     A
0033 3460              ADDC    A,#060H
0035 F583              MOV     DPH,A
0037 EF                MOV     A,R7
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 368
0039 900000      R     MOV     DPTR,#USBFS_currentTD+02H
003C 120000      E     LCALL   ?C?PLDXDATA
003F E9                MOV     A,R1
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 21  

0040 2401              ADD     A,#01H
0042 F9                MOV     R1,A
0043 E4                CLR     A
0044 3A                ADDC    A,R2
0045 FA                MOV     R2,A
0046 900000      R     MOV     DPTR,#USBFS_currentTD+02H
0049 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 369
004C 0D                INC     R5
                                           ; SOURCE LINE # 370
004D 900000      R     MOV     DPTR,#USBFS_currentTD
0050 74FF              MOV     A,#0FFH
0052 F5F0              MOV     B,A
0054 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 371
0057 80B7              SJMP    ?C0045
0059         ?C0046:
                                           ; SOURCE LINE # 374
0059 900000      R     MOV     DPTR,#USBFS_lastPacketSize
005C E0                MOVX    A,@DPTR
005D 6408              XRL     A,#08H
005F 6006              JZ      ?C0048
0061 ED                MOV     A,R5
0062 D3                SETB    C
0063 9400              SUBB    A,#00H
0065 4015              JC      ?C0047
0067         ?C0048:
                                           ; SOURCE LINE # 375
                                           ; SOURCE LINE # 377
0067 900000      R     MOV     DPTR,#USBFS_ep0Toggle
006A E0                MOVX    A,@DPTR
006B 6480              XRL     A,#080H
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 379
006E 900000      R     MOV     DPTR,#USBFS_ep0Mode
0071 740F              MOV     A,#0FH
0073 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 381
0074 900000      R     MOV     DPTR,#USBFS_transferState
0077 7402              MOV     A,#02H
0079 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 382
007A 800A              SJMP    ?C0049
007C         ?C0047:
                                           ; SOURCE LINE # 384
                                           ; SOURCE LINE # 386
007C 900000      R     MOV     DPTR,#USBFS_ep0Mode
007F 7402              MOV     A,#02H
0081 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 388
0082 900000      R     MOV     DPTR,#USBFS_transferState
0085 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 389
0086         ?C0049:
                                           ; SOURCE LINE # 392
0086 900000      R     MOV     DPTR,#USBFS_ep0Count
0089 ED                MOV     A,R5
008A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 393
008B 900000      R     MOV     DPTR,#USBFS_lastPacketSize
008E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 394
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 22  

008F 22                RET     
             ; FUNCTION USBFS_LoadEP0 (END)

             ; FUNCTION USBFS_InitControlRead (BEGIN)
                                           ; SOURCE LINE # 418
                                           ; SOURCE LINE # 419
                                           ; SOURCE LINE # 422
0000 900000      R     MOV     DPTR,#USBFS_currentTD
0003 E0                MOVX    A,@DPTR
0004 7002              JNZ     ?C0071
0006 A3                INC     DPTR
0007 E0                MOVX    A,@DPTR
0008         ?C0071:
0008 7005              JNZ     ?C0051
                                           ; SOURCE LINE # 423
                                           ; SOURCE LINE # 424
000A 120000      R     LCALL   USBFS_InitZeroLengthControlTransfer
                                           ; SOURCE LINE # 425
000D 8030              SJMP    ?C0052
000F         ?C0051:
                                           ; SOURCE LINE # 427
                                           ; SOURCE LINE # 429
000F 900000      R     MOV     DPTR,#USBFS_transferState
0012 7402              MOV     A,#02H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 432
0015 E4                CLR     A
0016 900000      R     MOV     DPTR,#USBFS_ep0Toggle
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 435
001A 120000      R     LCALL   USBFS_InitializeStatusBlock
                                           ; SOURCE LINE # 437
001D 906007            MOV     DPTR,#06007H
0020 E0                MOVX    A,@DPTR
0021 FE                MOV     R6,A
0022 906006            MOV     DPTR,#06006H
0025 E0                MOVX    A,@DPTR
0026 FD                MOV     R5,A
0027 EE                MOV     A,R6
0028 ED                MOV     A,R5
0029 FF                MOV     R7,A
;---- Variable 'xferCount' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 439
002A D3                SETB    C
002B 900000      R     MOV     DPTR,#USBFS_currentTD+01H
002E E0                MOVX    A,@DPTR
002F 9F                SUBB    A,R7
0030 900000      R     MOV     DPTR,#USBFS_currentTD
0033 E0                MOVX    A,@DPTR
0034 9E                SUBB    A,R6
0035 4005              JC      ?C0053
                                           ; SOURCE LINE # 440
                                           ; SOURCE LINE # 441
0037 EE                MOV     A,R6
0038 F0                MOVX    @DPTR,A
0039 A3                INC     DPTR
003A EF                MOV     A,R7
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 442
003C         ?C0053:
                                           ; SOURCE LINE # 444
003C 120000      R     LCALL   USBFS_LoadEP0
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 23  

                                           ; SOURCE LINE # 445
003F         ?C0052:
                                           ; SOURCE LINE # 447
003F 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 448
0041         ?C0054:
0041 22                RET     
             ; FUNCTION USBFS_InitControlRead (END)

             ; FUNCTION USBFS_InitZeroLengthControlTransfer (BEGIN)
                                           ; SOURCE LINE # 471
                                           ; SOURCE LINE # 473
                                           ; SOURCE LINE # 475
0000 900000      R     MOV     DPTR,#USBFS_transferState
0003 7402              MOV     A,#02H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 478
0006 900000      R     MOV     DPTR,#USBFS_ep0Toggle
0009 7480              MOV     A,#080H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 481
000C 900000      R     MOV     DPTR,#USBFS_ep0Mode
000F 740F              MOV     A,#0FH
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 484
0012 E4                CLR     A
0013 900000      R     MOV     DPTR,#USBFS_lastPacketSize
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 486
0017 900000      R     MOV     DPTR,#USBFS_ep0Count
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 488
001B 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 489
001D         ?C0055:
001D 22                RET     
             ; FUNCTION USBFS_InitZeroLengthControlTransfer (END)

             ; FUNCTION USBFS_ControlReadDataStage (BEGIN)
                                           ; SOURCE LINE # 503
                                           ; SOURCE LINE # 505
                                           ; SOURCE LINE # 506
0000 120000      R     LCALL   USBFS_LoadEP0
                                           ; SOURCE LINE # 507
0003 22                RET     
             ; FUNCTION USBFS_ControlReadDataStage (END)

             ; FUNCTION USBFS_ControlReadStatusStage (BEGIN)
                                           ; SOURCE LINE # 526
                                           ; SOURCE LINE # 527
                                           ; SOURCE LINE # 529
0000 900000      R     MOV     DPTR,#USBFS_lastPacketSize
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#USBFS_transferByteCount
0008 E4                CLR     A
0009 8FF0              MOV     B,R7
000B 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 532
000E E4                CLR     A
000F 900000      R     MOV     DPTR,#USBFS_transferState
0012 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 24  

                                           ; SOURCE LINE # 535
0013 7F01              MOV     R7,#01H
0015 120000      R     LCALL   _USBFS_UpdateStatusBlock
                                           ; SOURCE LINE # 538
0018 900000      R     MOV     DPTR,#USBFS_ep0Mode
001B 7403              MOV     A,#03H
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 539
001E 22                RET     
             ; FUNCTION USBFS_ControlReadStatusStage (END)

             ; FUNCTION USBFS_InitControlWrite (BEGIN)
                                           ; SOURCE LINE # 560
                                           ; SOURCE LINE # 561
                                           ; SOURCE LINE # 565
0000 900000      R     MOV     DPTR,#USBFS_transferState
0003 7404              MOV     A,#04H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 568
0006 900000      R     MOV     DPTR,#USBFS_ep0Toggle
0009 7480              MOV     A,#080H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 571
000C 120000      R     LCALL   USBFS_InitializeStatusBlock
                                           ; SOURCE LINE # 573
000F 906007            MOV     DPTR,#06007H
0012 E0                MOVX    A,@DPTR
0013 FE                MOV     R6,A
0014 906006            MOV     DPTR,#06006H
0017 E0                MOVX    A,@DPTR
0018 FD                MOV     R5,A
0019 EE                MOV     A,R6
001A ED                MOV     A,R5
001B FF                MOV     R7,A
;---- Variable 'xferCount' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 575
001C D3                SETB    C
001D 900000      R     MOV     DPTR,#USBFS_currentTD+01H
0020 E0                MOVX    A,@DPTR
0021 9F                SUBB    A,R7
0022 900000      R     MOV     DPTR,#USBFS_currentTD
0025 E0                MOVX    A,@DPTR
0026 9E                SUBB    A,R6
0027 4005              JC      ?C0058
                                           ; SOURCE LINE # 576
                                           ; SOURCE LINE # 577
0029 EE                MOV     A,R6
002A F0                MOVX    @DPTR,A
002B A3                INC     DPTR
002C EF                MOV     A,R7
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 578
002E         ?C0058:
                                           ; SOURCE LINE # 581
002E 900000      R     MOV     DPTR,#USBFS_ep0Mode
0031 740B              MOV     A,#0BH
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 583
0034 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 584
0036         ?C0059:
0036 22                RET     
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 25  

             ; FUNCTION USBFS_InitControlWrite (END)

             ; FUNCTION USBFS_ControlWriteDataStage (BEGIN)
                                           ; SOURCE LINE # 611
                                           ; SOURCE LINE # 612
                                           ; SOURCE LINE # 614
;---- Variable 'regIndex' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 616
0002 906029            MOV     DPTR,#06029H
0005 E0                MOVX    A,@DPTR
0006 540F              ANL     A,#0FH
0008 24FE              ADD     A,#0FEH
000A FE                MOV     R6,A
;---- Variable 'ep0Count' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 618
000B FD                MOV     R5,A
000C 900000      R     MOV     DPTR,#USBFS_transferByteCount
000F E4                CLR     A
0010 8DF0              MOV     B,R5
0012 120000      E     LCALL   ?C?IILDX
0015         ?C0060:
                                           ; SOURCE LINE # 620
0015 D3                SETB    C
0016 900000      R     MOV     DPTR,#USBFS_currentTD+01H
0019 E0                MOVX    A,@DPTR
001A 9400              SUBB    A,#00H
001C 900000      R     MOV     DPTR,#USBFS_currentTD
001F E0                MOVX    A,@DPTR
0020 9400              SUBB    A,#00H
0022 403C              JC      ?C0061
0024 EE                MOV     A,R6
0025 D3                SETB    C
0026 9400              SUBB    A,#00H
0028 4036              JC      ?C0061
                                           ; SOURCE LINE # 621
                                           ; SOURCE LINE # 622
002A E4                CLR     A
002B 2F                ADD     A,R7
002C F582              MOV     DPL,A
002E E4                CLR     A
002F 3460              ADDC    A,#060H
0031 F583              MOV     DPH,A
0033 E0                MOVX    A,@DPTR
0034 FD                MOV     R5,A
0035 900000      R     MOV     DPTR,#USBFS_currentTD+02H
0038 120000      E     LCALL   ?C?PLDXDATA
003B ED                MOV     A,R5
003C 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 623
003F 900000      R     MOV     DPTR,#USBFS_currentTD+02H
0042 120000      E     LCALL   ?C?PLDXDATA
0045 E9                MOV     A,R1
0046 2401              ADD     A,#01H
0048 F9                MOV     R1,A
0049 E4                CLR     A
004A 3A                ADDC    A,R2
004B FA                MOV     R2,A
004C 900000      R     MOV     DPTR,#USBFS_currentTD+02H
004F 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 624
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 26  

0052 0F                INC     R7
                                           ; SOURCE LINE # 625
0053 1E                DEC     R6
                                           ; SOURCE LINE # 626
0054 900000      R     MOV     DPTR,#USBFS_currentTD
0057 74FF              MOV     A,#0FFH
0059 F5F0              MOV     B,A
005B 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 627
005E 80B5              SJMP    ?C0060
0060         ?C0061:
                                           ; SOURCE LINE # 629
0060 AF06              MOV     R7,AR6
0062 900000      R     MOV     DPTR,#USBFS_ep0Count
0065 EE                MOV     A,R6
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 632
0067 900000      R     MOV     DPTR,#USBFS_ep0Toggle
006A E0                MOVX    A,@DPTR
006B 6480              XRL     A,#080H
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 635
006E 900000      R     MOV     DPTR,#USBFS_ep0Mode
0071 740B              MOV     A,#0BH
0073 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 636
0074 22                RET     
             ; FUNCTION USBFS_ControlWriteDataStage (END)

             ; FUNCTION USBFS_ControlWriteStatusStage (BEGIN)
                                           ; SOURCE LINE # 653
                                           ; SOURCE LINE # 654
                                           ; SOURCE LINE # 656
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#USBFS_transferState
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 659
0005 7F01              MOV     R7,#01H
0007 120000      R     LCALL   _USBFS_UpdateStatusBlock
                                           ; SOURCE LINE # 662
000A 900000      R     MOV     DPTR,#USBFS_ep0Mode
000D 7403              MOV     A,#03H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 663
0010 22                RET     
             ; FUNCTION USBFS_ControlWriteStatusStage (END)

             ; FUNCTION USBFS_InitNoDataControlTransfer (BEGIN)
                                           ; SOURCE LINE # 685
                                           ; SOURCE LINE # 686
                                           ; SOURCE LINE # 687
0000 900000      R     MOV     DPTR,#USBFS_transferState
0003 7406              MOV     A,#06H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 688
0006 900000      R     MOV     DPTR,#USBFS_ep0Mode
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 689
000A 900000      R     MOV     DPTR,#USBFS_ep0Toggle
000D 7480              MOV     A,#080H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 690
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 27  

0010 E4                CLR     A
0011 900000      R     MOV     DPTR,#USBFS_ep0Count
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 692
0015 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 693
0017         ?C0064:
0017 22                RET     
             ; FUNCTION USBFS_InitNoDataControlTransfer (END)

             ; FUNCTION USBFS_NoDataControlStatusStage (BEGIN)
                                           ; SOURCE LINE # 714
                                           ; SOURCE LINE # 715
                                           ; SOURCE LINE # 716
0000 900000      R     MOV     DPTR,#USBFS_deviceAddress
0003 E0                MOVX    A,@DPTR
0004 600C              JZ      ?C0065
                                           ; SOURCE LINE # 717
                                           ; SOURCE LINE # 719
0006 E0                MOVX    A,@DPTR
0007 4480              ORL     A,#080H
0009 906008            MOV     DPTR,#06008H
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 720
000D E4                CLR     A
000E 900000      R     MOV     DPTR,#USBFS_deviceAddress
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 721
0012         ?C0065:
                                           ; SOURCE LINE # 723
0012 E4                CLR     A
0013 900000      R     MOV     DPTR,#USBFS_transferState
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 726
0017 7F01              MOV     R7,#01H
0019 120000      R     LCALL   _USBFS_UpdateStatusBlock
                                           ; SOURCE LINE # 729
001C 900000      R     MOV     DPTR,#USBFS_ep0Mode
001F 7403              MOV     A,#03H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 730
0022 22                RET     
             ; FUNCTION USBFS_NoDataControlStatusStage (END)

             ; FUNCTION _USBFS_UpdateStatusBlock (BEGIN)
                                           ; SOURCE LINE # 754
;---- Variable 'completionCode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 755
                                           ; SOURCE LINE # 756
0000 900000      R     MOV     DPTR,#USBFS_currentTD+05H
0003 120000      E     LCALL   ?C?PLDXDATA
0006 E9                MOV     A,R1
0007 4A                ORL     A,R2
0008 4B                ORL     A,R3
0009 6031              JZ      ?C0068
                                           ; SOURCE LINE # 757
                                           ; SOURCE LINE # 758
000B 900000      R     MOV     DPTR,#USBFS_currentTD+05H
000E 120000      E     LCALL   ?C?PLDXDATA
0011 EF                MOV     A,R7
0012 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 759
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 28  

0015 900000      R     MOV     DPTR,#USBFS_transferByteCount
0018 E0                MOVX    A,@DPTR
0019 FE                MOV     R6,A
001A A3                INC     DPTR
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 900000      R     MOV     DPTR,#USBFS_currentTD+05H
0020 120000      E     LCALL   ?C?PLDXDATA
0023 E9                MOV     A,R1
0024 2401              ADD     A,#01H
0026 F9                MOV     R1,A
0027 E4                CLR     A
0028 3A                ADDC    A,R2
0029 FA                MOV     R2,A
002A EE                MOV     A,R6
002B 8FF0              MOV     B,R7
002D 120000      E     LCALL   ?C?ISTPTR
                                           ; SOURCE LINE # 760
0030 7B00              MOV     R3,#00H
0032 7A00              MOV     R2,#00H
0034 7900              MOV     R1,#00H
0036 900000      R     MOV     DPTR,#USBFS_currentTD+05H
0039 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 761
                                           ; SOURCE LINE # 762
003C         ?C0068:
003C 22                RET     
             ; FUNCTION _USBFS_UpdateStatusBlock (END)

             ; FUNCTION USBFS_InitializeStatusBlock (BEGIN)
                                           ; SOURCE LINE # 784
                                           ; SOURCE LINE # 785
                                           ; SOURCE LINE # 786
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#USBFS_transferByteCount
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 788
0007 900000      R     MOV     DPTR,#USBFS_currentTD+05H
000A 120000      E     LCALL   ?C?PLDXDATA
000D E9                MOV     A,R1
000E 4A                ORL     A,R2
000F 4B                ORL     A,R3
0010 601D              JZ      ?C0070
                                           ; SOURCE LINE # 789
                                           ; SOURCE LINE # 790
0012 900000      R     MOV     DPTR,#USBFS_currentTD+05H
0015 120000      E     LCALL   ?C?PLDXDATA
0018 E4                CLR     A
0019 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 791
001C 900000      R     MOV     DPTR,#USBFS_currentTD+05H
001F 120000      E     LCALL   ?C?PLDXDATA
0022 E9                MOV     A,R1
0023 2401              ADD     A,#01H
0025 F9                MOV     R1,A
0026 E4                CLR     A
0027 3A                ADDC    A,R2
0028 FA                MOV     R2,A
0029 E4                CLR     A
002A F5F0              MOV     B,A
C51 COMPILER V9.51   USBFS_DRV                                                             07/29/2016 09:50:44 PAGE 29  

002C 120000      E     LCALL   ?C?ISTPTR
                                           ; SOURCE LINE # 792
                                           ; SOURCE LINE # 793
002F         ?C0070:
002F 22                RET     
             ; FUNCTION USBFS_InitializeStatusBlock (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1058    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    125       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
