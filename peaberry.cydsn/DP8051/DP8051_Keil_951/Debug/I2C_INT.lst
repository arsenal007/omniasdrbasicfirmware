C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE I2C_INT
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\I2C_INT.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\I2C_INT.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) PR(
                    -.\DP8051\DP8051_Keil_951\Debug/I2C_INT.lst) CD OT(5,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\I2C_INT.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: I2C_INT.c
   3          * Version 3.50
   4          *
   5          * Description:
   6          *  This file provides the source code of Interrupt Service Routine (ISR)
   7          *  for the I2C component.
   8          *
   9          ********************************************************************************
  10          * Copyright 2008-2015, Cypress Semiconductor Corporation. All rights reserved.
  11          * You may use this file only in accordance with the license, terms, conditions,
  12          * disclaimers, and limitations in the end user license agreement accompanying
  13          * the software package with which this file was provided.
  14          *******************************************************************************/
  15          
  16          #include "I2C_PVT.h"
  17          
  18          
  19          
  20          /*******************************************************************************
  21          *  Place your includes, defines and code here.
  22          ********************************************************************************/
  23          /* `#START I2C_ISR_intc` */
  24          
  25          /* `#END` */
  26          
  27          
  28          /*******************************************************************************
  29          * Function Name: I2C_ISR
  30          ********************************************************************************
  31          *
  32          * Summary:
  33          *  The handler for the I2C interrupt. The slave and master operations are
  34          *  handled here.
  35          *
  36          * Parameters:
  37          *  None.
  38          *
  39          * Return:
  40          *  None.
  41          *
  42          * Reentrant:
  43          *  No.
  44          *
  45          *******************************************************************************/
  46          CY_ISR(I2C_ISR)
  47          {
  48   1      #if (I2C_MODE_SLAVE_ENABLED)
                 uint8  tmp8;
              #endif  /* (I2C_MODE_SLAVE_ENABLED) */
  51   1      
  52   1          uint8  tmpCsr;
  53   1          
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 2   

  54   1      #ifdef I2C_ISR_ENTRY_CALLBACK
                  I2C_ISR_EntryCallback();
              #endif /* I2C_ISR_ENTRY_CALLBACK */
  57   1          
  58   1      
  59   1      #if(I2C_TIMEOUT_FF_ENABLED)
                  if(0u != I2C_TimeoutGetStatus())
                  {
                      I2C_TimeoutReset();
                      I2C_state = I2C_SM_EXIT_IDLE;
                      /* I2C_CSR_REG should be cleared after reset */
                  }
              #endif /* (I2C_TIMEOUT_FF_ENABLED) */
  67   1      
  68   1      
  69   1          tmpCsr = I2C_CSR_REG;      /* Make copy as interrupts clear */
  70   1      
  71   1      #if(I2C_MODE_MULTI_MASTER_SLAVE_ENABLED)
                  if(I2C_CHECK_START_GEN(I2C_MCSR_REG))
                  {
                      I2C_CLEAR_START_GEN;
              
                      /* Set transfer complete and error flags */
                      I2C_mstrStatus |= (I2C_MSTAT_ERR_XFER |
                                                      I2C_GET_MSTAT_CMPLT);
              
                      /* Slave was addressed */
                      I2C_state = I2C_SM_SLAVE;
                  }
              #endif /* (I2C_MODE_MULTI_MASTER_SLAVE_ENABLED) */
  84   1      
  85   1      
  86   1      #if(I2C_MODE_MULTI_MASTER_ENABLED)
                  if(I2C_CHECK_LOST_ARB(tmpCsr))
                  {
                      /* Set errors */
                      I2C_mstrStatus |= (I2C_MSTAT_ERR_XFER     |
                                                      I2C_MSTAT_ERR_ARB_LOST |
                                                      I2C_GET_MSTAT_CMPLT);
              
                      I2C_DISABLE_INT_ON_STOP; /* Interrupt on Stop is enabled by write */
              
                      #if(I2C_MODE_MULTI_MASTER_SLAVE_ENABLED)
                          if(I2C_CHECK_ADDRESS_STS(tmpCsr))
                          {
                              /* Slave was addressed */
                              I2C_state = I2C_SM_SLAVE;
                          }
                          else
                          {
                              I2C_BUS_RELEASE;
              
                              I2C_state = I2C_SM_EXIT_IDLE;
                          }
                      #else
                          I2C_BUS_RELEASE;
              
                          I2C_state = I2C_SM_EXIT_IDLE;
              
                      #endif /* (I2C_MODE_MULTI_MASTER_SLAVE_ENABLED) */
                  }
              #endif /* (I2C_MODE_MULTI_MASTER_ENABLED) */
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 3   

 116   1      
 117   1          /* Check for master operation mode */
 118   1          if(I2C_CHECK_SM_MASTER)
 119   1          {
 120   2          #if(I2C_MODE_MASTER_ENABLED)
 121   2              if(I2C_CHECK_BYTE_COMPLETE(tmpCsr))
 122   2              {
 123   3                  switch (I2C_state)
 124   3                  {
 125   4                  case I2C_SM_MSTR_WR_ADDR:  /* After address is sent, write data */
 126   4                  case I2C_SM_MSTR_RD_ADDR:  /* After address is sent, read data */
 127   4      
 128   4                      tmpCsr &= ((uint8) ~I2C_CSR_STOP_STATUS); /* Clear Stop bit history on address phase */
 129   4      
 130   4                      if(I2C_CHECK_ADDR_ACK(tmpCsr))
 131   4                      {
 132   5                          /* Setup for transmit or receive of data */
 133   5                          if(I2C_state == I2C_SM_MSTR_WR_ADDR)   /* TRANSMIT data */
 134   5                          {
 135   6                              /* Check if at least one byte to transfer */
 136   6                              if(I2C_mstrWrBufSize > 0u)
 137   6                              {
 138   7                                  /* Load the 1st data byte */
 139   7                                  I2C_DATA_REG = I2C_mstrWrBufPtr[0u];
 140   7                                  I2C_TRANSMIT_DATA;
 141   7                                  I2C_mstrWrBufIndex = 1u;   /* Set index to 2nd element */
 142   7      
 143   7                                  /* Set transmit state until done */
 144   7                                  I2C_state = I2C_SM_MSTR_WR_DATA;
 145   7                              }
 146   6                              /* End of buffer: complete writing */
 147   6                              else if(I2C_CHECK_NO_STOP(I2C_mstrControl))
 148   6                              {
 149   7                                  /* Set write complete and master halted */
 150   7                                  I2C_mstrStatus |= (I2C_MSTAT_XFER_HALT |
 151   7                                                                  I2C_MSTAT_WR_CMPLT);
 152   7      
 153   7                                  I2C_state = I2C_SM_MSTR_HALT; /* Expect ReStart */
 154   7                                  I2C_DisableInt();
 155   7                              }
 156   6                              else
 157   6                              {
 158   7                                  I2C_ENABLE_INT_ON_STOP; /* Enable interrupt on Stop, to catch it */
 159   7                                  I2C_GENERATE_STOP;
 160   7                              }
 161   6                          }
 162   5                          else  /* Master receive data */
 163   5                          {
 164   6                              I2C_READY_TO_READ; /* Release bus to read data */
 165   6      
 166   6                              I2C_state  = I2C_SM_MSTR_RD_DATA;
 167   6                          }
 168   5                      }
 169   4                      /* Address is NACKed */
 170   4                      else if(I2C_CHECK_ADDR_NAK(tmpCsr))
 171   4                      {
 172   5                          /* Set Address NAK error */
 173   5                          I2C_mstrStatus |= (I2C_MSTAT_ERR_XFER |
 174   5                                                          I2C_MSTAT_ERR_ADDR_NAK);
 175   5      
 176   5                          if(I2C_CHECK_NO_STOP(I2C_mstrControl))
 177   5                          {
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 4   

 178   6                              I2C_mstrStatus |= (I2C_MSTAT_XFER_HALT |
 179   6                                                              I2C_GET_MSTAT_CMPLT);
 180   6      
 181   6                              I2C_state = I2C_SM_MSTR_HALT; /* Expect RESTART */
 182   6                              I2C_DisableInt();
 183   6                          }
 184   5                          else  /* Do normal Stop */
 185   5                          {
 186   6                              I2C_ENABLE_INT_ON_STOP; /* Enable interrupt on Stop, to catch it */
 187   6                              I2C_GENERATE_STOP;
 188   6                          }
 189   5                      }
 190   4                      else
 191   4                      {
 192   5                          /* Address phase is not set for some reason: error */
 193   5                          #if(I2C_TIMEOUT_ENABLED)
                                      /* Exit interrupt to take chance for timeout timer to handle this case */
                                      I2C_DisableInt();
                                      I2C_ClearPendingInt();
                                  #else
 198   5                              /* Block execution flow: unexpected condition */
 199   5                              CYASSERT(0u != 0u);
 200   5                          #endif /* (I2C_TIMEOUT_ENABLED) */
 201   5                      }
 202   4                      break;
 203   4      
 204   4                  case I2C_SM_MSTR_WR_DATA:
 205   4      
 206   4                      if(I2C_CHECK_DATA_ACK(tmpCsr))
 207   4                      {
 208   5                          /* Check if end of buffer */
 209   5                          if(I2C_mstrWrBufIndex  < I2C_mstrWrBufSize)
 210   5                          {
 211   6                              I2C_DATA_REG =
 212   6                                                       I2C_mstrWrBufPtr[I2C_mstrWrBufIndex];
 213   6                              I2C_TRANSMIT_DATA;
 214   6                              I2C_mstrWrBufIndex++;
 215   6                          }
 216   5                          /* End of buffer: complete writing */
 217   5                          else if(I2C_CHECK_NO_STOP(I2C_mstrControl))
 218   5                          {
 219   6                              /* Set write complete and master halted */
 220   6                              I2C_mstrStatus |= (I2C_MSTAT_XFER_HALT |
 221   6                                                              I2C_MSTAT_WR_CMPLT);
 222   6      
 223   6                              I2C_state = I2C_SM_MSTR_HALT;    /* Expect restart */
 224   6                              I2C_DisableInt();
 225   6                          }
 226   5                          else  /* Do normal Stop */
 227   5                          {
 228   6                              I2C_ENABLE_INT_ON_STOP;    /* Enable interrupt on Stop, to catch it */
 229   6                              I2C_GENERATE_STOP;
 230   6                          }
 231   5                      }
 232   4                      /* Last byte NAKed: end writing */
 233   4                      else if(I2C_CHECK_NO_STOP(I2C_mstrControl))
 234   4                      {
 235   5                          /* Set write complete, short transfer and master halted */
 236   5                          I2C_mstrStatus |= (I2C_MSTAT_ERR_XFER       |
 237   5                                                          I2C_MSTAT_ERR_SHORT_XFER |
 238   5                                                          I2C_MSTAT_XFER_HALT      |
 239   5                                                          I2C_MSTAT_WR_CMPLT);
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 5   

 240   5      
 241   5                          I2C_state = I2C_SM_MSTR_HALT;    /* Expect ReStart */
 242   5                          I2C_DisableInt();
 243   5                      }
 244   4                      else  /* Do normal Stop */
 245   4                      {
 246   5                          I2C_ENABLE_INT_ON_STOP;    /* Enable interrupt on Stop, to catch it */
 247   5                          I2C_GENERATE_STOP;
 248   5      
 249   5                          /* Set short transfer and error flag */
 250   5                          I2C_mstrStatus |= (I2C_MSTAT_ERR_SHORT_XFER |
 251   5                                                          I2C_MSTAT_ERR_XFER);
 252   5                      }
 253   4      
 254   4                      break;
 255   4      
 256   4                  case I2C_SM_MSTR_RD_DATA:
 257   4      
 258   4                      I2C_mstrRdBufPtr[I2C_mstrRdBufIndex] = I2C_DATA_REG;
 259   4                      I2C_mstrRdBufIndex++;
 260   4      
 261   4                      /* Check if end of buffer */
 262   4                      if(I2C_mstrRdBufIndex < I2C_mstrRdBufSize)
 263   4                      {
 264   5                          I2C_ACK_AND_RECEIVE;       /* ACK and receive byte */
 265   5                      }
 266   4                      /* End of buffer: complete reading */
 267   4                      else if(I2C_CHECK_NO_STOP(I2C_mstrControl))
 268   4                      {
 269   5                          /* Set read complete and master halted */
 270   5                          I2C_mstrStatus |= (I2C_MSTAT_XFER_HALT |
 271   5                                                          I2C_MSTAT_RD_CMPLT);
 272   5      
 273   5                          I2C_state = I2C_SM_MSTR_HALT;    /* Expect ReStart */
 274   5                          I2C_DisableInt();
 275   5                      }
 276   4                      else
 277   4                      {
 278   5                          I2C_ENABLE_INT_ON_STOP;
 279   5                          I2C_NAK_AND_RECEIVE;       /* NACK and TRY to generate Stop */
 280   5                      }
 281   4                      break;
 282   4      
 283   4                  default: /* This is an invalid state and should not occur */
 284   4      
 285   4                  #if(I2C_TIMEOUT_ENABLED)
                              /* Exit interrupt to take chance for timeout timer to handles this case */
                              I2C_DisableInt();
                              I2C_ClearPendingInt();
                          #else
 290   4                      /* Block execution flow: unexpected condition */
 291   4                      CYASSERT(0u != 0u);
 292   4                  #endif /* (I2C_TIMEOUT_ENABLED) */
 293   4      
 294   4                      break;
 295   4                  }
 296   3              }
 297   2      
 298   2              /* Catches Stop: end of transaction */
 299   2              if(I2C_CHECK_STOP_STS(tmpCsr))
 300   2              {
 301   3                  I2C_mstrStatus |= I2C_GET_MSTAT_CMPLT;
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 6   

 302   3      
 303   3                  I2C_DISABLE_INT_ON_STOP;
 304   3                  I2C_state = I2C_SM_IDLE;
 305   3              }
 306   2          #endif /* (I2C_MODE_MASTER_ENABLED) */
 307   2          }
 308   1          else if(I2C_CHECK_SM_SLAVE)
 309   1          {
 310   2          #if(I2C_MODE_SLAVE_ENABLED)
              
                      if((I2C_CHECK_STOP_STS(tmpCsr)) || /* Stop || Restart */
                         (I2C_CHECK_BYTE_COMPLETE(tmpCsr) && I2C_CHECK_ADDRESS_STS(tmpCsr)))
                      {
                          /* Catch end of master write transaction: use interrupt on Stop */
                          /* The Stop bit history on address phase does not have correct state */
                          if(I2C_SM_SL_WR_DATA == I2C_state)
                          {
                              I2C_DISABLE_INT_ON_STOP;
              
                              I2C_slStatus &= ((uint8) ~I2C_SSTAT_WR_BUSY);
                              I2C_slStatus |= ((uint8)  I2C_SSTAT_WR_CMPLT);
              
                              I2C_state = I2C_SM_IDLE;
                          }
                      }
              
                      if(I2C_CHECK_BYTE_COMPLETE(tmpCsr))
                      {
                          /* The address only issued after Start or ReStart: so check the address
                             to catch these events:
                              FF : sets an address phase with a byte_complete interrupt trigger.
                              UDB: sets an address phase immediately after Start or ReStart. */
                          if(I2C_CHECK_ADDRESS_STS(tmpCsr))
                          {
                          /* Check for software address detection */
                          #if(I2C_SW_ADRR_DECODE)
                              tmp8 = I2C_GET_SLAVE_ADDR(I2C_DATA_REG);
              
                              if(tmp8 == I2C_slAddress)   /* Check for address match */
                              {
                                  if(0u != (I2C_DATA_REG & I2C_READ_FLAG))
                                  {
                                      /* Place code to prepare read buffer here                  */
                                      /* `#START I2C_SW_PREPARE_READ_BUF_interrupt` */
              
                                      /* `#END` */
              
                                  #ifdef I2C_SW_PREPARE_READ_BUF_CALLBACK
                                      I2C_SwPrepareReadBuf_Callback();
                                  #endif /* I2C_SW_PREPARE_READ_BUF_CALLBACK */
                                      
                                      /* Prepare next operation to read, get data and place in data register */
                                      if(I2C_slRdBufIndex < I2C_slRdBufSize)
                                      {
                                          /* Load first data byte from array */
                                          I2C_DATA_REG = I2C_slRdBufPtr[I2C_slRdBufIndex];
                                          I2C_ACK_AND_TRANSMIT;
                                          I2C_slRdBufIndex++;
              
                                          I2C_slStatus |= I2C_SSTAT_RD_BUSY;
                                      }
                                      else    /* Overflow: provide 0xFF on bus */
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 7   

                                      {
                                          I2C_DATA_REG = I2C_OVERFLOW_RETURN;
                                          I2C_ACK_AND_TRANSMIT;
              
                                          I2C_slStatus  |= (I2C_SSTAT_RD_BUSY |
                                                                         I2C_SSTAT_RD_ERR_OVFL);
                                      }
              
                                      I2C_state = I2C_SM_SL_RD_DATA;
                                  }
                                  else  /* Write transaction: receive 1st byte */
                                  {
                                      I2C_ACK_AND_RECEIVE;
                                      I2C_state = I2C_SM_SL_WR_DATA;
              
                                      I2C_slStatus |= I2C_SSTAT_WR_BUSY;
                                      I2C_ENABLE_INT_ON_STOP;
                                  }
                              }
                              else
                              {
                                  /*     Place code to compare for additional address here    */
                                  /* `#START I2C_SW_ADDR_COMPARE_interruptStart` */
              
                                  /* `#END` */
              
                              #ifdef I2C_SW_ADDR_COMPARE_ENTRY_CALLBACK
                                  I2C_SwAddrCompare_EntryCallback();
                              #endif /* I2C_SW_ADDR_COMPARE_ENTRY_CALLBACK */
                                  
                                  I2C_NAK_AND_RECEIVE;   /* NACK address */
              
                                  /* Place code to end of condition for NACK generation here */
                                  /* `#START I2C_SW_ADDR_COMPARE_interruptEnd`  */
              
                                  /* `#END` */
              
                              #ifdef I2C_SW_ADDR_COMPARE_EXIT_CALLBACK
                                  I2C_SwAddrCompare_ExitCallback();
                              #endif /* I2C_SW_ADDR_COMPARE_EXIT_CALLBACK */
                              }
              
                          #else /* (I2C_HW_ADRR_DECODE) */
              
                              if(0u != (I2C_DATA_REG & I2C_READ_FLAG))
                              {
                                  /* Place code to prepare read buffer here                  */
                                  /* `#START I2C_HW_PREPARE_READ_BUF_interrupt` */
              
                                  /* `#END` */
                                  
                              #ifdef I2C_HW_PREPARE_READ_BUF_CALLBACK
                                  I2C_HwPrepareReadBuf_Callback();
                              #endif /* I2C_HW_PREPARE_READ_BUF_CALLBACK */
              
                                  /* Prepare next operation to read, get data and place in data register */
                                  if(I2C_slRdBufIndex < I2C_slRdBufSize)
                                  {
                                      /* Load first data byte from array */
                                      I2C_DATA_REG = I2C_slRdBufPtr[I2C_slRdBufIndex];
                                      I2C_ACK_AND_TRANSMIT;
                                      I2C_slRdBufIndex++;
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 8   

              
                                      I2C_slStatus |= I2C_SSTAT_RD_BUSY;
                                  }
                                  else    /* Overflow: provide 0xFF on bus */
                                  {
                                      I2C_DATA_REG = I2C_OVERFLOW_RETURN;
                                      I2C_ACK_AND_TRANSMIT;
              
                                      I2C_slStatus  |= (I2C_SSTAT_RD_BUSY |
                                                                     I2C_SSTAT_RD_ERR_OVFL);
                                  }
              
                                  I2C_state = I2C_SM_SL_RD_DATA;
                              }
                              else  /* Write transaction: receive 1st byte */
                              {
                                  I2C_ACK_AND_RECEIVE;
                                  I2C_state = I2C_SM_SL_WR_DATA;
              
                                  I2C_slStatus |= I2C_SSTAT_WR_BUSY;
                                  I2C_ENABLE_INT_ON_STOP;
                              }
              
                          #endif /* (I2C_SW_ADRR_DECODE) */
                          }
                          /* Data states */
                          /* Data master writes into slave */
                          else if(I2C_state == I2C_SM_SL_WR_DATA)
                          {
                              if(I2C_slWrBufIndex < I2C_slWrBufSize)
                              {
                                  tmp8 = I2C_DATA_REG;
                                  I2C_ACK_AND_RECEIVE;
                                  I2C_slWrBufPtr[I2C_slWrBufIndex] = tmp8;
                                  I2C_slWrBufIndex++;
                              }
                              else  /* of array: complete write, send NACK */
                              {
                                  I2C_NAK_AND_RECEIVE;
              
                                  I2C_slStatus |= I2C_SSTAT_WR_ERR_OVFL;
                              }
                          }
                          /* Data master reads from slave */
                          else if(I2C_state == I2C_SM_SL_RD_DATA)
                          {
                              if(I2C_CHECK_DATA_ACK(tmpCsr))
                              {
                                  if(I2C_slRdBufIndex < I2C_slRdBufSize)
                                  {
                                       /* Get data from array */
                                      I2C_DATA_REG = I2C_slRdBufPtr[I2C_slRdBufIndex];
                                      I2C_TRANSMIT_DATA;
                                      I2C_slRdBufIndex++;
                                  }
                                  else   /* Overflow: provide 0xFF on bus */
                                  {
                                      I2C_DATA_REG = I2C_OVERFLOW_RETURN;
                                      I2C_TRANSMIT_DATA;
              
                                      I2C_slStatus |= I2C_SSTAT_RD_ERR_OVFL;
                                  }
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 9   

                              }
                              else  /* Last byte was NACKed: read complete */
                              {
                                  /* Only NACK appears on bus */
                                  I2C_DATA_REG = I2C_OVERFLOW_RETURN;
                                  I2C_NAK_AND_TRANSMIT;
              
                                  I2C_slStatus &= ((uint8) ~I2C_SSTAT_RD_BUSY);
                                  I2C_slStatus |= ((uint8)  I2C_SSTAT_RD_CMPLT);
              
                                  I2C_state = I2C_SM_IDLE;
                              }
                          }
                          else
                          {
                          #if(I2C_TIMEOUT_ENABLED)
                              /* Exit interrupt to take chance for timeout timer to handle this case */
                              I2C_DisableInt();
                              I2C_ClearPendingInt();
                          #else
                              /* Block execution flow: unexpected condition */
                              CYASSERT(0u != 0u);
                          #endif /* (I2C_TIMEOUT_ENABLED) */
                          }
                      }
                  #endif /* (I2C_MODE_SLAVE_ENABLED) */
 514   2          }
 515   1          else
 516   1          {
 517   2              /* The FSM skips master and slave processing: return to IDLE */
 518   2              I2C_state = I2C_SM_IDLE;
 519   2          }
 520   1      
 521   1      #ifdef I2C_ISR_EXIT_CALLBACK
                  I2C_ISR_ExitCallback();
              #endif /* I2C_ISR_EXIT_CALLBACK */    
 524   1      }
 525          
 526          
 527          #if ((I2C_FF_IMPLEMENTED) && (I2C_WAKEUP_ENABLED))
                  /*******************************************************************************
                  * Function Name: I2C_WAKEUP_ISR
                  ********************************************************************************
                  *
                  * Summary:
                  *  The interrupt handler to trigger after a wakeup.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  CY_ISR(I2C_WAKEUP_ISR)
                  {
                  #ifdef I2C_WAKEUP_ISR_ENTRY_CALLBACK
                      I2C_WAKEUP_ISR_EntryCallback();
                  #endif /* I2C_WAKEUP_ISR_ENTRY_CALLBACK */
                       
                      /* Set flag to notify that matched address is received */
                      I2C_wakeupSource = 1u;
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 10  

              
                      /* SCL is stretched until the I2C_Wake() is called */
              
                  #ifdef I2C_WAKEUP_ISR_EXIT_CALLBACK
                      I2C_WAKEUP_ISR_ExitCallback();
                  #endif /* I2C_WAKEUP_ISR_EXIT_CALLBACK */
                  }
              #endif /* ((I2C_FF_IMPLEMENTED) && (I2C_WAKEUP_ENABLED)) */
 558          
 559          
 560          /* [] END OF FILE */
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 11  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION I2C_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C085              PUSH    DPH1
000A C084              PUSH    DPL1
000C C086              PUSH    DPS
000E 758600            MOV     DPS,#00H
0011 C000        E     PUSH    ?C?XPAGE1SFR
0013 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0016 C0D0              PUSH    PSW
0018 75D000            MOV     PSW,#00H
001B C000              PUSH    AR0
001D C001              PUSH    AR1
001F C002              PUSH    AR2
0021 C003              PUSH    AR3
0023 C004              PUSH    AR4
0025 C005              PUSH    AR5
0027 C006              PUSH    AR6
0029 C007              PUSH    AR7
                                           ; SOURCE LINE # 46
                                           ; SOURCE LINE # 69
002B 9049D7            MOV     DPTR,#049D7H
002E E0                MOVX    A,@DPTR
002F 900000      R     MOV     DPTR,#tmpCsr
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 118
0033 900000      E     MOV     DPTR,#I2C_state
0036 E0                MOVX    A,@DPTR
0037 5440              ANL     A,#040H
0039 7003              JNZ     $ + 5H
003B 020000      R     LJMP    ?C0001
                                           ; SOURCE LINE # 119
                                           ; SOURCE LINE # 121
003E 900000      R     MOV     DPTR,#tmpCsr
0041 E0                MOVX    A,@DPTR
0042 FF                MOV     R7,A
0043 5401              ANL     A,#01H
0045 7003              JNZ     $ + 5H
0047 020000      R     LJMP    ?C0002
                                           ; SOURCE LINE # 122
                                           ; SOURCE LINE # 123
004A 900000      E     MOV     DPTR,#I2C_state
004D E0                MOVX    A,@DPTR
004E 24BA              ADD     A,#0BAH
0050 7003              JNZ     $ + 5H
0052 020000      R     LJMP    ?C0039
0055 24FD              ADD     A,#0FDH
0057 600D              JZ      ?C0005
0059 14                DEC     A
005A 7003              JNZ     $ + 5H
005C 020000      R     LJMP    ?C0063
005F 2405              ADD     A,#05H
0061 6003              JZ      $ + 5H
0063 020000      R     LJMP    ?C0077
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 125
                                           ; SOURCE LINE # 126
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 12  

0066         ?C0005:
                                           ; SOURCE LINE # 128
0066 EF                MOV     A,R7
0067 54DF              ANL     A,#0DFH
0069 900000      R     MOV     DPTR,#tmpCsr
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 130
006D 540A              ANL     A,#0AH
006F FD                MOV     R5,A
0070 7C00              MOV     R4,#00H
0072 6408              XRL     A,#08H
0074 7075              JNZ     ?C0006
                                           ; SOURCE LINE # 131
                                           ; SOURCE LINE # 133
0076 900000      E     MOV     DPTR,#I2C_state
0079 E0                MOVX    A,@DPTR
007A 6445              XRL     A,#045H
007C 705F              JNZ     ?C0024
                                           ; SOURCE LINE # 134
                                           ; SOURCE LINE # 136
007E 900000      E     MOV     DPTR,#I2C_mstrWrBufSize
0081 E0                MOVX    A,@DPTR
0082 D3                SETB    C
0083 9400              SUBB    A,#00H
0085 4022              JC      ?C0008
                                           ; SOURCE LINE # 137
                                           ; SOURCE LINE # 139
0087 900000      E     MOV     DPTR,#I2C_mstrWrBufPtr
008A 120000      E     LCALL   ?C?PLDXDATA
008D 120000      E     LCALL   ?C?CLDPTR
0090 9049D8            MOV     DPTR,#049D8H
0093 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 140
0094 9049D7            MOV     DPTR,#049D7H
0097 7404              MOV     A,#04H
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 141
009A 900000      E     MOV     DPTR,#I2C_mstrWrBufIndex
009D 7401              MOV     A,#01H
009F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 144
00A0 900000      E     MOV     DPTR,#I2C_state
00A3 7446              MOV     A,#046H
00A5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 145
00A6 020000      R     LJMP    ?C0002
00A9         ?C0008:
                                           ; SOURCE LINE # 147
00A9 900000      E     MOV     DPTR,#I2C_mstrControl
00AC E0                MOVX    A,@DPTR
00AD 5402              ANL     A,#02H
00AF 6016              JZ      ?C0017
                                           ; SOURCE LINE # 148
                                           ; SOURCE LINE # 150
00B1 900000      E     MOV     DPTR,#I2C_mstrStatus
00B4 E0                MOVX    A,@DPTR
00B5 440A              ORL     A,#0AH
00B7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 153
00B8 900000      E     MOV     DPTR,#I2C_state
00BB 7460              MOV     A,#060H
00BD F0                MOVX    @DPTR,A
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 13  

                                           ; SOURCE LINE # 154
00BE 9044C9            MOV     DPTR,#044C9H
00C1 7480              MOV     A,#080H
00C3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 155
00C4 020000      R     LJMP    ?C0002
                                           ; SOURCE LINE # 157
00C7         ?C0017:
                                           ; SOURCE LINE # 158
00C7 9049D6            MOV     DPTR,#049D6H
00CA E0                MOVX    A,@DPTR
00CB 4410              ORL     A,#010H
00CD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 159
00CE 9049D9            MOV     DPTR,#049D9H
00D1 7410              MOV     A,#010H
00D3 F0                MOVX    @DPTR,A
00D4 9049D7            MOV     DPTR,#049D7H
00D7 7404              MOV     A,#04H
00D9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 160
                                           ; SOURCE LINE # 161
00DA 020000      R     LJMP    ?C0002
                                           ; SOURCE LINE # 163
00DD         ?C0024:
                                           ; SOURCE LINE # 164
00DD 9049D7            MOV     DPTR,#049D7H
00E0 E4                CLR     A
00E1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 166
00E2 900000      E     MOV     DPTR,#I2C_state
00E5 744A              MOV     A,#04AH
00E7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 167
                                           ; SOURCE LINE # 168
00E8 020000      R     LJMP    ?C0002
00EB         ?C0006:
                                           ; SOURCE LINE # 170
00EB ED                MOV     A,R5
00EC 640A              XRL     A,#0AH
00EE 4C                ORL     A,R4
00EF 704F              JNZ     ?C0026
                                           ; SOURCE LINE # 171
                                           ; SOURCE LINE # 173
00F1 900000      E     MOV     DPTR,#I2C_mstrStatus
00F4 E0                MOVX    A,@DPTR
00F5 44A0              ORL     A,#0A0H
00F7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 176
00F8 900000      E     MOV     DPTR,#I2C_mstrControl
00FB E0                MOVX    A,@DPTR
00FC 5402              ANL     A,#02H
00FE 602A              JZ      ?C0033
                                           ; SOURCE LINE # 177
                                           ; SOURCE LINE # 178
0100 900000      E     MOV     DPTR,#I2C_mstrStatus
0103 E0                MOVX    A,@DPTR
0104 FF                MOV     R7,A
0105 900000      E     MOV     DPTR,#I2C_state
0108 E0                MOVX    A,@DPTR
0109 5408              ANL     A,#08H
010B 6004              JZ      ?C0028
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 14  

010D 7E01              MOV     R6,#01H
010F 8002              SJMP    ?C0029
0111         ?C0028:
0111 7E02              MOV     R6,#02H
0113         ?C0029:
0113 EE                MOV     A,R6
0114 4408              ORL     A,#08H
0116 4F                ORL     A,R7
0117 900000      E     MOV     DPTR,#I2C_mstrStatus
011A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 181
011B 900000      E     MOV     DPTR,#I2C_state
011E 7460              MOV     A,#060H
0120 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 182
0121 9044C9            MOV     DPTR,#044C9H
0124 7480              MOV     A,#080H
0126 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 183
0127 020000      R     LJMP    ?C0002
                                           ; SOURCE LINE # 185
012A         ?C0033:
                                           ; SOURCE LINE # 186
012A 9049D6            MOV     DPTR,#049D6H
012D E0                MOVX    A,@DPTR
012E 4410              ORL     A,#010H
0130 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 187
0131 9049D9            MOV     DPTR,#049D9H
0134 7410              MOV     A,#010H
0136 F0                MOVX    @DPTR,A
0137 9049D7            MOV     DPTR,#049D7H
013A 7404              MOV     A,#04H
013C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 189
013D 020000      R     LJMP    ?C0002
0140         ?C0026:
                                           ; SOURCE LINE # 191
                                           ; SOURCE LINE # 199
0140 7F00              MOV     R7,#00H
0142 120000      E     LCALL   _?CyHalt
                                           ; SOURCE LINE # 201
                                           ; SOURCE LINE # 202
0145 020000      R     LJMP    ?C0002
                                           ; SOURCE LINE # 204
0148         ?C0039:
                                           ; SOURCE LINE # 206
0148 900000      R     MOV     DPTR,#tmpCsr
014B E0                MOVX    A,@DPTR
014C 5402              ANL     A,#02H
014E 7066              JNZ     ?C0040
                                           ; SOURCE LINE # 207
                                           ; SOURCE LINE # 209
0150 900000      E     MOV     DPTR,#I2C_mstrWrBufSize
0153 E0                MOVX    A,@DPTR
0154 FF                MOV     R7,A
0155 900000      E     MOV     DPTR,#I2C_mstrWrBufIndex
0158 E0                MOVX    A,@DPTR
0159 C3                CLR     C
015A 9F                SUBB    A,R7
015B 5025              JNC     ?C0041
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 15  

                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 211
015D 900000      E     MOV     DPTR,#I2C_mstrWrBufPtr
0160 120000      E     LCALL   ?C?PLDXDATA
0163 900000      E     MOV     DPTR,#I2C_mstrWrBufIndex
0166 E0                MOVX    A,@DPTR
0167 29                ADD     A,R1
0168 F9                MOV     R1,A
0169 E4                CLR     A
016A 3A                ADDC    A,R2
016B FA                MOV     R2,A
016C 120000      E     LCALL   ?C?CLDPTR
016F 9049D8            MOV     DPTR,#049D8H
0172 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 213
0173 9049D7            MOV     DPTR,#049D7H
0176 7404              MOV     A,#04H
0178 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 214
0179 900000      E     MOV     DPTR,#I2C_mstrWrBufIndex
017C E0                MOVX    A,@DPTR
017D 04                INC     A
017E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 215
017F 020000      R     LJMP    ?C0002
0182         ?C0041:
                                           ; SOURCE LINE # 217
0182 900000      E     MOV     DPTR,#I2C_mstrControl
0185 E0                MOVX    A,@DPTR
0186 5402              ANL     A,#02H
0188 6016              JZ      ?C0050
                                           ; SOURCE LINE # 218
                                           ; SOURCE LINE # 220
018A 900000      E     MOV     DPTR,#I2C_mstrStatus
018D E0                MOVX    A,@DPTR
018E 440A              ORL     A,#0AH
0190 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 223
0191 900000      E     MOV     DPTR,#I2C_state
0194 7460              MOV     A,#060H
0196 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 224
0197 9044C9            MOV     DPTR,#044C9H
019A 7480              MOV     A,#080H
019C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 225
019D 020000      R     LJMP    ?C0002
                                           ; SOURCE LINE # 227
01A0         ?C0050:
                                           ; SOURCE LINE # 228
01A0 9049D6            MOV     DPTR,#049D6H
01A3 E0                MOVX    A,@DPTR
01A4 4410              ORL     A,#010H
01A6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 229
01A7 9049D9            MOV     DPTR,#049D9H
01AA 7410              MOV     A,#010H
01AC F0                MOVX    @DPTR,A
01AD 9049D7            MOV     DPTR,#049D7H
01B0 7404              MOV     A,#04H
01B2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 230
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 16  

                                           ; SOURCE LINE # 231
01B3 020000      R     LJMP    ?C0002
01B6         ?C0040:
                                           ; SOURCE LINE # 233
01B6 900000      E     MOV     DPTR,#I2C_mstrControl
01B9 E0                MOVX    A,@DPTR
01BA 5402              ANL     A,#02H
01BC 6015              JZ      ?C0059
                                           ; SOURCE LINE # 234
                                           ; SOURCE LINE # 236
01BE 900000      E     MOV     DPTR,#I2C_mstrStatus
01C1 E0                MOVX    A,@DPTR
01C2 449A              ORL     A,#09AH
01C4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 241
01C5 900000      E     MOV     DPTR,#I2C_state
01C8 7460              MOV     A,#060H
01CA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 242
01CB 9044C9            MOV     DPTR,#044C9H
01CE 7480              MOV     A,#080H
01D0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 243
01D1 807D              SJMP    ?C0002
                                           ; SOURCE LINE # 245
01D3         ?C0059:
                                           ; SOURCE LINE # 246
01D3 9049D6            MOV     DPTR,#049D6H
01D6 E0                MOVX    A,@DPTR
01D7 4410              ORL     A,#010H
01D9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 247
01DA 9049D9            MOV     DPTR,#049D9H
01DD 7410              MOV     A,#010H
01DF F0                MOVX    @DPTR,A
01E0 9049D7            MOV     DPTR,#049D7H
01E3 7404              MOV     A,#04H
01E5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 250
01E6 900000      E     MOV     DPTR,#I2C_mstrStatus
01E9 E0                MOVX    A,@DPTR
01EA 4490              ORL     A,#090H
01EC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 252
                                           ; SOURCE LINE # 254
01ED 8061              SJMP    ?C0002
                                           ; SOURCE LINE # 256
01EF         ?C0063:
                                           ; SOURCE LINE # 258
01EF 9049D8            MOV     DPTR,#049D8H
01F2 E0                MOVX    A,@DPTR
01F3 FF                MOV     R7,A
01F4 900000      E     MOV     DPTR,#I2C_mstrRdBufPtr
01F7 120000      E     LCALL   ?C?PLDXDATA
01FA 900000      E     MOV     DPTR,#I2C_mstrRdBufIndex
01FD E0                MOVX    A,@DPTR
01FE 29                ADD     A,R1
01FF F9                MOV     R1,A
0200 E4                CLR     A
0201 3A                ADDC    A,R2
0202 FA                MOV     R2,A
0203 EF                MOV     A,R7
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 17  

0204 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 259
0207 900000      E     MOV     DPTR,#I2C_mstrRdBufIndex
020A E0                MOVX    A,@DPTR
020B 04                INC     A
020C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 262
020D 900000      E     MOV     DPTR,#I2C_mstrRdBufSize
0210 E0                MOVX    A,@DPTR
0211 FF                MOV     R7,A
0212 900000      E     MOV     DPTR,#I2C_mstrRdBufIndex
0215 E0                MOVX    A,@DPTR
0216 C3                CLR     C
0217 9F                SUBB    A,R7
0218 5008              JNC     ?C0064
                                           ; SOURCE LINE # 263
                                           ; SOURCE LINE # 264
021A 9049D7            MOV     DPTR,#049D7H
021D 7410              MOV     A,#010H
021F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 265
0220 802E              SJMP    ?C0002
0222         ?C0064:
                                           ; SOURCE LINE # 267
0222 900000      E     MOV     DPTR,#I2C_mstrControl
0225 E0                MOVX    A,@DPTR
0226 5402              ANL     A,#02H
0228 6015              JZ      ?C0073
                                           ; SOURCE LINE # 268
                                           ; SOURCE LINE # 270
022A 900000      E     MOV     DPTR,#I2C_mstrStatus
022D E0                MOVX    A,@DPTR
022E 4409              ORL     A,#09H
0230 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 273
0231 900000      E     MOV     DPTR,#I2C_state
0234 7460              MOV     A,#060H
0236 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 274
0237 9044C9            MOV     DPTR,#044C9H
023A 7480              MOV     A,#080H
023C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 275
023D 8011              SJMP    ?C0002
                                           ; SOURCE LINE # 277
023F         ?C0073:
                                           ; SOURCE LINE # 278
023F 9049D6            MOV     DPTR,#049D6H
0242 E0                MOVX    A,@DPTR
0243 4410              ORL     A,#010H
0245 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 279
0246 A3                INC     DPTR
0247 E4                CLR     A
0248 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 280
                                           ; SOURCE LINE # 281
0249 8005              SJMP    ?C0002
                                           ; SOURCE LINE # 283
024B         ?C0077:
                                           ; SOURCE LINE # 291
024B 7F00              MOV     R7,#00H
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 18  

024D 120000      E     LCALL   _?CyHalt
                                           ; SOURCE LINE # 294
                                           ; SOURCE LINE # 295
                                           ; SOURCE LINE # 296
0250         ?C0002:
                                           ; SOURCE LINE # 299
0250 900000      R     MOV     DPTR,#tmpCsr
0253 E0                MOVX    A,@DPTR
0254 5420              ANL     A,#020H
0256 6036              JZ      ?C0088
                                           ; SOURCE LINE # 300
                                           ; SOURCE LINE # 301
0258 900000      E     MOV     DPTR,#I2C_mstrStatus
025B E0                MOVX    A,@DPTR
025C FF                MOV     R7,A
025D 900000      E     MOV     DPTR,#I2C_state
0260 E0                MOVX    A,@DPTR
0261 5408              ANL     A,#08H
0263 6004              JZ      ?C0080
0265 7E01              MOV     R6,#01H
0267 8002              SJMP    ?C0081
0269         ?C0080:
0269 7E02              MOV     R6,#02H
026B         ?C0081:
026B EF                MOV     A,R7
026C 4E                ORL     A,R6
026D 900000      E     MOV     DPTR,#I2C_mstrStatus
0270 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 303
0271 9049D6            MOV     DPTR,#049D6H
0274 E0                MOVX    A,@DPTR
0275 54EF              ANL     A,#0EFH
0277 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 304
0278 900000      E     MOV     DPTR,#I2C_state
027B 7410              MOV     A,#010H
027D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 305
                                           ; SOURCE LINE # 307
027E 800E              SJMP    ?C0088
0280         ?C0001:
                                           ; SOURCE LINE # 308
0280 900000      E     MOV     DPTR,#I2C_state
0283 E0                MOVX    A,@DPTR
0284 5410              ANL     A,#010H
0286 7006              JNZ     ?C0088
                                           ; SOURCE LINE # 309
                                           ; SOURCE LINE # 514
0288         ?C0086:
                                           ; SOURCE LINE # 516
                                           ; SOURCE LINE # 518
0288 900000      E     MOV     DPTR,#I2C_state
028B 7410              MOV     A,#010H
028D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 519
                                           ; SOURCE LINE # 524
028E         ?C0088:
028E D007              POP     AR7
0290 D006              POP     AR6
0292 D005              POP     AR5
0294 D004              POP     AR4
0296 D003              POP     AR3
C51 COMPILER V9.51   I2C_INT                                                               10/22/2015 22:07:40 PAGE 19  

0298 D002              POP     AR2
029A D001              POP     AR1
029C D000              POP     AR0
029E D0D0              POP     PSW
02A0 D000        E     POP     ?C?XPAGE1SFR
02A2 D086              POP     DPS
02A4 D084              POP     DPL1
02A6 D085              POP     DPH1
02A8 D082              POP     DPL
02AA D083              POP     DPH
02AC D0F0              POP     B
02AE D0E0              POP     ACC
02B0 32                RETI    
             ; FUNCTION I2C_ISR (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    689    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
