C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE I2C_MASTER
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\I2C_MASTER.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\I2C_MASTER.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) 
                    -PR(.\DP8051\DP8051_Keil_951\Debug/I2C_MASTER.lst) CD OT(5,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\I2C_MASTER.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: I2C_MASTER.c
   3          * Version 3.50
   4          *
   5          * Description:
   6          *  This file provides the source code of APIs for the I2C component master mode.
   7          *
   8          *******************************************************************************
   9          * Copyright 2012-2015, Cypress Semiconductor Corporation. All rights reserved.
  10          * You may use this file only in accordance with the license, terms, conditions,
  11          * disclaimers, and limitations in the end user license agreement accompanying
  12          * the software package with which this file was provided.
  13          *******************************************************************************/
  14          
  15          #include "I2C_PVT.h"
  16          
  17          #if(I2C_MODE_MASTER_ENABLED)
  18          
  19          /**********************************
  20          *      System variables
  21          **********************************/
  22          
  23          volatile uint8 I2C_mstrStatus;     /* Master Status byte  */
  24          volatile uint8 I2C_mstrControl;    /* Master Control byte */
  25          
  26          /* Transmit buffer variables */
  27          volatile uint8 * I2C_mstrRdBufPtr;     /* Pointer to Master Read buffer */
  28          volatile uint8   I2C_mstrRdBufSize;    /* Master Read buffer size       */
  29          volatile uint8   I2C_mstrRdBufIndex;   /* Master Read buffer Index      */
  30          
  31          /* Receive buffer variables */
  32          volatile uint8 * I2C_mstrWrBufPtr;     /* Pointer to Master Write buffer */
  33          volatile uint8   I2C_mstrWrBufSize;    /* Master Write buffer size       */
  34          volatile uint8   I2C_mstrWrBufIndex;   /* Master Write buffer Index      */
  35          
  36          
  37          /*******************************************************************************
  38          * Function Name: I2C_MasterWriteBuf
  39          ********************************************************************************
  40          *
  41          * Summary:
  42          *  Automatically writes an entire buffer of data to a slave device. Once the
  43          *  data transfer is initiated by this function, further data transfer is handled
  44          *  by the included ISR in byte by byte mode.
  45          *
  46          * Parameters:
  47          *  slaveAddr: 7-bit slave address.
  48          *  xferData:  Pointer to buffer of data to be sent.
  49          *  cnt:       Size of buffer to send.
  50          *  mode:      Transfer mode defines: start or restart condition generation at
  51          *             begin of the transfer and complete the transfer or halt before
  52          *             generating a stop.
  53          *
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 2   

  54          * Return:
  55          *  Status error - Zero means no errors.
  56          *
  57          * Side Effects:
  58          *  The included ISR will start a transfer after a start or restart condition is
  59          *  generated.
  60          *
  61          * Global variables:
  62          *  I2C_mstrStatus  - The global variable used to store a current
  63          *                                 status of the I2C Master.
  64          *  I2C_state       - The global variable used to store a current
  65          *                                 state of the software FSM.
  66          *  I2C_mstrControl - The global variable used to control the master
  67          *                                 end of a transaction with or without Stop
  68          *                                 generation.
  69          *  I2C_mstrWrBufPtr - The global variable used to store a pointer
  70          *                                  to the master write buffer.
  71          *  I2C_mstrWrBufIndex - The global variable used to store current
  72          *                                    index within the master write buffer.
  73          *  I2C_mstrWrBufSize - The global variable used to store a master
  74          *                                   write buffer size.
  75          *
  76          * Reentrant:
  77          *  No
  78          *
  79          *******************************************************************************/
  80          uint8 I2C_MasterWriteBuf(uint8 slaveAddress, uint8 * wrData, uint8 cnt, uint8 mode)
  81                
  82          {
  83   1          uint8 errStatus;
  84   1      
  85   1          errStatus = I2C_MSTR_NOT_READY;
  86   1      
  87   1          if(NULL != wrData)
  88   1          {
  89   2              /* Check I2C state to allow transfer: valid states are IDLE or HALT */
  90   2              if(I2C_SM_IDLE == I2C_state)
  91   2              {
  92   3                  /* Master is ready for transaction: check if bus is free */
  93   3                  if(I2C_CHECK_BUS_FREE(I2C_MCSR_REG))
  94   3                  {
  95   4                      errStatus = I2C_MSTR_NO_ERROR;
  96   4                  }
  97   3                  else
  98   3                  {
  99   4                      errStatus = I2C_MSTR_BUS_BUSY;
 100   4                  }
 101   3              }
 102   2              else if(I2C_SM_MSTR_HALT == I2C_state)
 103   2              {
 104   3                  /* Master is ready and waiting for ReStart */
 105   3                  errStatus = I2C_MSTR_NO_ERROR;
 106   3      
 107   3                  I2C_ClearPendingInt();
 108   3                  I2C_mstrStatus &= (uint8) ~I2C_MSTAT_XFER_HALT;
 109   3              }
 110   2              else
 111   2              {
 112   3                  /* errStatus = I2C_MSTR_NOT_READY was send before */
 113   3              }
 114   2      
 115   2              if(I2C_MSTR_NO_ERROR == errStatus)
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 3   

 116   2              {
 117   3                  /* Set state to start write transaction */
 118   3                  I2C_state = I2C_SM_MSTR_WR_ADDR;
 119   3      
 120   3                  /* Prepare write buffer */
 121   3                  I2C_mstrWrBufIndex = 0u;
 122   3                  I2C_mstrWrBufSize  = cnt;
 123   3                  I2C_mstrWrBufPtr   = (volatile uint8 *) wrData;
 124   3      
 125   3                  /* Set end of transaction flag: Stop or Halt (following ReStart) */
 126   3                  I2C_mstrControl = mode;
 127   3      
 128   3                  /* Clear write status history */
 129   3                  I2C_mstrStatus &= (uint8) ~I2C_MSTAT_WR_CMPLT;
 130   3      
 131   3                  /* Hardware actions: write address and generate Start or ReStart */
 132   3                  I2C_DATA_REG = (uint8) (slaveAddress << I2C_SLAVE_ADDR_SHIFT);
 133   3      
 134   3                  if(I2C_CHECK_RESTART(mode))
 135   3                  {
 136   4                      I2C_GENERATE_RESTART;
 137   4                  }
 138   3                  else
 139   3                  {
 140   4                      I2C_GENERATE_START;
 141   4                  }
 142   3      
 143   3                  /* Enable interrupt to complete transfer */
 144   3                  I2C_EnableInt();
 145   3              }
 146   2          }
 147   1      
 148   1          return(errStatus);
 149   1      }
 150          
 151          
 152          /*******************************************************************************
 153          * Function Name: I2C_MasterReadBuf
 154          ********************************************************************************
 155          *
 156          * Summary:
 157          *  Automatically writes an entire buffer of data to a slave device. Once the
 158          *  data transfer is initiated by this function, further data transfer is handled
 159          *  by the included ISR in byte by byte mode.
 160          *
 161          * Parameters:
 162          *  slaveAddr: 7-bit slave address.
 163          *  xferData:  Pointer to buffer where to put data from slave.
 164          *  cnt:       Size of buffer to read.
 165          *  mode:      Transfer mode defines: start or restart condition generation at
 166          *             begin of the transfer and complete the transfer or halt before
 167          *             generating a stop.
 168          *
 169          * Return:
 170          *  Status error - Zero means no errors.
 171          *
 172          * Side Effects:
 173          *  The included ISR will start a transfer after start or restart condition is
 174          *  generated.
 175          *
 176          * Global variables:
 177          *  I2C_mstrStatus  - The global variable used to store a current
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 4   

 178          *                                 status of the I2C Master.
 179          *  I2C_state       - The global variable used to store a current
 180          *                                 state of the software FSM.
 181          *  I2C_mstrControl - The global variable used to control the master
 182          *                                 end of a transaction with or without
 183          *                                 Stop generation.
 184          *  I2C_mstrRdBufPtr - The global variable used to store a pointer
 185          *                                  to the master write buffer.
 186          *  I2C_mstrRdBufIndex - The global variable  used to store a
 187          *                                    current index within the master
 188          *                                    write buffer.
 189          *  I2C_mstrRdBufSize - The global variable used to store a master
 190          *                                   write buffer size.
 191          *
 192          * Reentrant:
 193          *  No.
 194          *
 195          *******************************************************************************/
 196          uint8 I2C_MasterReadBuf(uint8 slaveAddress, uint8 * rdData, uint8 cnt, uint8 mode)
 197                
 198          {
 199   1          uint8 errStatus;
 200   1      
 201   1          errStatus = I2C_MSTR_NOT_READY;
 202   1      
 203   1          if(NULL != rdData)
 204   1          {
 205   2              /* Check I2C state to allow transfer: valid states are IDLE or HALT */
 206   2              if(I2C_SM_IDLE == I2C_state)
 207   2              {
 208   3                  /* Master is ready to transaction: check if bus is free */
 209   3                  if(I2C_CHECK_BUS_FREE(I2C_MCSR_REG))
 210   3                  {
 211   4                      errStatus = I2C_MSTR_NO_ERROR;
 212   4                  }
 213   3                  else
 214   3                  {
 215   4                      errStatus = I2C_MSTR_BUS_BUSY;
 216   4                  }
 217   3              }
 218   2              else if(I2C_SM_MSTR_HALT == I2C_state)
 219   2              {
 220   3                  /* Master is ready and waiting for ReStart */
 221   3                  errStatus = I2C_MSTR_NO_ERROR;
 222   3      
 223   3                  I2C_ClearPendingInt();
 224   3                  I2C_mstrStatus &= (uint8) ~I2C_MSTAT_XFER_HALT;
 225   3              }
 226   2              else
 227   2              {
 228   3                  /* errStatus = I2C_MSTR_NOT_READY was set before */
 229   3              }
 230   2      
 231   2              if(I2C_MSTR_NO_ERROR == errStatus)
 232   2              {
 233   3                  /* Set state to start write transaction */
 234   3                  I2C_state = I2C_SM_MSTR_RD_ADDR;
 235   3      
 236   3                  /* Prepare read buffer */
 237   3                  I2C_mstrRdBufIndex  = 0u;
 238   3                  I2C_mstrRdBufSize   = cnt;
 239   3                  I2C_mstrRdBufPtr    = (volatile uint8 *) rdData;
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 5   

 240   3      
 241   3                  /* Set end of transaction flag: Stop or Halt (following ReStart) */
 242   3                  I2C_mstrControl = mode;
 243   3      
 244   3                  /* Clear read status history */
 245   3                  I2C_mstrStatus &= (uint8) ~I2C_MSTAT_RD_CMPLT;
 246   3      
 247   3                  /* Hardware actions: write address and generate Start or ReStart */
 248   3                  I2C_DATA_REG = ((uint8) (slaveAddress << I2C_SLAVE_ADDR_SHIFT) |
 249   3                                                        I2C_READ_FLAG);
 250   3      
 251   3                  if(I2C_CHECK_RESTART(mode))
 252   3                  {
 253   4                      I2C_GENERATE_RESTART;
 254   4                  }
 255   3                  else
 256   3                  {
 257   4                      I2C_GENERATE_START;
 258   4                  }
 259   3      
 260   3                  /* Enable interrupt to complete transfer */
 261   3                  I2C_EnableInt();
 262   3              }
 263   2          }
 264   1      
 265   1          return(errStatus);
 266   1      }
 267          
 268          
 269          /*******************************************************************************
 270          * Function Name: I2C_MasterSendStart
 271          ********************************************************************************
 272          *
 273          * Summary:
 274          *  Generates Start condition and sends slave address with read/write bit.
 275          *
 276          * Parameters:
 277          *  slaveAddress:  7-bit slave address.
 278          *  R_nW:          Zero, send write command, non-zero send read command.
 279          *
 280          * Return:
 281          *  Status error - Zero means no errors.
 282          *
 283          * Side Effects:
 284          *  This function is entered without a "byte complete" bit set in the I2C_CSR
 285          *  register. It does not exit until it is set.
 286          *
 287          * Global variables:
 288          *  I2C_state - The global variable used to store a current state of
 289          *                           the software FSM.
 290          *
 291          * Reentrant:
 292          *  No.
 293          *
 294          *******************************************************************************/
 295          uint8 I2C_MasterSendStart(uint8 slaveAddress, uint8 R_nW)
 296                
 297          {
 298   1          uint8 errStatus;
 299   1      
 300   1          errStatus = I2C_MSTR_NOT_READY;
 301   1      
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 6   

 302   1          /* If IDLE, check if bus is free */
 303   1          if(I2C_SM_IDLE == I2C_state)
 304   1          {
 305   2              /* If bus is free, generate Start condition */
 306   2              if(I2C_CHECK_BUS_FREE(I2C_MCSR_REG))
 307   2              {
 308   3                  /* Disable interrupt for manual master operation */
 309   3                  I2C_DisableInt();
 310   3      
 311   3                  /* Set address and read/write flag */
 312   3                  slaveAddress = (uint8) (slaveAddress << I2C_SLAVE_ADDR_SHIFT);
 313   3                  if(0u != R_nW)
 314   3                  {
 315   4                      slaveAddress |= I2C_READ_FLAG;
 316   4                      I2C_state = I2C_SM_MSTR_RD_ADDR;
 317   4                  }
 318   3                  else
 319   3                  {
 320   4                      I2C_state = I2C_SM_MSTR_WR_ADDR;
 321   4                  }
 322   3      
 323   3                  /* Hardware actions: write address and generate Start */
 324   3                  I2C_DATA_REG = slaveAddress;
 325   3                  I2C_GENERATE_START_MANUAL;
 326   3      
 327   3                  /* Wait until address is transferred */
 328   3                  while(I2C_WAIT_BYTE_COMPLETE(I2C_CSR_REG))
 329   3                  {
 330   4                  }
 331   3      
 332   3              #if(I2C_MODE_MULTI_MASTER_SLAVE_ENABLED)
                          if(I2C_CHECK_START_GEN(I2C_MCSR_REG))
                          {
                              I2C_CLEAR_START_GEN;
              
                              /* Start condition was not generated: reset FSM to IDLE */
                              I2C_state = I2C_SM_IDLE;
                              errStatus = I2C_MSTR_ERR_ABORT_START_GEN;
                          }
                          else
                      #endif /* (I2C_MODE_MULTI_MASTER_SLAVE_ENABLED) */
 343   3      
 344   3              #if(I2C_MODE_MULTI_MASTER_ENABLED)
                          if(I2C_CHECK_LOST_ARB(I2C_CSR_REG))
                          {
                              I2C_BUS_RELEASE_MANUAL;
              
                              /* Master lost arbitrage: reset FSM to IDLE */
                              I2C_state = I2C_SM_IDLE;
                              errStatus = I2C_MSTR_ERR_ARB_LOST;
                          }
                          else
                      #endif /* (I2C_MODE_MULTI_MASTER_ENABLED) */
 355   3      
 356   3                  if(I2C_CHECK_ADDR_NAK(I2C_CSR_REG))
 357   3                  {
 358   4                      /* Address has been NACKed: reset FSM to IDLE */
 359   4                      I2C_state = I2C_SM_IDLE;
 360   4                      errStatus = I2C_MSTR_ERR_LB_NAK;
 361   4                  }
 362   3                  else
 363   3                  {
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 7   

 364   4                      /* Start was sent without errors */
 365   4                      errStatus = I2C_MSTR_NO_ERROR;
 366   4                  }
 367   3              }
 368   2              else
 369   2              {
 370   3                  errStatus = I2C_MSTR_BUS_BUSY;
 371   3              }
 372   2          }
 373   1      
 374   1          return(errStatus);
 375   1      }
 376          
 377          
 378          /*******************************************************************************
 379          * Function Name: I2C_MasterSendRestart
 380          ********************************************************************************
 381          *
 382          * Summary:
 383          *  Generates ReStart condition and sends slave address with read/write bit.
 384          *
 385          * Parameters:
 386          *  slaveAddress:  7-bit slave address.
 387          *  R_nW:          Zero, send write command, non-zero send read command.
 388          *
 389          * Return:
 390          *  Status error - Zero means no errors.
 391          *
 392          * Side Effects:
 393          *  This function is entered without a "byte complete" bit set in the I2C_CSR
 394          *  register. It does not exit until it is set.
 395          *
 396          * Global variables:
 397          *  I2C_state - The global variable used to store a current state of
 398          *                           the software FSM.
 399          *
 400          * Reentrant:
 401          *  No.
 402          *
 403          *******************************************************************************/
 404          uint8 I2C_MasterSendRestart(uint8 slaveAddress, uint8 R_nW)
 405                
 406          {
 407   1          uint8 errStatus;
 408   1      
 409   1          errStatus = I2C_MSTR_NOT_READY;
 410   1      
 411   1          /* Check if START condition was generated */
 412   1          if(I2C_CHECK_MASTER_MODE(I2C_MCSR_REG))
 413   1          {
 414   2              /* Set address and read/write flag */
 415   2              slaveAddress = (uint8) (slaveAddress << I2C_SLAVE_ADDR_SHIFT);
 416   2              if(0u != R_nW)
 417   2              {
 418   3                  slaveAddress |= I2C_READ_FLAG;
 419   3                  I2C_state = I2C_SM_MSTR_RD_ADDR;
 420   3              }
 421   2              else
 422   2              {
 423   3                  I2C_state = I2C_SM_MSTR_WR_ADDR;
 424   3              }
 425   2      
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 8   

 426   2              /* Hardware actions: write address and generate ReStart */
 427   2              I2C_DATA_REG = slaveAddress;
 428   2              I2C_GENERATE_RESTART_MANUAL;
 429   2      
 430   2              /* Wait until address has been transferred */
 431   2              while(I2C_WAIT_BYTE_COMPLETE(I2C_CSR_REG))
 432   2              {
 433   3              }
 434   2      
 435   2          #if(I2C_MODE_MULTI_MASTER_ENABLED)
                      if(I2C_CHECK_LOST_ARB(I2C_CSR_REG))
                      {
                          I2C_BUS_RELEASE_MANUAL;
              
                          /* Master lost arbitrage: reset FSM to IDLE */
                          I2C_state = I2C_SM_IDLE;
                          errStatus = I2C_MSTR_ERR_ARB_LOST;
                      }
                      else
                  #endif /* (I2C_MODE_MULTI_MASTER_ENABLED) */
 446   2      
 447   2              if(I2C_CHECK_ADDR_NAK(I2C_CSR_REG))
 448   2              {
 449   3                  /* Address has been NACKed: reset FSM to IDLE */
 450   3                  I2C_state = I2C_SM_IDLE;
 451   3                  errStatus = I2C_MSTR_ERR_LB_NAK;
 452   3              }
 453   2              else
 454   2              {
 455   3                  /* ReStart was sent without errors */
 456   3                  errStatus = I2C_MSTR_NO_ERROR;
 457   3              }
 458   2          }
 459   1      
 460   1          return(errStatus);
 461   1      }
 462          
 463          
 464          /*******************************************************************************
 465          * Function Name: I2C_MasterSendStop
 466          ********************************************************************************
 467          *
 468          * Summary:
 469          *  Generates I2C Stop condition on bus. Function do nothing if Start or Restart
 470          *  condition was failed before call this function.
 471          *
 472          * Parameters:
 473          *  None.
 474          *
 475          * Return:
 476          *  Status error - Zero means no errors.
 477          *
 478          * Side Effects:
 479          *  Stop generation is required to complete the transaction.
 480          *  This function does not wait until a Stop condition is generated.
 481          *
 482          * Global variables:
 483          *  I2C_state - The global variable used to store a current state of
 484          *                           the software FSM.
 485          *
 486          * Reentrant:
 487          *  No.
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 9   

 488          *
 489          *******************************************************************************/
 490          uint8 I2C_MasterSendStop(void) 
 491          {
 492   1          uint8 errStatus;
 493   1      
 494   1          errStatus = I2C_MSTR_NOT_READY;
 495   1      
 496   1          /* Check if master is active on bus */
 497   1          if(I2C_CHECK_MASTER_MODE(I2C_MCSR_REG))
 498   1          {
 499   2              I2C_GENERATE_STOP_MANUAL;
 500   2              I2C_state = I2C_SM_IDLE;
 501   2      
 502   2              /* Wait until stop has been generated */
 503   2              while(I2C_WAIT_STOP_COMPLETE(I2C_CSR_REG))
 504   2              {
 505   3              }
 506   2      
 507   2              errStatus = I2C_MSTR_NO_ERROR;
 508   2      
 509   2          #if(I2C_MODE_MULTI_MASTER_ENABLED)
                      if(I2C_CHECK_LOST_ARB(I2C_CSR_REG))
                      {
                          I2C_BUS_RELEASE_MANUAL;
              
                          /* NACK was generated by instead Stop */
                          errStatus = I2C_MSTR_ERR_ARB_LOST;
                      }
                  #endif /* (I2C_MODE_MULTI_MASTER_ENABLED) */
 518   2          }
 519   1      
 520   1          return(errStatus);
 521   1      }
 522          
 523          
 524          /*******************************************************************************
 525          * Function Name: I2C_MasterWriteByte
 526          ********************************************************************************
 527          *
 528          * Summary:
 529          *  Sends one byte to a slave. A valid Start or ReStart condition must be
 530          *  generated before this call this function. Function do nothing if Start or
 531          *  Restart condition was failed before call this function.
 532          *
 533          * Parameters:
 534          *  data:  The data byte to send to the slave.
 535          *
 536          * Return:
 537          *  Status error - Zero means no errors.
 538          *
 539          * Side Effects:
 540          *  This function is entered without a "byte complete" bit set in the I2C_CSR
 541          *  register. It does not exit until it is set.
 542          *
 543          * Global variables:
 544          *  I2C_state - The global variable used to store a current state of
 545          *                           the software FSM.
 546          *
 547          *******************************************************************************/
 548          uint8 I2C_MasterWriteByte(uint8 theByte) 
 549          {
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 10  

 550   1          uint8 errStatus;
 551   1      
 552   1          errStatus = I2C_MSTR_NOT_READY;
 553   1      
 554   1          /* Check if START condition was generated */
 555   1          if(I2C_CHECK_MASTER_MODE(I2C_MCSR_REG))
 556   1          {
 557   2              I2C_DATA_REG = theByte;   /* Write DATA register */
 558   2              I2C_TRANSMIT_DATA_MANUAL; /* Set transmit mode   */
 559   2              I2C_state = I2C_SM_MSTR_WR_DATA;
 560   2      
 561   2              /* Wait until data byte has been transmitted */
 562   2              while(I2C_WAIT_BYTE_COMPLETE(I2C_CSR_REG))
 563   2              {
 564   3              }
 565   2      
 566   2          #if(I2C_MODE_MULTI_MASTER_ENABLED)
                      if(I2C_CHECK_LOST_ARB(I2C_CSR_REG))
                      {
                          I2C_BUS_RELEASE_MANUAL;
              
                          /* Master lost arbitrage: reset FSM to IDLE */
                          I2C_state = I2C_SM_IDLE;
                          errStatus = I2C_MSTR_ERR_ARB_LOST;
                      }
                      /* Check LRB bit */
                      else
                  #endif /* (I2C_MODE_MULTI_MASTER_ENABLED) */
 578   2      
 579   2              if(I2C_CHECK_DATA_ACK(I2C_CSR_REG))
 580   2              {
 581   3                  I2C_state = I2C_SM_MSTR_HALT;
 582   3                  errStatus = I2C_MSTR_NO_ERROR;
 583   3              }
 584   2              else
 585   2              {
 586   3                  I2C_state = I2C_SM_MSTR_HALT;
 587   3                  errStatus = I2C_MSTR_ERR_LB_NAK;
 588   3              }
 589   2          }
 590   1      
 591   1          return(errStatus);
 592   1      }
 593          
 594          
 595          /*******************************************************************************
 596          * Function Name: I2C_MasterReadByte
 597          ********************************************************************************
 598          *
 599          * Summary:
 600          *  Reads one byte from a slave and ACK or NACK the transfer. A valid Start or
 601          *  ReStart condition must be generated before this call this function. Function
 602          *  do nothing if Start or Restart condition was failed before call this
 603          *  function.
 604          *
 605          * Parameters:
 606          *  acknNack:  Zero, response with NACK, if non-zero response with ACK.
 607          *
 608          * Return:
 609          *  Byte read from slave.
 610          *
 611          * Side Effects:
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 11  

 612          *  This function is entered without a "byte complete" bit set in the I2C_CSR
 613          *  register. It does not exit until it is set.
 614          *
 615          * Global variables:
 616          *  I2C_state - The global variable used to store a current
 617          *                           state of the software FSM.
 618          *
 619          * Reentrant:
 620          *  No.
 621          *
 622          *******************************************************************************/
 623          uint8 I2C_MasterReadByte(uint8 acknNak) 
 624          {
 625   1          uint8 theByte;
 626   1      
 627   1          theByte = 0u;
 628   1      
 629   1          /* Check if START condition was generated */
 630   1          if(I2C_CHECK_MASTER_MODE(I2C_MCSR_REG))
 631   1          {
 632   2              /* When address phase needs to release bus and receive byte,
 633   2              * then decide ACK or NACK
 634   2              */
 635   2              if(I2C_SM_MSTR_RD_ADDR == I2C_state)
 636   2              {
 637   3                  I2C_READY_TO_READ_MANUAL;
 638   3                  I2C_state = I2C_SM_MSTR_RD_DATA;
 639   3              }
 640   2      
 641   2              /* Wait until data byte has been received */
 642   2              while(I2C_WAIT_BYTE_COMPLETE(I2C_CSR_REG))
 643   2              {
 644   3              }
 645   2      
 646   2              theByte = I2C_DATA_REG;
 647   2      
 648   2              /* Command ACK to receive next byte and continue transfer.
 649   2              *  Do nothing for NACK. The NACK will be generated by
 650   2              *  Stop or ReStart routine.
 651   2              */
 652   2              if(acknNak != 0u) /* Generate ACK */
 653   2              {
 654   3                  I2C_ACK_AND_RECEIVE_MANUAL;
 655   3              }
 656   2              else              /* Do nothing for the follwong NACK */
 657   2              {
 658   3                  I2C_state = I2C_SM_MSTR_HALT;
 659   3              }
 660   2          }
 661   1      
 662   1          return(theByte);
 663   1      }
 664          
 665          
 666          /*******************************************************************************
 667          * Function Name: I2C_MasterStatus
 668          ********************************************************************************
 669          *
 670          * Summary:
 671          *  Returns the master's communication status.
 672          *
 673          * Parameters:
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 12  

 674          *  None.
 675          *
 676          * Return:
 677          *  Current status of I2C master.
 678          *
 679          * Global variables:
 680          *  I2C_mstrStatus - The global variable used to store a current
 681          *                                status of the I2C Master.
 682          *
 683          *******************************************************************************/
 684          uint8 I2C_MasterStatus(void) 
 685          {
 686   1          uint8 status;
 687   1      
 688   1          I2C_DisableInt(); /* Lock from interrupt */
 689   1      
 690   1          /* Read master status */
 691   1          status = I2C_mstrStatus;
 692   1      
 693   1          if (I2C_CHECK_SM_MASTER)
 694   1          {
 695   2              /* Set transfer in progress flag in status */
 696   2              status |= I2C_MSTAT_XFER_INP;
 697   2          }
 698   1      
 699   1          I2C_EnableInt(); /* Release lock */
 700   1      
 701   1          return (status);
 702   1      }
 703          
 704          
 705          /*******************************************************************************
 706          * Function Name: I2C_MasterClearStatus
 707          ********************************************************************************
 708          *
 709          * Summary:
 710          *  Clears all status flags and returns the master status.
 711          *
 712          * Parameters:
 713          *  None.
 714          *
 715          * Return:
 716          *  Current status of I2C master.
 717          *
 718          * Global variables:
 719          *  I2C_mstrStatus - The global variable used to store a current
 720          *                                status of the I2C Master.
 721          *
 722          * Reentrant:
 723          *  No.
 724          *
 725          *******************************************************************************/
 726          uint8 I2C_MasterClearStatus(void) 
 727          {
 728   1          uint8 status;
 729   1      
 730   1          I2C_DisableInt(); /* Lock from interrupt */
 731   1      
 732   1          /* Read and clear master status */
 733   1          status = I2C_mstrStatus;
 734   1          I2C_mstrStatus = I2C_MSTAT_CLEAR;
 735   1      
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 13  

 736   1          I2C_EnableInt(); /* Release lock */
 737   1      
 738   1          return (status);
 739   1      }
 740          
 741          
 742          /*******************************************************************************
 743          * Function Name: I2C_MasterGetReadBufSize
 744          ********************************************************************************
 745          *
 746          * Summary:
 747          *  Returns the amount of bytes that has been transferred with an
 748          *  I2C_MasterReadBuf command.
 749          *
 750          * Parameters:
 751          *  None.
 752          *
 753          * Return:
 754          *  Byte count of transfer. If the transfer is not yet complete, it will return
 755          *  the byte count transferred so far.
 756          *
 757          * Global variables:
 758          *  I2C_mstrRdBufIndex - The global variable stores current index
 759          *                                    within the master read buffer.
 760          *
 761          *******************************************************************************/
 762          uint8 I2C_MasterGetReadBufSize(void) 
 763          {
 764   1          return (I2C_mstrRdBufIndex);
 765   1      }
 766          
 767          
 768          /*******************************************************************************
 769          * Function Name: I2C_MasterGetWriteBufSize
 770          ********************************************************************************
 771          *
 772          * Summary:
 773          *  Returns the amount of bytes that has been transferred with an
 774          *  I2C_MasterWriteBuf command.
 775          *
 776          * Parameters:
 777          *  None.
 778          *
 779          * Return:
 780          *  Byte count of transfer. If the transfer is not yet complete, it will return
 781          *  the byte count transferred so far.
 782          *
 783          * Global variables:
 784          *  I2C_mstrWrBufIndex -  The global variable used to stores current
 785          *                                     index within master write buffer.
 786          *
 787          *******************************************************************************/
 788          uint8 I2C_MasterGetWriteBufSize(void) 
 789          {
 790   1          return (I2C_mstrWrBufIndex);
 791   1      }
 792          
 793          
 794          /*******************************************************************************
 795          * Function Name: I2C_MasterClearReadBuf
 796          ********************************************************************************
 797          *
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 14  

 798          * Summary:
 799          *  Resets the read buffer pointer back to the first byte in the buffer.
 800          *
 801          * Parameters:
 802          *  None.
 803          *
 804          * Return:
 805          *  None.
 806          *
 807          * Global variables:
 808          *  I2C_mstrRdBufIndex - The global variable used to stores current
 809          *                                    index within master read buffer.
 810          *  I2C_mstrStatus - The global variable used to store a current
 811          *                                status of the I2C Master.
 812          *
 813          * Reentrant:
 814          *  No.
 815          *
 816          *******************************************************************************/
 817          void I2C_MasterClearReadBuf(void) 
 818          {
 819   1          I2C_DisableInt(); /* Lock from interrupt */
 820   1      
 821   1          I2C_mstrRdBufIndex = 0u;
 822   1          I2C_mstrStatus    &= (uint8) ~I2C_MSTAT_RD_CMPLT;
 823   1      
 824   1          I2C_EnableInt(); /* Release lock */
 825   1      }
 826          
 827          
 828          /*******************************************************************************
 829          * Function Name: I2C_MasterClearWriteBuf
 830          ********************************************************************************
 831          *
 832          * Summary:
 833          *  Resets the write buffer pointer back to the first byte in the buffer.
 834          *
 835          * Parameters:
 836          *  None.
 837          *
 838          * Return:
 839          *  None.
 840          *
 841          * Global variables:
 842          *  I2C_mstrRdBufIndex - The global variable used to stote current
 843          *                                    index within master read buffer.
 844          *  I2C_mstrStatus - The global variable used to store a current
 845          *                                status of the I2C Master.
 846          *
 847          * Reentrant:
 848          *  No.
 849          *
 850          *******************************************************************************/
 851          void I2C_MasterClearWriteBuf(void) 
 852          {
 853   1          I2C_DisableInt(); /* Lock from interrupt */
 854   1      
 855   1          I2C_mstrWrBufIndex = 0u;
 856   1          I2C_mstrStatus    &= (uint8) ~I2C_MSTAT_WR_CMPLT;
 857   1      
 858   1          I2C_EnableInt(); /* Release lock */
 859   1      }
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 15  

 860          
 861          #endif /* (I2C_MODE_MASTER_ENABLED) */
 862          
 863          
 864          /* [] END OF FILE */
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 16  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _I2C_MasterWriteBuf (BEGIN)
                                           ; SOURCE LINE # 80
0000 900000      R     MOV     DPTR,#wrData
0003 120000      E     LCALL   ?C?PSTXDATA
;---- Variable 'slaveAddress' assigned to Register 'R4' ----
0006 AC07              MOV     R4,AR7
                                           ; SOURCE LINE # 82
                                           ; SOURCE LINE # 85
;---- Variable 'errStatus' assigned to Register 'R5' ----
0008 7D02              MOV     R5,#02H
                                           ; SOURCE LINE # 87
000A 900000      R     MOV     DPTR,#wrData
000D 120000      E     LCALL   ?C?PLDXDATA
0010 E9                MOV     A,R1
0011 4A                ORL     A,R2
0012 4B                ORL     A,R3
0013 7003              JNZ     $ + 5H
0015 020000      R     LJMP    ?C0001
                                           ; SOURCE LINE # 88
                                           ; SOURCE LINE # 90
0018 900000      E     MOV     DPTR,#I2C_state
001B E0                MOVX    A,@DPTR
001C B4100F            CJNE    A,#010H,?C0002
                                           ; SOURCE LINE # 91
                                           ; SOURCE LINE # 93
001F 9049D9            MOV     DPTR,#049D9H
0022 E0                MOVX    A,@DPTR
0023 5408              ANL     A,#08H
0025 7003              JNZ     ?C0003
                                           ; SOURCE LINE # 94
                                           ; SOURCE LINE # 95
0027 FD                MOV     R5,A
                                           ; SOURCE LINE # 96
0028 801A              SJMP    ?C0005
002A         ?C0003:
                                           ; SOURCE LINE # 98
                                           ; SOURCE LINE # 99
002A 7D01              MOV     R5,#01H
                                           ; SOURCE LINE # 100
                                           ; SOURCE LINE # 101
002C 8016              SJMP    ?C0005
002E         ?C0002:
                                           ; SOURCE LINE # 102
002E 900000      E     MOV     DPTR,#I2C_state
0031 E0                MOVX    A,@DPTR
0032 B4600F            CJNE    A,#060H,?C0005
                                           ; SOURCE LINE # 103
                                           ; SOURCE LINE # 105
0035 E4                CLR     A
0036 FD                MOV     R5,A
                                           ; SOURCE LINE # 107
0037 9044D9            MOV     DPTR,#044D9H
003A 7480              MOV     A,#080H
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 108
003D 900000      R     MOV     DPTR,#I2C_mstrStatus
0040 E0                MOVX    A,@DPTR
0041 54F7              ANL     A,#0F7H
0043 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 17  

                                           ; SOURCE LINE # 109
                                           ; SOURCE LINE # 111
                                           ; SOURCE LINE # 113
0044         ?C0005:
                                           ; SOURCE LINE # 115
0044 ED                MOV     A,R5
0045 7055              JNZ     ?C0001
                                           ; SOURCE LINE # 116
                                           ; SOURCE LINE # 118
0047 900000      E     MOV     DPTR,#I2C_state
004A 7445              MOV     A,#045H
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 121
004D E4                CLR     A
004E 900000      R     MOV     DPTR,#I2C_mstrWrBufIndex
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 122
0052 900000      R     MOV     DPTR,#cnt
0055 E0                MOVX    A,@DPTR
0056 900000      R     MOV     DPTR,#I2C_mstrWrBufSize
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 123
005A 900000      R     MOV     DPTR,#wrData
005D 120000      E     LCALL   ?C?PLDXDATA
0060 900000      R     MOV     DPTR,#I2C_mstrWrBufPtr
0063 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 126
0066 900000      R     MOV     DPTR,#mode
0069 E0                MOVX    A,@DPTR
006A FF                MOV     R7,A
006B 900000      R     MOV     DPTR,#I2C_mstrControl
006E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 129
006F 900000      R     MOV     DPTR,#I2C_mstrStatus
0072 E0                MOVX    A,@DPTR
0073 54FD              ANL     A,#0FDH
0075 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 132
0076 AE04              MOV     R6,AR4
0078 EE                MOV     A,R6
0079 25E0              ADD     A,ACC
007B 9049D8            MOV     DPTR,#049D8H
007E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 134
007F EF                MOV     A,R7
0080 5401              ANL     A,#01H
0082 600C              JZ      ?C0016
                                           ; SOURCE LINE # 135
                                           ; SOURCE LINE # 136
0084 A3                INC     DPTR
0085 7412              MOV     A,#012H
0087 F0                MOVX    @DPTR,A
0088 9049D7            MOV     DPTR,#049D7H
008B 7404              MOV     A,#04H
008D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 137
008E 8006              SJMP    ?C0013
                                           ; SOURCE LINE # 139
0090         ?C0016:
                                           ; SOURCE LINE # 140
0090 9049D9            MOV     DPTR,#049D9H
0093 7401              MOV     A,#01H
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 18  

0095 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 141
0096         ?C0013:
                                           ; SOURCE LINE # 144
0096 9044C1            MOV     DPTR,#044C1H
0099 7480              MOV     A,#080H
009B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 145
                                           ; SOURCE LINE # 146
009C         ?C0001:
                                           ; SOURCE LINE # 148
009C AF05              MOV     R7,AR5
                                           ; SOURCE LINE # 149
009E         ?C0017:
009E 22                RET     
             ; FUNCTION _I2C_MasterWriteBuf (END)

             ; FUNCTION _I2C_MasterReadBuf (BEGIN)
                                           ; SOURCE LINE # 196
0000 900000      R     MOV     DPTR,#rdData
0003 120000      E     LCALL   ?C?PSTXDATA
;---- Variable 'slaveAddress' assigned to Register 'R4' ----
0006 AC07              MOV     R4,AR7
                                           ; SOURCE LINE # 198
                                           ; SOURCE LINE # 201
;---- Variable 'errStatus' assigned to Register 'R5' ----
0008 7D02              MOV     R5,#02H
                                           ; SOURCE LINE # 203
000A 900000      R     MOV     DPTR,#rdData
000D 120000      E     LCALL   ?C?PLDXDATA
0010 E9                MOV     A,R1
0011 4A                ORL     A,R2
0012 4B                ORL     A,R3
0013 7003              JNZ     $ + 5H
0015 020000      R     LJMP    ?C0018
                                           ; SOURCE LINE # 204
                                           ; SOURCE LINE # 206
0018 900000      E     MOV     DPTR,#I2C_state
001B E0                MOVX    A,@DPTR
001C B4100F            CJNE    A,#010H,?C0019
                                           ; SOURCE LINE # 207
                                           ; SOURCE LINE # 209
001F 9049D9            MOV     DPTR,#049D9H
0022 E0                MOVX    A,@DPTR
0023 5408              ANL     A,#08H
0025 7003              JNZ     ?C0020
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 211
0027 FD                MOV     R5,A
                                           ; SOURCE LINE # 212
0028 801A              SJMP    ?C0022
002A         ?C0020:
                                           ; SOURCE LINE # 214
                                           ; SOURCE LINE # 215
002A 7D01              MOV     R5,#01H
                                           ; SOURCE LINE # 216
                                           ; SOURCE LINE # 217
002C 8016              SJMP    ?C0022
002E         ?C0019:
                                           ; SOURCE LINE # 218
002E 900000      E     MOV     DPTR,#I2C_state
0031 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 19  

0032 B4600F            CJNE    A,#060H,?C0022
                                           ; SOURCE LINE # 219
                                           ; SOURCE LINE # 221
0035 E4                CLR     A
0036 FD                MOV     R5,A
                                           ; SOURCE LINE # 223
0037 9044D9            MOV     DPTR,#044D9H
003A 7480              MOV     A,#080H
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 224
003D 900000      R     MOV     DPTR,#I2C_mstrStatus
0040 E0                MOVX    A,@DPTR
0041 54F7              ANL     A,#0F7H
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 225
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 229
0044         ?C0022:
                                           ; SOURCE LINE # 231
0044 ED                MOV     A,R5
0045 7057              JNZ     ?C0018
                                           ; SOURCE LINE # 232
                                           ; SOURCE LINE # 234
0047 900000      E     MOV     DPTR,#I2C_state
004A 7449              MOV     A,#049H
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 237
004D E4                CLR     A
004E 900000      R     MOV     DPTR,#I2C_mstrRdBufIndex
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 238
0052 900000      R     MOV     DPTR,#cnt
0055 E0                MOVX    A,@DPTR
0056 900000      R     MOV     DPTR,#I2C_mstrRdBufSize
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 239
005A 900000      R     MOV     DPTR,#rdData
005D 120000      E     LCALL   ?C?PLDXDATA
0060 900000      R     MOV     DPTR,#I2C_mstrRdBufPtr
0063 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 242
0066 900000      R     MOV     DPTR,#mode
0069 E0                MOVX    A,@DPTR
006A FF                MOV     R7,A
006B 900000      R     MOV     DPTR,#I2C_mstrControl
006E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 245
006F 900000      R     MOV     DPTR,#I2C_mstrStatus
0072 E0                MOVX    A,@DPTR
0073 54FE              ANL     A,#0FEH
0075 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 248
0076 AE04              MOV     R6,AR4
0078 EE                MOV     A,R6
0079 25E0              ADD     A,ACC
007B 4401              ORL     A,#01H
007D 9049D8            MOV     DPTR,#049D8H
0080 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 251
0081 EF                MOV     A,R7
0082 5401              ANL     A,#01H
0084 600C              JZ      ?C0033
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 20  

                                           ; SOURCE LINE # 252
                                           ; SOURCE LINE # 253
0086 A3                INC     DPTR
0087 7412              MOV     A,#012H
0089 F0                MOVX    @DPTR,A
008A 9049D7            MOV     DPTR,#049D7H
008D 7404              MOV     A,#04H
008F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 254
0090 8006              SJMP    ?C0030
                                           ; SOURCE LINE # 256
0092         ?C0033:
                                           ; SOURCE LINE # 257
0092 9049D9            MOV     DPTR,#049D9H
0095 7401              MOV     A,#01H
0097 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 258
0098         ?C0030:
                                           ; SOURCE LINE # 261
0098 9044C1            MOV     DPTR,#044C1H
009B 7480              MOV     A,#080H
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 262
                                           ; SOURCE LINE # 263
009E         ?C0018:
                                           ; SOURCE LINE # 265
009E AF05              MOV     R7,AR5
                                           ; SOURCE LINE # 266
00A0         ?C0034:
00A0 22                RET     
             ; FUNCTION _I2C_MasterReadBuf (END)

             ; FUNCTION _I2C_MasterSendStart (BEGIN)
                                           ; SOURCE LINE # 295
;---- Variable 'slaveAddress' assigned to Register 'R7' ----
;---- Variable 'R_nW' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 297
                                           ; SOURCE LINE # 300
;---- Variable 'errStatus' assigned to Register 'R6' ----
0000 7E02              MOV     R6,#02H
                                           ; SOURCE LINE # 303
0002 900000      E     MOV     DPTR,#I2C_state
0005 E0                MOVX    A,@DPTR
0006 6410              XRL     A,#010H
0008 7052              JNZ     ?C0035
                                           ; SOURCE LINE # 304
                                           ; SOURCE LINE # 306
000A 9049D9            MOV     DPTR,#049D9H
000D E0                MOVX    A,@DPTR
000E 5408              ANL     A,#08H
0010 7048              JNZ     ?C0036
                                           ; SOURCE LINE # 307
                                           ; SOURCE LINE # 309
0012 9044C9            MOV     DPTR,#044C9H
0015 7480              MOV     A,#080H
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 312
0018 EF                MOV     A,R7
0019 25E0              ADD     A,ACC
001B FF                MOV     R7,A
                                           ; SOURCE LINE # 313
001C ED                MOV     A,R5
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 21  

001D 600C              JZ      ?C0037
                                           ; SOURCE LINE # 314
                                           ; SOURCE LINE # 315
001F EF                MOV     A,R7
0020 4401              ORL     A,#01H
0022 FF                MOV     R7,A
                                           ; SOURCE LINE # 316
0023 900000      E     MOV     DPTR,#I2C_state
0026 7449              MOV     A,#049H
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 317
0029 8006              SJMP    ?C0038
002B         ?C0037:
                                           ; SOURCE LINE # 319
                                           ; SOURCE LINE # 320
002B 900000      E     MOV     DPTR,#I2C_state
002E 7445              MOV     A,#045H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 321
0031         ?C0038:
                                           ; SOURCE LINE # 324
0031 9049D8            MOV     DPTR,#049D8H
0034 EF                MOV     A,R7
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 325
0036 A3                INC     DPTR
0037 7401              MOV     A,#01H
0039 F0                MOVX    @DPTR,A
003A         ?C0042:
                                           ; SOURCE LINE # 328
003A 9049D7            MOV     DPTR,#049D7H
003D E0                MOVX    A,@DPTR
003E 5401              ANL     A,#01H
0040 60F8              JZ      ?C0042
                                           ; SOURCE LINE # 329
                                           ; SOURCE LINE # 330
0042         ?C0043:
                                           ; SOURCE LINE # 356
0042 9049D7            MOV     DPTR,#049D7H
0045 E0                MOVX    A,@DPTR
0046 540A              ANL     A,#0AH
0048 640A              XRL     A,#0AH
004A 700A              JNZ     ?C0044
                                           ; SOURCE LINE # 357
                                           ; SOURCE LINE # 359
004C 900000      E     MOV     DPTR,#I2C_state
004F 7410              MOV     A,#010H
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 360
0052 7E03              MOV     R6,#03H
                                           ; SOURCE LINE # 361
0054 8006              SJMP    ?C0035
0056         ?C0044:
                                           ; SOURCE LINE # 363
                                           ; SOURCE LINE # 365
0056 E4                CLR     A
0057 FE                MOV     R6,A
                                           ; SOURCE LINE # 366
                                           ; SOURCE LINE # 367
0058 8002              SJMP    ?C0035
005A         ?C0036:
                                           ; SOURCE LINE # 369
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 22  

                                           ; SOURCE LINE # 370
005A 7E01              MOV     R6,#01H
                                           ; SOURCE LINE # 371
                                           ; SOURCE LINE # 372
005C         ?C0035:
                                           ; SOURCE LINE # 374
005C AF06              MOV     R7,AR6
                                           ; SOURCE LINE # 375
005E         ?C0047:
005E 22                RET     
             ; FUNCTION _I2C_MasterSendStart (END)

             ; FUNCTION _I2C_MasterSendRestart (BEGIN)
                                           ; SOURCE LINE # 404
;---- Variable 'slaveAddress' assigned to Register 'R7' ----
;---- Variable 'R_nW' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 406
                                           ; SOURCE LINE # 409
;---- Variable 'errStatus' assigned to Register 'R6' ----
0000 7E02              MOV     R6,#02H
                                           ; SOURCE LINE # 412
0002 9049D9            MOV     DPTR,#049D9H
0005 E0                MOVX    A,@DPTR
0006 5404              ANL     A,#04H
0008 6046              JZ      ?C0048
                                           ; SOURCE LINE # 413
                                           ; SOURCE LINE # 415
000A EF                MOV     A,R7
000B 25E0              ADD     A,ACC
000D FF                MOV     R7,A
                                           ; SOURCE LINE # 416
000E ED                MOV     A,R5
000F 600C              JZ      ?C0049
                                           ; SOURCE LINE # 417
                                           ; SOURCE LINE # 418
0011 EF                MOV     A,R7
0012 4401              ORL     A,#01H
0014 FF                MOV     R7,A
                                           ; SOURCE LINE # 419
0015 900000      E     MOV     DPTR,#I2C_state
0018 7449              MOV     A,#049H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 420
001B 8006              SJMP    ?C0050
001D         ?C0049:
                                           ; SOURCE LINE # 422
                                           ; SOURCE LINE # 423
001D 900000      E     MOV     DPTR,#I2C_state
0020 7445              MOV     A,#045H
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 424
0023         ?C0050:
                                           ; SOURCE LINE # 427
0023 9049D8            MOV     DPTR,#049D8H
0026 EF                MOV     A,R7
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 428
0028 A3                INC     DPTR
0029 7412              MOV     A,#012H
002B F0                MOVX    @DPTR,A
002C 9049D7            MOV     DPTR,#049D7H
002F 7404              MOV     A,#04H
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 23  

0031 F0                MOVX    @DPTR,A
0032         ?C0054:
                                           ; SOURCE LINE # 431
0032 9049D7            MOV     DPTR,#049D7H
0035 E0                MOVX    A,@DPTR
0036 5401              ANL     A,#01H
0038 60F8              JZ      ?C0054
                                           ; SOURCE LINE # 432
                                           ; SOURCE LINE # 433
003A         ?C0055:
                                           ; SOURCE LINE # 447
003A 9049D7            MOV     DPTR,#049D7H
003D E0                MOVX    A,@DPTR
003E 540A              ANL     A,#0AH
0040 640A              XRL     A,#0AH
0042 700A              JNZ     ?C0056
                                           ; SOURCE LINE # 448
                                           ; SOURCE LINE # 450
0044 900000      E     MOV     DPTR,#I2C_state
0047 7410              MOV     A,#010H
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 451
004A 7E03              MOV     R6,#03H
                                           ; SOURCE LINE # 452
004C 8002              SJMP    ?C0048
004E         ?C0056:
                                           ; SOURCE LINE # 454
                                           ; SOURCE LINE # 456
004E E4                CLR     A
004F FE                MOV     R6,A
                                           ; SOURCE LINE # 457
                                           ; SOURCE LINE # 458
0050         ?C0048:
                                           ; SOURCE LINE # 460
0050 AF06              MOV     R7,AR6
                                           ; SOURCE LINE # 461
0052         ?C0058:
0052 22                RET     
             ; FUNCTION _I2C_MasterSendRestart (END)

             ; FUNCTION I2C_MasterSendStop (BEGIN)
                                           ; SOURCE LINE # 490
                                           ; SOURCE LINE # 491
                                           ; SOURCE LINE # 494
;---- Variable 'errStatus' assigned to Register 'R7' ----
0000 7F02              MOV     R7,#02H
                                           ; SOURCE LINE # 497
0002 9049D9            MOV     DPTR,#049D9H
0005 E0                MOVX    A,@DPTR
0006 5404              ANL     A,#04H
0008 6019              JZ      ?C0059
                                           ; SOURCE LINE # 498
                                           ; SOURCE LINE # 499
000A 7410              MOV     A,#010H
000C F0                MOVX    @DPTR,A
000D 9049D7            MOV     DPTR,#049D7H
0010 7404              MOV     A,#04H
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 500
0013 900000      E     MOV     DPTR,#I2C_state
0016 7410              MOV     A,#010H
0018 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 24  

0019         ?C0063:
                                           ; SOURCE LINE # 503
0019 9049D7            MOV     DPTR,#049D7H
001C E0                MOVX    A,@DPTR
001D 5421              ANL     A,#021H
001F 60F8              JZ      ?C0063
                                           ; SOURCE LINE # 504
                                           ; SOURCE LINE # 505
0021         ?C0064:
                                           ; SOURCE LINE # 507
0021 E4                CLR     A
0022 FF                MOV     R7,A
                                           ; SOURCE LINE # 518
0023         ?C0059:
                                           ; SOURCE LINE # 520
                                           ; SOURCE LINE # 521
0023         ?C0065:
0023 22                RET     
             ; FUNCTION I2C_MasterSendStop (END)

             ; FUNCTION _I2C_MasterWriteByte (BEGIN)
                                           ; SOURCE LINE # 548
;---- Variable 'theByte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 549
                                           ; SOURCE LINE # 552
;---- Variable 'errStatus' assigned to Register 'R6' ----
0000 7E02              MOV     R6,#02H
                                           ; SOURCE LINE # 555
0002 9049D9            MOV     DPTR,#049D9H
0005 E0                MOVX    A,@DPTR
0006 5404              ANL     A,#04H
0008 6033              JZ      ?C0066
                                           ; SOURCE LINE # 556
                                           ; SOURCE LINE # 557
000A 9049D8            MOV     DPTR,#049D8H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 558
000F 9049D7            MOV     DPTR,#049D7H
0012 7404              MOV     A,#04H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 559
0015 900000      E     MOV     DPTR,#I2C_state
0018 7446              MOV     A,#046H
001A F0                MOVX    @DPTR,A
001B         ?C0070:
                                           ; SOURCE LINE # 562
001B 9049D7            MOV     DPTR,#049D7H
001E E0                MOVX    A,@DPTR
001F 5401              ANL     A,#01H
0021 60F8              JZ      ?C0070
                                           ; SOURCE LINE # 563
                                           ; SOURCE LINE # 564
0023         ?C0071:
                                           ; SOURCE LINE # 579
0023 9049D7            MOV     DPTR,#049D7H
0026 E0                MOVX    A,@DPTR
0027 5402              ANL     A,#02H
0029 700A              JNZ     ?C0072
                                           ; SOURCE LINE # 580
                                           ; SOURCE LINE # 581
002B 900000      E     MOV     DPTR,#I2C_state
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 25  

002E 7460              MOV     A,#060H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 582
0031 E4                CLR     A
0032 FE                MOV     R6,A
                                           ; SOURCE LINE # 583
0033 8008              SJMP    ?C0066
0035         ?C0072:
                                           ; SOURCE LINE # 585
                                           ; SOURCE LINE # 586
0035 900000      E     MOV     DPTR,#I2C_state
0038 7460              MOV     A,#060H
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 587
003B 7E03              MOV     R6,#03H
                                           ; SOURCE LINE # 588
                                           ; SOURCE LINE # 589
003D         ?C0066:
                                           ; SOURCE LINE # 591
003D AF06              MOV     R7,AR6
                                           ; SOURCE LINE # 592
003F         ?C0074:
003F 22                RET     
             ; FUNCTION _I2C_MasterWriteByte (END)

             ; FUNCTION _I2C_MasterReadByte (BEGIN)
                                           ; SOURCE LINE # 623
;---- Variable 'acknNak' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 624
                                           ; SOURCE LINE # 627
;---- Variable 'theByte' assigned to Register 'R6' ----
0000 E4                CLR     A
0001 FE                MOV     R6,A
                                           ; SOURCE LINE # 630
0002 9049D9            MOV     DPTR,#049D9H
0005 E0                MOVX    A,@DPTR
0006 5404              ANL     A,#04H
0008 6030              JZ      ?C0075
                                           ; SOURCE LINE # 631
                                           ; SOURCE LINE # 635
000A 900000      E     MOV     DPTR,#I2C_state
000D E0                MOVX    A,@DPTR
000E B4490B            CJNE    A,#049H,?C0080
                                           ; SOURCE LINE # 636
                                           ; SOURCE LINE # 637
0011 9049D7            MOV     DPTR,#049D7H
0014 E4                CLR     A
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 638
0016 900000      E     MOV     DPTR,#I2C_state
0019 744A              MOV     A,#04AH
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 639
001C         ?C0080:
                                           ; SOURCE LINE # 642
001C 9049D7            MOV     DPTR,#049D7H
001F E0                MOVX    A,@DPTR
0020 5401              ANL     A,#01H
0022 60F8              JZ      ?C0080
                                           ; SOURCE LINE # 643
                                           ; SOURCE LINE # 644
0024         ?C0081:
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 26  

                                           ; SOURCE LINE # 646
0024 9049D8            MOV     DPTR,#049D8H
0027 E0                MOVX    A,@DPTR
0028 FE                MOV     R6,A
                                           ; SOURCE LINE # 652
0029 EF                MOV     A,R7
002A 6008              JZ      ?C0082
                                           ; SOURCE LINE # 653
                                           ; SOURCE LINE # 654
002C 9049D7            MOV     DPTR,#049D7H
002F 7410              MOV     A,#010H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 655
0032 8006              SJMP    ?C0075
0034         ?C0082:
                                           ; SOURCE LINE # 657
                                           ; SOURCE LINE # 658
0034 900000      E     MOV     DPTR,#I2C_state
0037 7460              MOV     A,#060H
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 659
                                           ; SOURCE LINE # 660
003A         ?C0075:
                                           ; SOURCE LINE # 662
003A AF06              MOV     R7,AR6
                                           ; SOURCE LINE # 663
003C         ?C0087:
003C 22                RET     
             ; FUNCTION _I2C_MasterReadByte (END)

             ; FUNCTION I2C_MasterStatus (BEGIN)
                                           ; SOURCE LINE # 684
                                           ; SOURCE LINE # 685
                                           ; SOURCE LINE # 688
0000 9044C9            MOV     DPTR,#044C9H
0003 7480              MOV     A,#080H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 691
0006 900000      R     MOV     DPTR,#I2C_mstrStatus
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
;---- Variable 'status' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 693
000B 900000      E     MOV     DPTR,#I2C_state
000E E0                MOVX    A,@DPTR
000F 5440              ANL     A,#040H
0011 6004              JZ      ?C0088
                                           ; SOURCE LINE # 694
                                           ; SOURCE LINE # 696
0013 EF                MOV     A,R7
0014 4404              ORL     A,#04H
0016 FF                MOV     R7,A
                                           ; SOURCE LINE # 697
0017         ?C0088:
                                           ; SOURCE LINE # 699
0017 9044C1            MOV     DPTR,#044C1H
001A 7480              MOV     A,#080H
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 701
                                           ; SOURCE LINE # 702
001D         ?C0089:
001D 22                RET     
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 27  

             ; FUNCTION I2C_MasterStatus (END)

             ; FUNCTION I2C_MasterClearStatus (BEGIN)
                                           ; SOURCE LINE # 726
                                           ; SOURCE LINE # 727
                                           ; SOURCE LINE # 730
0000 9044C9            MOV     DPTR,#044C9H
0003 7480              MOV     A,#080H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 733
0006 900000      R     MOV     DPTR,#I2C_mstrStatus
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
;---- Variable 'status' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 734
000B E4                CLR     A
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 736
000D 9044C1            MOV     DPTR,#044C1H
0010 7480              MOV     A,#080H
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 738
                                           ; SOURCE LINE # 739
0013         ?C0090:
0013 22                RET     
             ; FUNCTION I2C_MasterClearStatus (END)

             ; FUNCTION I2C_MasterGetReadBufSize (BEGIN)
                                           ; SOURCE LINE # 762
                                           ; SOURCE LINE # 763
                                           ; SOURCE LINE # 764
0000 900000      R     MOV     DPTR,#I2C_mstrRdBufIndex
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 765
0005         ?C0091:
0005 22                RET     
             ; FUNCTION I2C_MasterGetReadBufSize (END)

             ; FUNCTION I2C_MasterGetWriteBufSize (BEGIN)
                                           ; SOURCE LINE # 788
                                           ; SOURCE LINE # 789
                                           ; SOURCE LINE # 790
0000 900000      R     MOV     DPTR,#I2C_mstrWrBufIndex
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 791
0005         ?C0092:
0005 22                RET     
             ; FUNCTION I2C_MasterGetWriteBufSize (END)

             ; FUNCTION I2C_MasterClearReadBuf (BEGIN)
                                           ; SOURCE LINE # 817
                                           ; SOURCE LINE # 818
                                           ; SOURCE LINE # 819
0000 9044C9            MOV     DPTR,#044C9H
0003 7480              MOV     A,#080H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 821
0006 E4                CLR     A
0007 900000      R     MOV     DPTR,#I2C_mstrRdBufIndex
000A F0                MOVX    @DPTR,A
C51 COMPILER V9.51   I2C_MASTER                                                            10/22/2015 22:07:40 PAGE 28  

                                           ; SOURCE LINE # 822
000B 900000      R     MOV     DPTR,#I2C_mstrStatus
000E E0                MOVX    A,@DPTR
000F 54FE              ANL     A,#0FEH
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 824
0012 9044C1            MOV     DPTR,#044C1H
0015 7480              MOV     A,#080H
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 825
0018 22                RET     
             ; FUNCTION I2C_MasterClearReadBuf (END)

             ; FUNCTION I2C_MasterClearWriteBuf (BEGIN)
                                           ; SOURCE LINE # 851
                                           ; SOURCE LINE # 852
                                           ; SOURCE LINE # 853
0000 9044C9            MOV     DPTR,#044C9H
0003 7480              MOV     A,#080H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 855
0006 E4                CLR     A
0007 900000      R     MOV     DPTR,#I2C_mstrWrBufIndex
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 856
000B 900000      R     MOV     DPTR,#I2C_mstrStatus
000E E0                MOVX    A,@DPTR
000F 54FD              ANL     A,#0FDH
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 858
0012 9044C1            MOV     DPTR,#044C1H
0015 7480              MOV     A,#080H
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 859
0018 22                RET     
             ; FUNCTION I2C_MasterClearWriteBuf (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    771    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     12      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
